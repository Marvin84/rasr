<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Sprint: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sprint
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000099"></a>Member <a class="el" href="classAcousticModelTrainer.html#ab8305b794b961a69f5972c675bfb6a86">AcousticModelTrainer::scoreAffineFeatureTransform2</a>  ()</dt>
<dd>give these functions a more descriptive name!  </dd>
<dt><a class="anchor" id="_todo000046"></a>Member <a class="el" href="classAdvancedTreeSearch_1_1AcousticLookAhead.html#ab4c6cd657dfbe597f3e951a7143c247b">AdvancedTreeSearch::AcousticLookAhead::initializeModels</a>  (<a class="el" href="structEmissionSetCounter.html">EmissionSetCounter</a> sets)</dt>
<dd><p class="startdd">Introduce weights for the splits, try out the better models again </p>
<p class="enddd">Make this the only representation  </p>
</dd>
<dt><a class="anchor" id="_todo000052"></a>Member <a class="el" href="classAdvancedTreeSearch_1_1LanguageModelLookahead.html#a0191843db85823fe373ec3db8f23cb97">AdvancedTreeSearch::LanguageModelLookahead::computeScoresSparse</a>  (<a class="el" href="classAdvancedTreeSearch_1_1LanguageModelLookahead_1_1ContextLookahead.html">ContextLookahead</a> &amp;lookahead) const </dt>
<dd>Not required once tables are managed properly  </dd>
<dt><a class="anchor" id="_todo000053"></a>Member <a class="el" href="classAdvancedTreeSearch_1_1LanguageModelLookahead.html#a0dabcfdd7eb6370bb09696eee7bbf08e">AdvancedTreeSearch::LanguageModelLookahead::fill</a>  (ContextLookaheadReference lah, bool sparse=false, bool approx=false)</dt>
<dd>If another thread is filling this table, wait  </dd>
<dt><a class="anchor" id="_todo000001"></a>Member <a class="el" href="classAm_1_1AcousticModel.html#a142d4b48d710c41dc41a9fd973515b21">Am::AcousticModel::nStateTransitions</a>  () const =0</dt>
<dd>Concept of transition tying not complete yet!  </dd>
<dt><a class="anchor" id="_todo000002"></a>Member <a class="el" href="classAm_1_1AdaptationTree.html#af77d3ac42518d29ff6024aa976acf843">Am::AdaptationTree::loadDecisionTree</a>  (const <a class="el" href="classCore_1_1Configuration.html" title="Central configuration class. ">Core::Configuration</a> &amp;config, const Am::ClassicStateModelRef stateModel, Bliss::Phoneme::Id silencePhoneme)</dt>
<dd>change if silence is handled correctly by dectree  </dd>
<dt><a class="anchor" id="_todo000049"></a>Member <a class="el" href="classAsymmetricIntersectionIterator.html#aef8fa28b6fb577afd46dc15f7ce97a6c">AsymmetricIntersectionIterator&lt; T &gt;::match</a>  ()</dt>
<dd>Think out some optimized inverted logic when lengthA &gt; lengthB  </dd>
<dt><a class="anchor" id="_todo000004"></a>Member <a class="el" href="classAudio_1_1OpenSoundSystemOutputNode.html#a1038e0ca870f90bee37462d09413f76c">Audio::OpenSoundSystemOutputNode::write</a>  (const <a class="el" href="classFlow_1_1Data.html" title="Base class for Data class in Flow Features: -Multithread safe reference counting. ...">Flow::Data</a> *)</dt>
<dd>Should look at datatype not at sample size.  </dd>
<dt><a class="anchor" id="_todo000005"></a>Member <a class="el" href="classAudio_1_1WavOutputNode.html#a65ebec19cd1021304a72829a73623531">Audio::WavOutputNode::write</a>  (const <a class="el" href="classFlow_1_1Data.html" title="Base class for Data class in Flow Features: -Multithread safe reference counting. ...">Flow::Data</a> *)</dt>
<dd>Should look at datatype not at sample size.  </dd>
<dt><a class="anchor" id="_todo000012"></a>File <a class="el" href="BinaryStream_8hh.html">BinaryStream.hh</a>  </dt>
<dd><p class="startdd">CodeSmell: wrapper and file stream roles should be separated: BinaryWriter/Reader vs.</p>
<p class="enddd">CodeSmell: wrapper and file stream roles should be separated: BinaryWriter/Reader vs. </p>
</dd>
<dt><a class="anchor" id="_todo000006"></a>Class <a class="el" href="classBliss_1_1LemmaPronunciation.html">Bliss::LemmaPronunciation</a>  </dt>
<dd>pronunciation probabilities are quite slow due to repeated calculation of logarithm  </dd>
<dt><a class="anchor" id="_todo000008"></a>Member <a class="el" href="classBliss_1_1PhonemeInventory.html#aa6e02d289b672ebfa7d6d344bb709001">Bliss::PhonemeInventory::writeBinary</a>  (<a class="el" href="classCore_1_1BinaryOutputStream.html" title="BinaryOutputStream. ">Core::BinaryOutputStream</a> &amp;) const </dt>
<dd><a class="el" href="classBliss_1_1PhonemeInventory.html#aa6e02d289b672ebfa7d6d344bb709001">PhonemeInventory::writeBinary</a> not implemented  </dd>
<dt><a class="anchor" id="_todo000007"></a>Class <a class="el" href="classBliss_1_1SyntacticToken.html">Bliss::SyntacticToken</a>  </dt>
<dd>class emission probabilities are quite slow due to repeated calculation of logarithm  </dd>
<dt><a class="anchor" id="_todo000009"></a>Member <a class="el" href="structCart_1_1FloatBox_1_1HashFcn.html#af58932f4e22e62d5f96d290c1ffae098">Cart::FloatBox::HashFcn::operator()</a>  (const <a class="el" href="classCart_1_1FloatBox.html" title="An efficient implementation of a 2-dim matrix. ">FloatBox</a> &amp;val) const </dt>
<dd>the hash function should be checked/improved some time  </dd>
<dt><a class="anchor" id="_todo000010"></a>Member <a class="el" href="structCart_1_1Properties_1_1HashFcn.html#acdfbacd383f7912371077e5d3a4ee219">Cart::Properties::HashFcn::operator()</a>  (const <a class="el" href="classCart_1_1Properties.html" title="Abstract set of properties, i.e. ">Properties</a> &amp;props) const </dt>
<dd>the hash function should be checked/improved some time  </dd>
<dt><a class="anchor" id="_todo000013"></a>Member <a class="el" href="classCore_1_1Channel.html#a45ea14b25e630d98a5a6af0750b8093e">Core::Channel::Channel</a>  (const <a class="el" href="classCore_1_1Configuration.html" title="Central configuration class. ">Configuration</a> &amp;, const std::string &amp;name, Default defaultTarget=disabled, TargetType __type=plainTarget)</dt>
<dd>should prevent deletion in destructor.  </dd>
<dt><a class="anchor" id="_todo000014"></a>Member <a class="el" href="classCore_1_1Component.html#ae96fa666c46f56fc1d779d6c54c9aae2">Core::Component::vErrorMessage</a>  (ErrorType mt, const char *msg, va_list) const </dt>
<dd>strerror() is not thread safe. But strerror_r() does not seems to work.  </dd>
<dt><a class="anchor" id="_todo000016"></a>Member <a class="el" href="classCore_1_1FileArchive.html#a79e6a5603fe7b2535f2dbca1761a8831">Core::FileArchive::remove</a>  (const std::string &amp;name)</dt>
<dd>merge empty segments  </dd>
<dt><a class="anchor" id="_todo000017"></a>Member <a class="el" href="classCore_1_1FileArchive.html#a83b8fcf86854ac3a5e8907af4864f1bc">Core::FileArchive::write</a>  (const std::string &amp;name, const std::string &amp;b, const Sizes &amp;sizes)</dt>
<dd>improve empty block usage  </dd>
<dt><a class="anchor" id="_todo000096"></a>Class <a class="el" href="classCore_1_1NameHelper_3_01Speech_1_1ConstSegmentwiseFeaturesRef_01_4.html">Core::NameHelper&lt; Speech::ConstSegmentwiseFeaturesRef &gt;</a>  </dt>
<dd>the string representation of Speech::ConstSegmentwiseFeaturesRef should be speech-...  </dd>
<dt><a class="anchor" id="_todo000018"></a>Member <a class="el" href="classFlf_1_1IncrementalRecognizer.html#aa59618ec3336868a81ab8a328d4b9fb1">Flf::IncrementalRecognizer::startRecognition</a>  (const <a class="el" href="classBliss_1_1SpeechSegment.html" title="Segment of a Recording containing speech. ">Bliss::SpeechSegment</a> *segment, bool useDataSource=true)</dt>
<dd>Also check compatibility when using the backward-recognizer. However we need all features.  </dd>
<dt><a class="anchor" id="_todo000019"></a>Member <a class="el" href="classFlf_1_1Module__.html#abdb101a044754e69aa18755e5d3e9cbb">Flf::Module_::init</a>  ()</dt>
<dd>network, lexicon, processor should not be part of Flf::Module (?)  </dd>
<dt><a class="anchor" id="_todo000020"></a>Member <a class="el" href="namespaceFlf.html#a52b0aa0717b85def2e5bc9cea6e740ec">Flf::pruneByFwdBwdScores</a>  (ConstLatticeRef l, ConstFwdBwdRef fb, Score t, f32 minArcsPerSec, f32 maxArcsPerSec, s32 maxArcsPerSegment)</dt>
<dd><p class="startdd">binary search instead of static steps </p>
<p>binary search instead of static steps </p>
<p>binary search instead of static steps </p>
<p class="enddd">binary search instead of static steps  </p>
</dd>
<dt><a class="anchor" id="_todo000102"></a>Member <a class="el" href="classFlfTool.html#acaf721c574794a8ca4521acf0667bce4">FlfTool::main</a>  (const std::vector&lt; std::string &gt; &amp;arguments)</dt>
<dd>network, lexicon, processor should not be part of Flf::Module (?)  </dd>
<dt><a class="anchor" id="_todo000024"></a>Member <a class="el" href="namespaceFlow.html#a4e4c89ec91691b444ac0968aa79f92f9">Flow::paramVectorSequenceNodeReverse</a>  ("reverse","if true, indices run backwards starting at the back of the inputs", false)</dt>
<dd>check the time stamps of the input and output vectors  </dd>
<dt><a class="anchor" id="_todo000022"></a>Class <a class="el" href="classFlow_1_1VectorAbsValDumpNode.html">Flow::VectorAbsValDumpNode&lt; content &gt;</a>  </dt>
<dd>remove this node. </dd>
<dt><a class="anchor" id="_todo000023"></a>Member <a class="el" href="classFlow_1_1VectorMultNode.html#a08539d0d5a1f017aca9217ba6591c441">Flow::VectorMultNode&lt; T &gt;::merge</a>  (std::vector&lt; <a class="el" href="classFlow_1_1DataPtr.html" title="Class template for Data smart pointers Extends the features of Core::TsRef by: -up and down cast usin...">DataPtr</a>&lt; <a class="el" href="classMath_1_1Vector.html">Vector&lt; T &gt;</a>&gt;&gt; &amp;inputData)</dt>
<dd>This would be more efficient, if vector dimensions were advertised attributes. </dd>
<dt><a class="anchor" id="_todo000025"></a>Member <a class="el" href="classFlow_1_1VectorSumNode.html#ab51c04e6c1ed2f8a7fc23e2fa3758599">Flow::VectorSumNode&lt; T &gt;::merge</a>  (std::vector&lt; <a class="el" href="classFlow_1_1DataPtr.html" title="Class template for Data smart pointers Extends the features of Core::TsRef by: -up and down cast usin...">DataPtr</a>&lt; <a class="el" href="classMath_1_1Vector.html">Vector&lt; T &gt;</a>&gt;&gt; &amp;inputData)</dt>
<dd>This would be more efficient, if vector dimensions were advertised attributes. </dd>
<dt><a class="anchor" id="_todo000101"></a>Member <a class="el" href="classFsa_1_1SimpleAlignAutomaton.html#a66ba0f546260ea3af17f71301ae49d39">Fsa::SimpleAlignAutomaton::SimpleAlignAutomaton</a>  (<a class="el" href="classCore_1_1Configuration.html" title="Central configuration class. ">Core::Configuration</a> &amp;config, const std::string &amp;source, const std::string &amp;target, const TransitionProbs &amp;transitionProbs, Translation::ConstConditionalLexiconRef lexicon, const double factorLexicon=1.0, const double factorTransition=1.0, const unsigned order=0)</dt>
<dd>null word and sentence begin padding symbol are hardcoded  </dd>
<dt><a class="anchor" id="_todo000027"></a>Member <a class="el" href="classFtl_1_1ArrayArcContainer.html#a7133a08a43b8c6cf95e1fcc23757f54a">Ftl::ArrayArcContainer&lt; _Arc &gt;::reallocate</a>  (size_t s)</dt>
<dd>: check bad alloc  </dd>
<dt><a class="anchor" id="_todo000028"></a>Member <a class="el" href="classFtl_1_1ArrayArcContainer.html#ac912f1bacafe2bb1a88c0dde04a3f9bf">Ftl::ArrayArcContainer&lt; _Arc &gt;::reallocateOneMore</a>  ()</dt>
<dd>: check bad alloc  </dd>
<dt><a class="anchor" id="_todo000029"></a>Member <a class="el" href="namespaceFtl.html#a5aeefe63720eacba752e0b701f49542f">Ftl::bestscore</a>  (typename _Automaton::ConstRef f)</dt>
<dd>make bestscore more efficient  </dd>
<dt><a class="anchor" id="_todo000031"></a>Member <a class="el" href="classFtl_1_1ClosureAutomaton.html#ae9178a307d9670eef2af5b64c2be2eb2">Ftl::ClosureAutomaton&lt; _Automaton &gt;::modifyState</a>  (_State *sp) const </dt>
<dd>existing loop weight should be collected with final weight.  </dd>
<dt><a class="anchor" id="_todo000030"></a>Member <a class="el" href="classFtl_1_1DeterminizeAutomaton_1_1Substates.html#a4de0a1cc5eaaa3bc9378c9dd08bdc89b">Ftl::DeterminizeAutomaton&lt; _Automaton &gt;::Substates::equal</a>  (Cursor pos1, Cursor pos2) const </dt>
<dd>compare without the user state tags = cycle indicators  </dd>
<dt><a class="anchor" id="_todo000032"></a>Member <a class="el" href="classFtl_1_1PushToInitialAutomaton.html#a96c4d1081e8cef2732a2ead3e725e8d1">Ftl::PushToInitialAutomaton&lt; _Automaton &gt;::PushToInitialAutomaton</a>  (_ConstAutomatonRef f, bool progress)</dt>
<dd>test ssspBackward: potentials_ = ssspBackward&lt;_Automaton&gt;(f, progress);  </dd>
<dt><a class="anchor" id="_todo000026"></a>Member <a class="el" href="classFtl_1_1StorageAutomaton.html#a8c03e4d39bb5056ccc1a87d03eb15b7d">Ftl::StorageAutomaton&lt; _Automaton &gt;::StorageAutomaton</a>  (Fsa::Type type)</dt>
<dd>: check what is correct here  </dd>
<dt><a class="anchor" id="_todo000033"></a>Member <a class="el" href="classLattice_1_1HtkReader.html#a896d9e598fa01f2c60d27effb981136c">Lattice::HtkReader::addState</a>  (<a class="el" href="structLattice_1_1HtkReader_1_1Node.html">Node</a> &amp;node)</dt>
<dd>across word model is not handled correctly yet  </dd>
<dt><a class="anchor" id="_todo000036"></a>Class <a class="el" href="classLattice_1_1Mm_1_1CachedFeatureScorer_1_1CachedContextScorerOverlay.html">Lattice::Mm::CachedFeatureScorer::CachedContextScorerOverlay</a>  </dt>
<dd>Eventually replace the cached class above by this one  </dd>
<dt><a class="anchor" id="_todo000037"></a>Class <a class="el" href="classMath_1_1FastFourierTransform.html">Math::FastFourierTransform</a>  </dt>
<dd>Optimization, e.g. use of SSE instructions  </dd>
<dt><a class="anchor" id="_todo000039"></a>Member <a class="el" href="classMm_1_1AbstractMixtureSetEstimator.html#a40c404db52ccc28adf3efb0177de704c">Mm::AbstractMixtureSetEstimator::createMixtureSpecificCovarianceEstimator</a>  ()</dt>
<dd>diagonal covariance should not be hardcoded!  </dd>
<dt><a class="anchor" id="_todo000038"></a>Member <a class="el" href="classMm_1_1AbstractMixtureSetEstimator.html#a9fba60a61c62cdfa40fe4034623255b9">Mm::AbstractMixtureSetEstimator::createPooledCovarianceEstimator</a>  ()</dt>
<dd>diagonal covariance should not be hardcoded!  </dd>
<dt><a class="anchor" id="_todo000040"></a>Class <a class="el" href="classMm_1_1CachedFeatureScorer_1_1CachedContextScorerOverlay.html">Mm::CachedFeatureScorer::CachedContextScorerOverlay</a>  </dt>
<dd>Eventually replace the cached class above by this one  </dd>
<dt><a class="anchor" id="_todo000044"></a>Class <a class="el" href="classMm_1_1FeatureScorerScaling.html">Mm::FeatureScorerScaling</a>  </dt>
<dd>: add scale to the basic feature scorer to remove the additional vtable lookup and function call for each call to score().  </dd>
<dt><a class="anchor" id="_todo000042"></a>Member <a class="el" href="classMm_1_1FullAdaptorViterbiEstimator.html#a5636fb280ead69b3f9330b1fda02eaf3">Mm::FullAdaptorViterbiEstimator::adaptor</a>  (void)</dt>
<dd>change if silence is handled correctly by dectree  </dd>
<dt><a class="anchor" id="_todo000041"></a>Member <a class="el" href="classMm_1_1MixtureSet.html#a75af7c57ef3fc10490ed329cdf661307">Mm::MixtureSet::createOneMixtureClusterCopy</a>  (const <a class="el" href="classCore_1_1Configuration.html" title="Central configuration class. ">Core::Configuration</a> &amp;clusteringConfiguration) const </dt>
<dd>Move this method to somewhere else  </dd>
<dt><a class="anchor" id="_todo000043"></a>Member <a class="el" href="classMm_1_1Module__.html#a1f534d77eb184b4ea358460e262b2966">Mm::Module_::convertMixtureSet</a>  (const <a class="el" href="classCore_1_1Configuration.html" title="Central configuration class. ">Core::Configuration</a> &amp;) const </dt>
<dd>this function needs some cleanup!  </dd>
<dt><a class="anchor" id="_todo000045"></a>Member <a class="el" href="namespaceOpenFst.html#a0de0e408c52f68d6d365222387f6ee3c">OpenFst::shortestPaths</a>  (const FstLib::Fst&lt; A &gt; &amp;fst, typename A::Weight beam, FstLib::VectorFst&lt; A &gt; *lattice)</dt>
<dd>garbage collection in the traceback: remove non-reachable states  </dd>
<dt><a class="anchor" id="_todo000064"></a>Namespace <a class="el" href="namespaceSearch.html">Search</a>  </dt>
<dd><p class="startdd">Enable batch-merging (mergeBatches_), and make sure the structure is optimal.</p>
<p class="enddd">Allow "freezing" all batches: No follower-gap in the middle (should save 1/3 of space for the batches)  </p>
</dd>
<dt><a class="anchor" id="_todo000048"></a>Member <a class="el" href="classSearch_1_1ApproxLinearIntHash.html#a753cae2e3cc1d2e25e235abd4558a8be">Search::ApproxLinearIntHash&lt; Key, invalidKey, useHashChain &gt;::insert</a>  (const Key h, const float _value)</dt>
<dd>eventually simply always use this  </dd>
<dt><a class="anchor" id="_todo000063"></a>Member <a class="el" href="classSearch_1_1HMMStateNetwork.html#a48357e3743d5c313244a915b356089da">Search::HMMStateNetwork::cleanup</a>  (std::list&lt; Search::StateId &gt; startNodes, <a class="el" href="namespaceSearch.html#a9b4630d7f0a64cb3317190d22f0bc2e4" title="Global index of a tree or subtree. ">Search::TreeIndex</a> masterTree, bool clearDeadEnds=true, bool onlyBatches=false)</dt>
<dd>Build a topology and order the nodes in a stable way based on that  </dd>
<dt><a class="anchor" id="_todo000066"></a>Member <a class="el" href="namespaceSearch.html#aaf94240d77ec07d15534b2a7d2d33174">Search::invalidTreeNodeIndex</a>  </dt>
<dd>Maybe this should be zero!  </dd>
<dt><a class="anchor" id="_todo000054"></a>Member <a class="el" href="classSearch_1_1LmCache.html#a3670d20974674d63a1b9b52aaf4a3e7b">Search::LmCache::clean</a>  ()</dt>
<dd>Make sure that the handles of the cached histories are kept alive  </dd>
<dt><a class="anchor" id="_todo000067"></a>Member <a class="el" href="classSearch_1_1Module__.html#af2ba8903b9ec2adbcff80c20c007b77f">Search::Module_::createLatticeHandler</a>  (const <a class="el" href="classCore_1_1Configuration.html" title="Central configuration class. ">Core::Configuration</a> &amp;c) const </dt>
<dd>: add <a class="el" href="classFlf_1_1LatticeHandler.html">Flf::LatticeHandler</a>? This would add a dependency to module <a class="el" href="namespaceFlf.html" title="Copyright 2020 RWTH Aachen University. ">Flf</a> without actual benefit.  </dd>
<dt><a class="anchor" id="_todo000056"></a>Member <a class="el" href="classSearch_1_1PersistentStateTree.html#a97a147378e3f6b447528b4b8a0df5c4d">Search::PersistentStateTree::cleanup</a>  (bool cleanupExits=true)</dt>
<dd><p class="startdd">Go through the search tree, and collect the required coarticulated root nodes </p>
<p class="enddd">Also add the overall root node to coarticulatedRootNodes, then this is not needed  </p>
</dd>
<dt><a class="anchor" id="_todo000055"></a>Member <a class="el" href="classSearch_1_1PersistentStateTree.html#a7a987244f34dde7ab308ce18b9660204">Search::PersistentStateTree::read</a>  (<a class="el" href="classCore_1_1MappedArchiveReader.html">Core::MappedArchiveReader</a> reader)</dt>
<dd>Eventually do memory-mapping  </dd>
<dt><a class="anchor" id="_todo000062"></a>Member <a class="el" href="classSearch_1_1SearchSpace.html#a0bbf5efe01c4d2e4dfa00aa41b9d6501">Search::SearchSpace::getBackOffInstance</a>  (<a class="el" href="structSearch_1_1Instance.html">Instance</a> *instance)</dt>
<dd>Möglicherweise wird der falsche backoff-score angewandt. Es sollte der score für die verkürzte history benutzt werden.  </dd>
<dt><a class="anchor" id="_todo000061"></a>Member <a class="el" href="classSearch_1_1SearchSpace.html#a5671907afc1ce556e295809b95e48b9b">Search::SearchSpace::getSentenceEndFallBack</a>  (TimeframeIndex time, bool shallCreateLattice)</dt>
<dd>This does not create a lattice for the last word. However a lattice structure is given for the previous words.  </dd>
<dt><a class="anchor" id="_todo000060"></a>Member <a class="el" href="classSearch_1_1SearchSpace.html#ab77cd1049aaf29b247e51d33d37182c9">Search::SearchSpace::hypothesizeEpsilonPronunciations</a>  (Score bestScore)</dt>
<dd>Un-copy this code  </dd>
<dt><a class="anchor" id="_todo000068"></a>Member <a class="el" href="classStateTree_1_1SuffixSet.html#a26e68d95f236e2ec90f9d0f01d7b6133">Search::StateTree::SuffixSet::partition</a>  (SuffixSetList &amp;conts) const </dt>
<dd>Change the hash structure, instead of abusing TransitionModelIndex  </dd>
<dt><a class="anchor" id="_todo000058"></a>Member <a class="el" href="classSearch_1_1StaticSearchAutomaton.html#aebd306dd8bd74e326b91e5d8f07ad515">Search::StaticSearchAutomaton::buildNetwork</a>  ()</dt>
<dd>Track the <a class="el" href="classTreeBuilder.html">TreeBuilder</a> configuration in transformation if minimizedTree  </dd>
<dt><a class="anchor" id="_todo000059"></a>Member <a class="el" href="classSearch_1_1StaticSearchAutomaton.html#a3e933703b79b04eb5958ad7f67e4c78f">Search::StaticSearchAutomaton::fillStateDepths</a>  (<a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee" title="Index of a state or label (see IS_LABEL, ID_FROM_LABEL, and LABEL_FROM_ID) ">Search::StateId</a> state, int depth)</dt>
<dd>Find out why this happens on some languages  </dd>
<dt><a class="anchor" id="_todo000069"></a>Member <a class="el" href="classCompressedNetwork_1_1Builder.html#a810f7e11ea2f333f36021ac4e55677b7">Search::Wfst::CompressedNetwork::Builder&lt; Automaton &gt;::createArcs</a>  (typename Automaton::StateId stateId, Fsa::Stack&lt; typename Automaton::StateId &gt; &amp;statesToExplore)</dt>
<dd>check: do not expand any epsilon arc  </dd>
<dt><a class="anchor" id="_todo000071"></a>Member <a class="el" href="classSearch_1_1Wfst_1_1DynamicGrammarFst.html#af3213245db666da65f6d25e55b731382">Search::Wfst::DynamicGrammarFst::reset</a>  ()</dt>
<dd>add parameter  </dd>
<dt><a class="anchor" id="_todo000070"></a>Member <a class="el" href="classSearch_1_1Wfst_1_1DynamicLmFstImpl.html#a39a0cdf51f43458f541ab659df8352db">Search::Wfst::DynamicLmFstImpl::Final</a>  (StateId s)</dt>
<dd>: add option for explicit sentence end tokens  </dd>
<dt><a class="anchor" id="_todo000072"></a>Member <a class="el" href="classSearch_1_1Wfst_1_1LatticeWeight.html#a96fc100630944f6950df4d4a3503d565">Search::Wfst::LatticeWeight::Properties</a>  ()</dt>
<dd>: check properties  </dd>
<dt><a class="anchor" id="_todo000074"></a>Member <a class="el" href="classSearch_1_1Wfst_1_1SearchSpace.html#a333d7af3d7b4b456cf8d82a165f9ebc3">Search::Wfst::SearchSpace&lt; N, S &gt;::feed</a>  (const Mm::FeatureScorer::Scorer &amp;scorer)</dt>
<dd>add latticePruningInterval_  </dd>
<dt><a class="anchor" id="_todo000075"></a>Member <a class="el" href="classSearch_1_1Wfst_1_1SearchSpaceBase.html#a46c4534c76db2080988bf4e16fc34772">Search::Wfst::SearchSpaceBase::StateToHypMap</a>  </dt>
<dd>replace by another container  </dd>
<dt><a class="anchor" id="_todo000083"></a>Member <a class="el" href="classSignal_1_1CorrFullCovMonoGaussianModel.html#a861bf9f2ab50e4eaf3f0e04a998ecfc1">Signal::CorrFullCovMonoGaussianModel::refresh</a>  ()</dt>
<dd>: this should be a private function  </dd>
<dt><a class="anchor" id="_todo000082"></a>Member <a class="el" href="classSignal_1_1CorrFullCovMonoGaussianModel.html#ae7c21affdc9287d35c932514006f8798">Signal::CorrFullCovMonoGaussianModel::relativeFeatureNormalize</a>  (f32 weight)</dt>
<dd>: this should be a private function  </dd>
<dt><a class="anchor" id="_todo000078"></a>Class <a class="el" href="classSignal_1_1FullCovMonoGaussianModel.html">Signal::FullCovMonoGaussianModel</a>  </dt>
<dd>: this class should be derived from the abstract <a class="el" href="classSignal_1_1DiagCovMonoGaussianModel.html">DiagCovMonoGaussianModel</a> class  </dd>
<dt><a class="anchor" id="_todo000080"></a>Member <a class="el" href="classSignal_1_1FullCovMonoGaussianModel.html#a1b92c06c576e2134af8b288f583d38cf">Signal::FullCovMonoGaussianModel::mergeMeans</a>  (const <a class="el" href="classSignal_1_1FullCovMonoGaussianModel.html">FullCovMonoGaussianModel</a> &amp;x, const <a class="el" href="classSignal_1_1FullCovMonoGaussianModel.html">FullCovMonoGaussianModel</a> &amp;y)</dt>
<dd>: this should be a private function?  </dd>
<dt><a class="anchor" id="_todo000081"></a>Member <a class="el" href="classSignal_1_1FullCovMonoGaussianModel.html#aecb7bb791c8d4feb6fb7bb2346fbb87e">Signal::FullCovMonoGaussianModel::mergeVariance</a>  (const <a class="el" href="classSignal_1_1FullCovMonoGaussianModel.html">FullCovMonoGaussianModel</a> &amp;x, const <a class="el" href="classSignal_1_1FullCovMonoGaussianModel.html">FullCovMonoGaussianModel</a> &amp;y)</dt>
<dd>: this should be a private function?  </dd>
<dt><a class="anchor" id="_todo000076"></a>Member <a class="el" href="classSignal_1_1RegressionNode.html#ab55b2af643408d5aacd021b883d445f4">Signal::RegressionNode::merge</a>  (std::vector&lt; Precursor::InputFrame &gt; &amp;)</dt>
<dd>This would be more efficient, if vector dimensions were advertised attributes. </dd>
<dt><a class="anchor" id="_todo000079"></a>Class <a class="el" href="classSignal_1_1SegmentClustering.html">Signal::SegmentClustering&lt; Model &gt;</a>  </dt>
<dd>: class is derive from component now, so ppplication logging should be done via the info channel  </dd>
<dt><a class="anchor" id="_todo000084"></a>Member <a class="el" href="classSignal_1_1SegmentClustering.html#ae216c089fdb9a54dc740fc77d6b85b32">Signal::SegmentClustering&lt; Model &gt;::SegmentClustering</a>  (const <a class="el" href="classCore_1_1Configuration.html" title="Central configuration class. ">Core::Configuration</a> &amp;c)</dt>
<dd>: -99999.9 is maybe not the best value ... </dd>
<dt><a class="anchor" id="_todo000085"></a>Member <a class="el" href="classSignal_1_1SegmentClusteringNode.html#a4261ca81bd8bdddbe5151bd17f42444e">Signal::SegmentClusteringNode&lt; Model &gt;::~SegmentClusteringNode</a>  ()</dt>
<dd>: ugly, this should be moved to the work method, but how?  </dd>
<dt><a class="anchor" id="_todo000087"></a>Class <a class="el" href="classSignal_1_1TimeWindowBuffer.html">Signal::TimeWindowBuffer&lt; T &gt;</a>  </dt>
<dd>Code duplication: <a class="el" href="classSignal_1_1WindowBuffer.html" title="WindowBuffer is buffer collecting vectors of samples and delivering (overlapping) segments of a given...">WindowBuffer</a> should be a template instance: TWindowBuffer&lt;f32&gt;  </dd>
<dt><a class="anchor" id="_todo000086"></a>File <a class="el" href="SilenceDetection_8hh.html">SilenceDetection.hh</a>  </dt>
<dd><a class="el" href="classSignal_1_1SilenceDetection.html">SilenceDetection</a> not tested yet. </dd>
<dt><a class="anchor" id="_todo000088"></a>Namespace <a class="el" href="namespaceSparse.html">Sparse</a>  </dt>
<dd>rename this file to Vector.hh  </dd>
<dt><a class="anchor" id="_todo000090"></a>Member <a class="el" href="classSpeech_1_1AffineFeatureTransformEstimator.html#a7af85bd3e59cb2331254d109fed6de19">Speech::AffineFeatureTransformEstimator::postProcess</a>  ()</dt>
<dd>this is a more or less diry hack. what we want to do here is to modify the object without writing the modification back to cache  </dd>
<dt><a class="anchor" id="_todo000092"></a>Member <a class="el" href="classSpeech_1_1DistanceLatticeRescorer.html#a5e07e9247f6dd445f17a8303f5f76ee2">Speech::DistanceLatticeRescorer::createDistanceLatticeRescorer</a>  (const <a class="el" href="classCore_1_1Configuration.html" title="Central configuration class. ">Core::Configuration</a> &amp;, Bliss::LexiconRef)</dt>
<dd>: move ?  </dd>
<dt><a class="anchor" id="_todo000091"></a>Member <a class="el" href="classSpeech_1_1LatticeArcAccumulatorNode.html#a9fa1a78cf0ede4cb7d9f0e13a5232365">Speech::LatticeArcAccumulatorNode::~LatticeArcAccumulatorNode</a>  ()</dt>
<dd>: don't change the lexicon, change only the written file  </dd>
<dt><a class="anchor" id="_todo000093"></a>Member <a class="el" href="classSpeech_1_1ModelCombination.html#a5827457efff9bf44b9c8277271f8b969">Speech::ModelCombination::ModelCombination</a>  (const <a class="el" href="classCore_1_1Configuration.html" title="Central configuration class. ">Core::Configuration</a> &amp;, Mode=complete, Am::AcousticModel::Mode=Am::AcousticModel::complete)</dt>
<dd>Scalable lexicon not implemented yet  </dd>
<dt><a class="anchor" id="_todo000095"></a>Member <a class="el" href="classSpeech_1_1OfflineRecognizer.html#ad501650677b32f24a1823e82e9a0e65f">Speech::OfflineRecognizer::processResult</a>  (<a class="el" href="classBliss_1_1SpeechSegment.html" title="Segment of a Recording containing speech. ">Bliss::SpeechSegment</a> *s)</dt>
<dd>Should stop timer here: evaluation may take some time we don't want to count it.  </dd>
<dt><a class="anchor" id="_todo000094"></a>Member <a class="el" href="classSpeech_1_1PhonemeSequenceAlignmentGenerator_1_1Cache.html#a423535b3ef82f356689345728652d5f4">Speech::PhonemeSequenceAlignmentGenerator::Cache::initializeArchive</a>  (const <a class="el" href="classSpeech_1_1ModelCombination.html" title="Combination of a lexicon, an acoustic model, and a language model. ">ModelCombination</a> &amp;)</dt>
<dd>missing dependency: pruning parameters  </dd>
<dt><a class="anchor" id="_todo000098"></a>Member <a class="el" href="classSpeech_1_1SegmentwiseGmmTrainer.html#ab8104ce9b04a231d8139a1f125911cf3">Speech::SegmentwiseGmmTrainer::createSegmentwiseGmmTrainer</a>  (const <a class="el" href="classCore_1_1Configuration.html" title="Central configuration class. ">Core::Configuration</a> &amp;)</dt>
<dd>: remove  </dd>
<dt><a class="anchor" id="_todo000089"></a>Member <a class="el" href="classSpeech_1_1TiedTextDependentMixtureSetTrainer.html#abdbffa0963427ae59cfaffc8240a282c">Speech::TiedTextDependentMixtureSetTrainer::setFeatureDescription</a>  (const <a class="el" href="classMm_1_1FeatureDescription.html" title="Vector of stream descriptions Stream description is a set of attributes describing a feature stream...">Mm::FeatureDescription</a> &amp;)</dt>
<dd>Allow specifying the training-data multiplication factor directly (probably needs binary search)  </dd>
<dt><a class="anchor" id="_todo000003"></a>Member <a class="el" href="classTransitionModel_1_1Applicator.html#a77106d98a7b9b8ab8f1c4087339e1b15">TransitionModel::Applicator::stateType</a>  (<a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53" title="label indices and special symbols ">Fsa::LabelId</a> emission) const </dt>
<dd>proper distinction between phone-1 and phone-2 states  </dd>
<dt><a class="anchor" id="_todo000100"></a>Member <a class="el" href="classTranslation_1_1ConditionalLexiconSri.html#ae84cfe93f08cc2900de59ba9c5e7822d">Translation::ConditionalLexiconSri::ConditionalLexiconSri</a>  (const <a class="el" href="classCore_1_1Configuration.html" title="Central configuration class. ">Core::Configuration</a> &amp;config)</dt>
<dd>sentence begin symbol is hardcoded  </dd>
<dt><a class="anchor" id="_todo000051"></a>Class <a class="el" href="structWeightedDistributedStandardHash.html">WeightedDistributedStandardHash&lt; Hash &gt;</a>  </dt>
<dd>MixedHash: Einfach die indizes zufällig durchwürfeln </dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
