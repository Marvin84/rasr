<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Sprint: Lattice::Core Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sprint
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLattice.html">Lattice</a></li><li class="navelem"><a class="el" href="namespaceLattice_1_1Core.html">Core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Lattice::Core Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Copyright 2020 RWTH Aachen University.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1absoluteValue.html">absoluteValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structLattice_1_1Core_1_1absoluteValue.html" title="absoluteValue: functor for absolute value ">absoluteValue</a>: functor for absolute value  <a href="structLattice_1_1Core_1_1absoluteValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1AbstractChoiceParameter.html">AbstractChoiceParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class template for multiple-choice parameters.  <a href="classLattice_1_1Core_1_1AbstractChoiceParameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1AbstractParameter.html">AbstractParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for parameter declaration.  <a href="classLattice_1_1Core_1_1AbstractParameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Application.html">Application</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLattice_1_1Core_1_1Application.html" title="Application class: ">Application</a> class:  <a href="classLattice_1_1Core_1_1Application.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1BinaryInputStream.html">BinaryInputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLattice_1_1Core_1_1BinaryInputStream.html" title="BinaryInputStream. ">BinaryInputStream</a>.  <a href="classLattice_1_1Core_1_1BinaryInputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1BinaryInputStreams.html">BinaryInputStreams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1BinaryOutputStream.html">BinaryOutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLattice_1_1Core_1_1BinaryOutputStream.html" title="BinaryOutputStream. ">BinaryOutputStream</a>.  <a href="classLattice_1_1Core_1_1BinaryOutputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1BinaryStream.html">BinaryStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1BinaryStreamIos.html">BinaryStreamIos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Channel.html">Channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLattice_1_1Core_1_1Configurable.html" title="Abstract base class for run-time configurable classes. ">Configurable</a> text output stream.  <a href="classLattice_1_1Core_1_1Channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1CharsetConverter.html">CharsetConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Choice.html">Choice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLattice_1_1Core_1_1Choice.html" title="Choice class. ">Choice</a> class.  <a href="classLattice_1_1Core_1_1Choice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1ChoiceStatistics.html">ChoiceStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Component.html">Component</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for configurable components with logging and error logging facilities.  <a href="classLattice_1_1Core_1_1Component.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1composedBinaryFunction.html">composedBinaryFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for f(g(x), h(y))  <a href="classLattice_1_1Core_1_1composedBinaryFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Condition.html">Condition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A condition variable.  <a href="classLattice_1_1Core_1_1Condition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Configurable.html">Configurable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for run-time configurable classes.  <a href="classLattice_1_1Core_1_1Configurable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Configuration.html">Configuration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Central configuration class.  <a href="classLattice_1_1Core_1_1Configuration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1conversion.html">conversion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic unary functor for type conversion.  <a href="structLattice_1_1Core_1_1conversion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Dependable.html">Dependable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Dependency.html">Dependency</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1DependencySet.html">DependencySet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Description.html">Description</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of stream descriptions <a class="el" href="classLattice_1_1Core_1_1Description_1_1Stream.html">Stream</a> descriptions if a set of attributes describing a (feature) stream.  <a href="classLattice_1_1Core_1_1Description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1HashMap.html">HashMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1HistogramStatistics.html">HistogramStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A histogram statistics class for simple unsigned integers.  <a href="classLattice_1_1Core_1_1HistogramStatistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1LockingPointer.html">LockingPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread-safety smart pointer.  <a href="classLattice_1_1Core_1_1LockingPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1maximum.html">maximum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">max: functor for max function  <a href="structLattice_1_1Core_1_1maximum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1minimum.html">minimum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">min: functor for min function  <a href="structLattice_1_1Core_1_1minimum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Mutex.html">Mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutex.  <a href="classLattice_1_1Core_1_1Mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1MutexLock.html">MutexLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock mutex in current scope.  <a href="classLattice_1_1Core_1_1MutexLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1NameHelper.html">NameHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this class for naming your basic classes.  <a href="classLattice_1_1Core_1_1NameHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1NameHelper_3_01bool_01_4.html">NameHelper&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1NameHelper_3_01Mm_1_1AbstractMixtureSet_01_4.html">NameHelper&lt; Mm::AbstractMixtureSet &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1NameHelper_3_01Mm_1_1MixtureSet_01_4.html">NameHelper&lt; Mm::MixtureSet &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1NameHelper_3_01std_1_1complex_3_01T_01_4_01_4.html">NameHelper&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1NameHelper_3_01std_1_1string_01_4.html">NameHelper&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1NameHelper_3_01std_1_1vector_3_01T_01_4_01_4.html">NameHelper&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Parameter.html">Parameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class template for parameter declaration.  <a href="classLattice_1_1Core_1_1Parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1ParameterBitVector.html">ParameterBitVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration class for bit vector parameters.  <a href="classLattice_1_1Core_1_1ParameterBitVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1ParameterBool.html">ParameterBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration class for boolean valued parameters.  <a href="classLattice_1_1Core_1_1ParameterBool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1ParameterChoice.html">ParameterChoice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration class for discrete multiple-choice parameters.  <a href="classLattice_1_1Core_1_1ParameterChoice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1ParameterFloat.html">ParameterFloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration class for floating point parameters.  <a href="classLattice_1_1Core_1_1ParameterFloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1ParameterFloatVector.html">ParameterFloatVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration class for float vector parameters.  <a href="classLattice_1_1Core_1_1ParameterFloatVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1ParameterInt.html">ParameterInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration class for integer valued parameters.  <a href="classLattice_1_1Core_1_1ParameterInt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1ParameterIntVector.html">ParameterIntVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration class for int vector parameters.  <a href="classLattice_1_1Core_1_1ParameterIntVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1ParameterString.html">ParameterString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration class for string parameters.  <a href="classLattice_1_1Core_1_1ParameterString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1ParameterStringVector.html">ParameterStringVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration class for string vector parameters.  <a href="classLattice_1_1Core_1_1ParameterStringVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1ParameterWeightVector.html">ParameterWeightVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration class for weight vector parameters.  <a href="classLattice_1_1Core_1_1ParameterWeightVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1PointerHash.html">PointerHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1power.html">power</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">power: functor for pow function  <a href="structLattice_1_1Core_1_1power.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1RangedParameter.html">RangedParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class template for parameters with lower und upper bounds.  <a href="classLattice_1_1Core_1_1RangedParameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1ReadWriteLock.html">ReadWriteLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read-write lock.  <a href="classLattice_1_1Core_1_1ReadWriteLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Ref.html">Ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class template for smart pointers using intrusive reference-counting.  <a href="classLattice_1_1Core_1_1Ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1ReferenceCounted.html">ReferenceCounted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for reference-counted objects.  <a href="classLattice_1_1Core_1_1ReferenceCounted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Statistics.html">Statistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1StringEquality.html">StringEquality</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1StringHash.html">StringHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1StringHashMap.html">StringHashMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1StringHashSet.html">StringHashSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1TextInputStream.html">TextInputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream for text input.  <a href="classLattice_1_1Core_1_1TextInputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1TextOutputStream.html">TextOutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream for text output.  <a href="classLattice_1_1Core_1_1TextOutputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Thread.html">Thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract <a class="el" href="classLattice_1_1Core_1_1Thread.html" title="Abstract Thread. ">Thread</a>.  <a href="classLattice_1_1Core_1_1Thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1tied.html">tied</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper for conveniently assigning the two values from a pair into separate variables.  <a href="classLattice_1_1Core_1_1tied.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1Timer.html">Timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1Type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static information about elementary types.  <a href="structLattice_1_1Core_1_1Type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1Type_3_01f32_01_4.html">Type&lt; f32 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1Type_3_01f64_01_4.html">Type&lt; f64 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1Type_3_01s16_01_4.html">Type&lt; s16 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1Type_3_01s32_01_4.html">Type&lt; s32 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1Type_3_01s64_01_4.html">Type&lt; s64 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1Type_3_01s8_01_4.html">Type&lt; s8 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1Type_3_01u16_01_4.html">Type&lt; u16 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1Type_3_01u32_01_4.html">Type&lt; u32 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1Type_3_01u64_01_4.html">Type&lt; u64 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLattice_1_1Core_1_1Type_3_01u8_01_4.html">Type&lt; u8 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1UnicodeInputConverter.html">UnicodeInputConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converter for reading text data.  <a href="classLattice_1_1Core_1_1UnicodeInputConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1UnicodeOutputConverter.html">UnicodeOutputConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converter for writing text data.  <a href="classLattice_1_1Core_1_1UnicodeOutputConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1VectorParameter.html">VectorParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class template for vector parameter declaration.  <a href="classLattice_1_1Core_1_1VectorParameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1VersionRegistry.html">VersionRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to source code version information.  <a href="classLattice_1_1Core_1_1VersionRegistry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1WeakRef.html">WeakRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class template for smart pointers provining weak referencing.  <a href="classLattice_1_1Core_1_1WeakRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1WeakRefBase.html">WeakRefBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of the <a class="el" href="classLattice_1_1Core_1_1WeakRef.html" title="Class template for smart pointers provining weak referencing. ">WeakRef</a> template.  <a href="classLattice_1_1Core_1_1WeakRefBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1XmlAttribute.html">XmlAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming objects for XML output.  <a href="classLattice_1_1Core_1_1XmlAttribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1XmlBlank.html">XmlBlank</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A blank character.  <a href="classLattice_1_1Core_1_1XmlBlank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1XmlChannel.html">XmlChannel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLattice_1_1Core_1_1Configurable.html" title="Abstract base class for run-time configurable classes. ">Configurable</a> XML output stream.  <a href="classLattice_1_1Core_1_1XmlChannel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1XmlClose.html">XmlClose</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1XmlCloseComment.html">XmlCloseComment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1XmlComment.html">XmlComment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1XmlEmpty.html">XmlEmpty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1XmlFull.html">XmlFull</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1XmlOpen.html">XmlOpen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1XmlOpenComment.html">XmlOpenComment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1XmlOutputStream.html">XmlOutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream for writing XML files.  <a href="classLattice_1_1Core_1_1XmlOutputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLattice_1_1Core_1_1XmlWriter.html">XmlWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream adaptor for producing XML output.  <a href="classLattice_1_1Core_1_1XmlWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a93530755c306d4850dbdd23154e65dcb"><td class="memTemplParams" colspan="2">template&lt;size_t size&gt; </td></tr>
<tr class="memitem:a93530755c306d4850dbdd23154e65dcb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a93530755c306d4850dbdd23154e65dcb">swapEndianess</a> (void *buf, size_t count=1)</td></tr>
<tr class="memdesc:a93530755c306d4850dbdd23154e65dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change endianess of a block of data.  <a href="#a93530755c306d4850dbdd23154e65dcb">More...</a><br /></td></tr>
<tr class="separator:a93530755c306d4850dbdd23154e65dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea743ed48529fd6372e213a024bb32c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="aea743ed48529fd6372e213a024bb32c4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aea743ed48529fd6372e213a024bb32c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swapEndianess&lt; 1 &gt;</b> (void *buf, size_t count)</td></tr>
<tr class="separator:aea743ed48529fd6372e213a024bb32c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d32932d9d88a94cfb55bb1714343f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a86d32932d9d88a94cfb55bb1714343f9">normalizeWhitespace</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:a86d32932d9d88a94cfb55bb1714343f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition: A string has "normalized whitespace" if and only if it matches one the following regular expressions: (+ )* or (+ )* + where  matches any non-whitespace character.  <a href="#a86d32932d9d88a94cfb55bb1714343f9">More...</a><br /></td></tr>
<tr class="separator:a86d32932d9d88a94cfb55bb1714343f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f4d09204cb08adfefba928d0fc6ecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a31f4d09204cb08adfefba928d0fc6ecb">enforceTrailingBlank</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:a31f4d09204cb08adfefba928d0fc6ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that a string ends with a single blank character.  <a href="#a31f4d09204cb08adfefba928d0fc6ecb">More...</a><br /></td></tr>
<tr class="separator:a31f4d09204cb08adfefba928d0fc6ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae994ba10c3cd9452007937fcb929df64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#ae994ba10c3cd9452007937fcb929df64">suppressTrailingBlank</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:ae994ba10c3cd9452007937fcb929df64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove trailing blank character.  <a href="#ae994ba10c3cd9452007937fcb929df64">More...</a><br /></td></tr>
<tr class="separator:ae994ba10c3cd9452007937fcb929df64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada36bc5027686a9d1ad270996b6474e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#ada36bc5027686a9d1ad270996b6474e7">isWhitespaceNormalized</a> (const std::string &amp;s, char trailingBlank=prohibitTrailingBlank)</td></tr>
<tr class="memdesc:ada36bc5027686a9d1ad270996b6474e7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceTest.html" title="Copyright 2020 RWTH Aachen University. ">Test</a> if a string is whitespace-normalized.  <a href="#ada36bc5027686a9d1ad270996b6474e7">More...</a><br /></td></tr>
<tr class="separator:ada36bc5027686a9d1ad270996b6474e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffb2ff05ca31174288694ad6c974293"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a0ffb2ff05ca31174288694ad6c974293">stripWhitespace</a> (std::string &amp;)</td></tr>
<tr class="memdesc:a0ffb2ff05ca31174288694ad6c974293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove leading and trailing whitespace.  <a href="#a0ffb2ff05ca31174288694ad6c974293">More...</a><br /></td></tr>
<tr class="separator:a0ffb2ff05ca31174288694ad6c974293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7547773712a8ce630a67decf8945f20c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a7547773712a8ce630a67decf8945f20c">convertToLowerCase</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a7547773712a8ce630a67decf8945f20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert UTF-8 string to lower case.  <a href="#a7547773712a8ce630a67decf8945f20c">More...</a><br /></td></tr>
<tr class="separator:a7547773712a8ce630a67decf8945f20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c34d547b0bedd2e621d6b5df658c2e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a87c34d547b0bedd2e621d6b5df658c2e">convertToUpperCase</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a87c34d547b0bedd2e621d6b5df658c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert UTF-8 string to upper case.  <a href="#a87c34d547b0bedd2e621d6b5df658c2e">More...</a><br /></td></tr>
<tr class="separator:a87c34d547b0bedd2e621d6b5df658c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108690689ad333007f4330bd175df4d9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a108690689ad333007f4330bd175df4d9">form</a> (const char *format,...) __attribute__((format(printf</td></tr>
<tr class="memdesc:a108690689ad333007f4330bd175df4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatted output conversion.  <a href="#a108690689ad333007f4330bd175df4d9">More...</a><br /></td></tr>
<tr class="separator:a108690689ad333007f4330bd175df4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c4bdb68d3f08b071f9e54245688891"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63c4bdb68d3f08b071f9e54245688891"></a>
std::string std::string&#160;</td><td class="memItemRight" valign="bottom"><b>vform</b> (const char *format, va_list args)</td></tr>
<tr class="separator:a63c4bdb68d3f08b071f9e54245688891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1674734f0cd77f13980678e4c6ac2474"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a1674734f0cd77f13980678e4c6ac2474">split</a> (const std::string &amp;string, const std::string &amp;separator)</td></tr>
<tr class="memdesc:a1674734f0cd77f13980678e4c6ac2474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split string into tokens.  <a href="#a1674734f0cd77f13980678e4c6ac2474">More...</a><br /></td></tr>
<tr class="separator:a1674734f0cd77f13980678e4c6ac2474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9eb46a2999d91b02e1fa09ddbc59b7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#af9eb46a2999d91b02e1fa09ddbc59b7e">startsWith</a> (const std::string &amp;string, const std::string &amp;search)</td></tr>
<tr class="memdesc:af9eb46a2999d91b02e1fa09ddbc59b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the python startswith method of strings.  <a href="#af9eb46a2999d91b02e1fa09ddbc59b7e">More...</a><br /></td></tr>
<tr class="separator:af9eb46a2999d91b02e1fa09ddbc59b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8538ea0129da43658d4c5681936049cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8538ea0129da43658d4c5681936049cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a8538ea0129da43658d4c5681936049cb">strconv</a> (const std::string &amp;, T &amp;)</td></tr>
<tr class="memdesc:a8538ea0129da43658d4c5681936049cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convinient functions to parse strings.  <a href="#a8538ea0129da43658d4c5681936049cb">More...</a><br /></td></tr>
<tr class="separator:a8538ea0129da43658d4c5681936049cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3965f33d5b845714d376fbb4960b1321"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3965f33d5b845714d376fbb4960b1321"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a3965f33d5b845714d376fbb4960b1321">strconv</a> (const std::string &amp;, T &amp;, const <a class="el" href="classLattice_1_1Core_1_1Choice.html">Choice</a> &amp;)</td></tr>
<tr class="memdesc:a3965f33d5b845714d376fbb4960b1321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a given string to value of type T via the given <a class="el" href="classLattice_1_1Core_1_1Choice.html" title="Choice class. ">Choice</a> object; returns true on successful mapping.  <a href="#a3965f33d5b845714d376fbb4960b1321">More...</a><br /></td></tr>
<tr class="separator:a3965f33d5b845714d376fbb4960b1321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42524f5eb89659d2ee2f665e29fe43bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42524f5eb89659d2ee2f665e29fe43bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a42524f5eb89659d2ee2f665e29fe43bb">str2vector</a> (const std::string &amp;, std::vector&lt; T &gt; &amp;, const std::string &amp;elemDelim)</td></tr>
<tr class="memdesc:a42524f5eb89659d2ee2f665e29fe43bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">String to list conversion.  <a href="#a42524f5eb89659d2ee2f665e29fe43bb">More...</a><br /></td></tr>
<tr class="separator:a42524f5eb89659d2ee2f665e29fe43bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07a07cd038f4ea670c9e1ab038a6907"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac07a07cd038f4ea670c9e1ab038a6907"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac07a07cd038f4ea670c9e1ab038a6907"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>str2vector</b> (const std::string &amp;, std::vector&lt; T &gt; &amp;, const std::string &amp;elemDelim, const std::string &amp;rangeDelim, const T &amp;min=<a class="el" href="structLattice_1_1Core_1_1Type.html">Core::Type</a>&lt; T &gt;::min, const T &amp;max=<a class="el" href="structLattice_1_1Core_1_1Type.html">Core::Type</a>&lt; T &gt;::max, const T &amp;step=T(1))</td></tr>
<tr class="separator:ac07a07cd038f4ea670c9e1ab038a6907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997fe05a73e4f9d4498491b50699db8c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a997fe05a73e4f9d4498491b50699db8c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a997fe05a73e4f9d4498491b50699db8c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>str2vector</b> (const std::string &amp;, std::vector&lt; T &gt; &amp;, const std::string &amp;elemDelim, const std::string &amp;rangeDelim, const std::string &amp;assignDelim, const T &amp;min=<a class="el" href="structLattice_1_1Core_1_1Type.html">Core::Type</a>&lt; T &gt;::min, const T &amp;max=<a class="el" href="structLattice_1_1Core_1_1Type.html">Core::Type</a>&lt; T &gt;::max, const T &amp;step=T(1))</td></tr>
<tr class="separator:a997fe05a73e4f9d4498491b50699db8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b72683537ae4618c831cea36d72fba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a01b72683537ae4618c831cea36d72fba"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a01b72683537ae4618c831cea36d72fba">vector2str</a> (const std::vector&lt; T &gt; &amp;vec, const std::string &amp;elemDelim=&quot; &quot;)</td></tr>
<tr class="memdesc:a01b72683537ae4618c831cea36d72fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert vector to string, elements are separated by elemDelim  <a href="#a01b72683537ae4618c831cea36d72fba">More...</a><br /></td></tr>
<tr class="separator:a01b72683537ae4618c831cea36d72fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb86d519df068bee8a07c2707b9a976"><td class="memTemplParams" colspan="2">template&lt;typename Signed &gt; </td></tr>
<tr class="memitem:a9cb86d519df068bee8a07c2707b9a976"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a9cb86d519df068bee8a07c2707b9a976">str2signed</a> (const std::string &amp;s, Signed &amp;i)</td></tr>
<tr class="memdesc:a9cb86d519df068bee8a07c2707b9a976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive data type conversion.  <a href="#a9cb86d519df068bee8a07c2707b9a976">More...</a><br /></td></tr>
<tr class="separator:a9cb86d519df068bee8a07c2707b9a976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72405c62994ebc8b36be378f5d277701"><td class="memTemplParams" colspan="2"><a class="anchor" id="a72405c62994ebc8b36be378f5d277701"></a>
template&lt;typename Unsigned &gt; </td></tr>
<tr class="memitem:a72405c62994ebc8b36be378f5d277701"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>str2unsigned</b> (const std::string &amp;s, Unsigned &amp;u)</td></tr>
<tr class="separator:a72405c62994ebc8b36be378f5d277701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b88938431e98045839179279bdf31f7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8b88938431e98045839179279bdf31f7"></a>
template&lt;typename Float &gt; </td></tr>
<tr class="memitem:a8b88938431e98045839179279bdf31f7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>str2float</b> (const std::string &amp;s, Float &amp;f)</td></tr>
<tr class="separator:a8b88938431e98045839179279bdf31f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae809a2716410cef21157bba913404ddc"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae809a2716410cef21157bba913404ddc"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae809a2716410cef21157bba913404ddc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv&lt; bool &gt;</b> (const std::string &amp;s, bool &amp;b)</td></tr>
<tr class="separator:ae809a2716410cef21157bba913404ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd630591ba612ad7f3a16d08418ace9f"><td class="memTemplParams" colspan="2"><a class="anchor" id="abd630591ba612ad7f3a16d08418ace9f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abd630591ba612ad7f3a16d08418ace9f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, s8 &amp;i)</td></tr>
<tr class="separator:abd630591ba612ad7f3a16d08418ace9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973aa8074bbe6f7fe8b8b61273bbb280"><td class="memTemplParams" colspan="2"><a class="anchor" id="a973aa8074bbe6f7fe8b8b61273bbb280"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a973aa8074bbe6f7fe8b8b61273bbb280"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, s16 &amp;i)</td></tr>
<tr class="separator:a973aa8074bbe6f7fe8b8b61273bbb280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83298eacd0124174e9d24dcb41e0b5e2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a83298eacd0124174e9d24dcb41e0b5e2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a83298eacd0124174e9d24dcb41e0b5e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, s32 &amp;i)</td></tr>
<tr class="separator:a83298eacd0124174e9d24dcb41e0b5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285a02969e4f6bde1d91b6fa46f829db"><td class="memTemplParams" colspan="2"><a class="anchor" id="a285a02969e4f6bde1d91b6fa46f829db"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a285a02969e4f6bde1d91b6fa46f829db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, s64 &amp;i)</td></tr>
<tr class="separator:a285a02969e4f6bde1d91b6fa46f829db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa050c0f94b3d22b888dc37476ae87095"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa050c0f94b3d22b888dc37476ae87095"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa050c0f94b3d22b888dc37476ae87095"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, u8 &amp;u)</td></tr>
<tr class="separator:aa050c0f94b3d22b888dc37476ae87095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388ff60fd3cd811457463427afb3cc92"><td class="memTemplParams" colspan="2"><a class="anchor" id="a388ff60fd3cd811457463427afb3cc92"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a388ff60fd3cd811457463427afb3cc92"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, u16 &amp;u)</td></tr>
<tr class="separator:a388ff60fd3cd811457463427afb3cc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e8d2e1f7056804f05dfa423eeb5fc5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a64e8d2e1f7056804f05dfa423eeb5fc5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a64e8d2e1f7056804f05dfa423eeb5fc5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, u32 &amp;u)</td></tr>
<tr class="separator:a64e8d2e1f7056804f05dfa423eeb5fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378d04853a5a15d7d2e593670ff8dc11"><td class="memTemplParams" colspan="2"><a class="anchor" id="a378d04853a5a15d7d2e593670ff8dc11"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a378d04853a5a15d7d2e593670ff8dc11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, u64 &amp;u)</td></tr>
<tr class="separator:a378d04853a5a15d7d2e593670ff8dc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaba6a4cfa7cc5e5abb15fa3675d632e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaaba6a4cfa7cc5e5abb15fa3675d632e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aaaba6a4cfa7cc5e5abb15fa3675d632e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, f32 &amp;f)</td></tr>
<tr class="separator:aaaba6a4cfa7cc5e5abb15fa3675d632e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea31a2d88faa1ccb06517988db1f7599"><td class="memTemplParams" colspan="2"><a class="anchor" id="aea31a2d88faa1ccb06517988db1f7599"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aea31a2d88faa1ccb06517988db1f7599"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, f64 &amp;f)</td></tr>
<tr class="separator:aea31a2d88faa1ccb06517988db1f7599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9610cf66c530fc0543e9157b9c298428"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a9610cf66c530fc0543e9157b9c298428"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a9610cf66c530fc0543e9157b9c298428">strconv</a> (const std::string &amp;s, std::string &amp;ss)</td></tr>
<tr class="memdesc:a9610cf66c530fc0543e9157b9c298428"><td class="mdescLeft">&#160;</td><td class="mdescRight">String conversion; strips whitspaces.  <a href="#a9610cf66c530fc0543e9157b9c298428">More...</a><br /></td></tr>
<tr class="separator:a9610cf66c530fc0543e9157b9c298428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68df2d84019ca0845e6518866042eca8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a68df2d84019ca0845e6518866042eca8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a68df2d84019ca0845e6518866042eca8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>str2vector</b> (const std::string &amp;s, std::vector&lt; T &gt; &amp;e, const std::string &amp;elemDelim, const std::string &amp;rangeDelim, const T &amp;minValue, const T &amp;maxValue, const u32 &amp;minSize, const u32 &amp;maxSize, const T &amp;step)</td></tr>
<tr class="separator:a68df2d84019ca0845e6518866042eca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2655848d83d6abfae665d4036c59b686"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2655848d83d6abfae665d4036c59b686"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2655848d83d6abfae665d4036c59b686"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>str2vector</b> (const std::string &amp;s, std::vector&lt; T &gt; &amp;e, const std::string &amp;elemDelim, const std::string &amp;rangeDelim, const std::string &amp;assignDelim, const T &amp;minValue, const T &amp;maxValue, const u32 &amp;minSize, const u32 &amp;maxSize, const T &amp;step)</td></tr>
<tr class="separator:a2655848d83d6abfae665d4036c59b686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fa6fdccf146885fa854cadb71e96f3"><td class="memTemplParams" colspan="2"><a class="anchor" id="af8fa6fdccf146885fa854cadb71e96f3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af8fa6fdccf146885fa854cadb71e96f3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, std::vector&lt; u8 &gt; &amp;v)</td></tr>
<tr class="separator:af8fa6fdccf146885fa854cadb71e96f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0858f58f3f84462fa842eb51700760dc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0858f58f3f84462fa842eb51700760dc"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0858f58f3f84462fa842eb51700760dc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, std::vector&lt; u16 &gt; &amp;v)</td></tr>
<tr class="separator:a0858f58f3f84462fa842eb51700760dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e3a5a6e422c25acb845d3e731aedc1"><td class="memTemplParams" colspan="2"><a class="anchor" id="af1e3a5a6e422c25acb845d3e731aedc1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af1e3a5a6e422c25acb845d3e731aedc1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, std::vector&lt; u32 &gt; &amp;v)</td></tr>
<tr class="separator:af1e3a5a6e422c25acb845d3e731aedc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04020725864334b58042a81ee6ed5c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad04020725864334b58042a81ee6ed5c4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad04020725864334b58042a81ee6ed5c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, std::vector&lt; u64 &gt; &amp;v)</td></tr>
<tr class="separator:ad04020725864334b58042a81ee6ed5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3b7f49afbdde135d25569fb5c3e506"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d3b7f49afbdde135d25569fb5c3e506"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0d3b7f49afbdde135d25569fb5c3e506"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, std::vector&lt; s8 &gt; &amp;v)</td></tr>
<tr class="separator:a0d3b7f49afbdde135d25569fb5c3e506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6170a2dc5e35bec82317456b66022c7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad6170a2dc5e35bec82317456b66022c7"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad6170a2dc5e35bec82317456b66022c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, std::vector&lt; s16 &gt; &amp;v)</td></tr>
<tr class="separator:ad6170a2dc5e35bec82317456b66022c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b41a92a734643f14e9c87a8c6cce8ce"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7b41a92a734643f14e9c87a8c6cce8ce"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7b41a92a734643f14e9c87a8c6cce8ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, std::vector&lt; s32 &gt; &amp;v)</td></tr>
<tr class="separator:a7b41a92a734643f14e9c87a8c6cce8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b4aa88118d651068764846870e7696"><td class="memTemplParams" colspan="2"><a class="anchor" id="af4b4aa88118d651068764846870e7696"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af4b4aa88118d651068764846870e7696"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, std::vector&lt; s64 &gt; &amp;v)</td></tr>
<tr class="separator:af4b4aa88118d651068764846870e7696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4069a7f149bb786863b3bd83cbcf2546"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4069a7f149bb786863b3bd83cbcf2546"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4069a7f149bb786863b3bd83cbcf2546"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, std::vector&lt; f32 &gt; &amp;v)</td></tr>
<tr class="separator:a4069a7f149bb786863b3bd83cbcf2546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97d43d4c59088384bec41873bae31c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac97d43d4c59088384bec41873bae31c4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac97d43d4c59088384bec41873bae31c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strconv</b> (const std::string &amp;s, std::vector&lt; f64 &gt; &amp;v)</td></tr>
<tr class="separator:ac97d43d4c59088384bec41873bae31c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10805ef38ae392f6e105503e728fa1b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa10805ef38ae392f6e105503e728fa1b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#aa10805ef38ae392f6e105503e728fa1b">strconv</a> (const std::string &amp;s, std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:aa10805ef38ae392f6e105503e728fa1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of strings conversion; strips whitespaces.  <a href="#aa10805ef38ae392f6e105503e728fa1b">More...</a><br /></td></tr>
<tr class="separator:aa10805ef38ae392f6e105503e728fa1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b7876df8caef37c7cf7c817e4c8027"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#ae6b7876df8caef37c7cf7c817e4c8027">getline</a> (std::istream &amp;, std::string &amp;, std::string delim=&quot;\n&quot;)</td></tr>
<tr class="memdesc:ae6b7876df8caef37c7cf7c817e4c8027"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads from input stream until one of the specified delimiters  <a href="#ae6b7876df8caef37c7cf7c817e4c8027">More...</a><br /></td></tr>
<tr class="separator:ae6b7876df8caef37c7cf7c817e4c8027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23ed26a77996f9c38c45ffbf5c5c604"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af23ed26a77996f9c38c45ffbf5c5c604"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>wsgetline</b> (std::istream &amp;is, std::string &amp;str, std::string delim=&quot;\n&quot;)</td></tr>
<tr class="separator:af23ed26a77996f9c38c45ffbf5c5c604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b06ad6acd80e3654db783c359aa7412"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b06ad6acd80e3654db783c359aa7412"></a>
std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>itoa</b> (std::string &amp;s, unsigned int val)</td></tr>
<tr class="separator:a4b06ad6acd80e3654db783c359aa7412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68548a01c2f4b105a6bc045ff1c44ba1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68548a01c2f4b105a6bc045ff1c44ba1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>itoa</b> (u32 i)</td></tr>
<tr class="separator:a68548a01c2f4b105a6bc045ff1c44ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7490c062fb564892b7254d8ce2b6023b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7490c062fb564892b7254d8ce2b6023b"></a>
template&lt;class A , class B &gt; </td></tr>
<tr class="memitem:a7490c062fb564892b7254d8ce2b6023b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLattice_1_1Core_1_1tied.html">tied</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tie</b> (A &amp;a, B &amp;b)</td></tr>
<tr class="separator:a7490c062fb564892b7254d8ce2b6023b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a31d866b1764db70781d828595bc09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#ad1a31d866b1764db70781d828595bc09">abs</a> (int v)</td></tr>
<tr class="memdesc:ad1a31d866b1764db70781d828595bc09"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceLattice_1_1Core.html#ad1a31d866b1764db70781d828595bc09" title="Core::abs : wrapper for several absolute value functions. ">Core::abs</a> : wrapper for several absolute value functions.  <a href="#ad1a31d866b1764db70781d828595bc09">More...</a><br /></td></tr>
<tr class="separator:ad1a31d866b1764db70781d828595bc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97e80f3d11a86404850bafdc4a81b8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa97e80f3d11a86404850bafdc4a81b8b"></a>
long int&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (long int v)</td></tr>
<tr class="separator:aa97e80f3d11a86404850bafdc4a81b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01febd5a6a81fdbcbe81117bf47ae3dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01febd5a6a81fdbcbe81117bf47ae3dd"></a>
long long int&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (long long int v)</td></tr>
<tr class="separator:a01febd5a6a81fdbcbe81117bf47ae3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854b2a44f36e49e1dd6e98a7419ccfa1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a854b2a44f36e49e1dd6e98a7419ccfa1"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (float v)</td></tr>
<tr class="separator:a854b2a44f36e49e1dd6e98a7419ccfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8729ea1badb8ca444d0796eb5d40da3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8729ea1badb8ca444d0796eb5d40da3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (double v)</td></tr>
<tr class="separator:ac8729ea1badb8ca444d0796eb5d40da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1292be60c8ca4b5a3dff8df9fb5695ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1292be60c8ca4b5a3dff8df9fb5695ea"></a>
long double&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (long double v)</td></tr>
<tr class="separator:a1292be60c8ca4b5a3dff8df9fb5695ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af813ea0a1c88a142fa67cb1fa23e2f29"><td class="memTemplParams" colspan="2"><a class="anchor" id="af813ea0a1c88a142fa67cb1fa23e2f29"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af813ea0a1c88a142fa67cb1fa23e2f29"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const std::complex&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:af813ea0a1c88a142fa67cb1fa23e2f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e2c1198bd03a3090596e35018b0695"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class M &gt; </td></tr>
<tr class="memitem:a87e2c1198bd03a3090596e35018b0695"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a87e2c1198bd03a3090596e35018b0695">maxAbsoluteElement</a> (InputIterator begin, InputIterator end, M &amp;m)</td></tr>
<tr class="memdesc:a87e2c1198bd03a3090596e35018b0695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal absolute value in <code>v</code> is returned in <code>m</code>.  <a href="#a87e2c1198bd03a3090596e35018b0695">More...</a><br /></td></tr>
<tr class="separator:a87e2c1198bd03a3090596e35018b0695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dacf3441b1824bb3674fb4afeed21e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad3dacf3441b1824bb3674fb4afeed21e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad3dacf3441b1824bb3674fb4afeed21e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>maxAbsoluteElement</b> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:ad3dacf3441b1824bb3674fb4afeed21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae405984bfc1fa472cfc56d87a2a7ac56"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae405984bfc1fa472cfc56d87a2a7ac56"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae405984bfc1fa472cfc56d87a2a7ac56"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>maxAbsoluteElement</b> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="separator:ae405984bfc1fa472cfc56d87a2a7ac56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8b332b91f47899a94954737d6b0610"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a3e8b332b91f47899a94954737d6b0610">round</a> (float v)</td></tr>
<tr class="memdesc:a3e8b332b91f47899a94954737d6b0610"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceLattice_1_1Core.html#a3e8b332b91f47899a94954737d6b0610" title="Core::round : wrapper for several round functions. ">Core::round</a> : wrapper for several round functions.  <a href="#a3e8b332b91f47899a94954737d6b0610">More...</a><br /></td></tr>
<tr class="separator:a3e8b332b91f47899a94954737d6b0610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2ae06619f37313b3f84b47c6d4d55d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a2ae06619f37313b3f84b47c6d4d55d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>round</b> (double v)</td></tr>
<tr class="separator:a5a2ae06619f37313b3f84b47c6d4d55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcd98d04576fbec99b9c2a771033a48"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a6bcd98d04576fbec99b9c2a771033a48">ceil</a> (float v)</td></tr>
<tr class="memdesc:a6bcd98d04576fbec99b9c2a771033a48"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceLattice_1_1Core.html#a6bcd98d04576fbec99b9c2a771033a48" title="Core::ceil : wrapper for several ceil functions. ">Core::ceil</a> : wrapper for several ceil functions.  <a href="#a6bcd98d04576fbec99b9c2a771033a48">More...</a><br /></td></tr>
<tr class="separator:a6bcd98d04576fbec99b9c2a771033a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012817534adfcd2b4863f144cbf99fae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a012817534adfcd2b4863f144cbf99fae"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>ceil</b> (double v)</td></tr>
<tr class="separator:a012817534adfcd2b4863f144cbf99fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95adc59ff5c608367f6ffa41edc22f86"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a95adc59ff5c608367f6ffa41edc22f86">floor</a> (float v)</td></tr>
<tr class="memdesc:a95adc59ff5c608367f6ffa41edc22f86"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceLattice_1_1Core.html#a95adc59ff5c608367f6ffa41edc22f86" title="Core::floor : wrapper for several floor functions. ">Core::floor</a> : wrapper for several floor functions.  <a href="#a95adc59ff5c608367f6ffa41edc22f86">More...</a><br /></td></tr>
<tr class="separator:a95adc59ff5c608367f6ffa41edc22f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb2049b707c00984fe25cf95d937245"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdb2049b707c00984fe25cf95d937245"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>floor</b> (double v)</td></tr>
<tr class="separator:abdb2049b707c00984fe25cf95d937245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2588703558baf60a189deddc18504d96"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a2588703558baf60a189deddc18504d96"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a2588703558baf60a189deddc18504d96">isNormal</a> (InputIterator begin, InputIterator end)</td></tr>
<tr class="separator:a2588703558baf60a189deddc18504d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c652ff64080d9e1e54a00970f145983"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a5c652ff64080d9e1e54a00970f145983"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a5c652ff64080d9e1e54a00970f145983">isMalformed</a> (F f)</td></tr>
<tr class="separator:a5c652ff64080d9e1e54a00970f145983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5597200d4c26cbb4956194f407f4b838"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5597200d4c26cbb4956194f407f4b838"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a5597200d4c26cbb4956194f407f4b838">clip</a> (T x)</td></tr>
<tr class="memdesc:a5597200d4c26cbb4956194f407f4b838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if.  <a href="#a5597200d4c26cbb4956194f407f4b838">More...</a><br /></td></tr>
<tr class="separator:a5597200d4c26cbb4956194f407f4b838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740e165a70b9604b8e8110cdea40357a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a740e165a70b9604b8e8110cdea40357a">log</a> (float v)</td></tr>
<tr class="memdesc:a740e165a70b9604b8e8110cdea40357a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceLattice_1_1Core.html#a740e165a70b9604b8e8110cdea40357a" title="Core::log : numerically robust wrapper for log functions. ">Core::log</a> : numerically robust wrapper for log functions.  <a href="#a740e165a70b9604b8e8110cdea40357a">More...</a><br /></td></tr>
<tr class="separator:a740e165a70b9604b8e8110cdea40357a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4528d20182263e78e832340a514739dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4528d20182263e78e832340a514739dd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>log</b> (double v)</td></tr>
<tr class="separator:a4528d20182263e78e832340a514739dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4210491bf1d666fc36fdc88ab0c56e10"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a4210491bf1d666fc36fdc88ab0c56e10"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a4210491bf1d666fc36fdc88ab0c56e10">isMalformed</a> (InputIterator begin, InputIterator end)</td></tr>
<tr class="separator:a4210491bf1d666fc36fdc88ab0c56e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114c05ece89fa47c224c9cc24a8b75ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a114c05ece89fa47c224c9cc24a8b75ca"></a>
template&lt;class F , class G , class H &gt; </td></tr>
<tr class="memitem:a114c05ece89fa47c224c9cc24a8b75ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLattice_1_1Core_1_1composedBinaryFunction.html">composedBinaryFunction</a>&lt; F, G, H &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>composeBinaryFunction</b> (const F &amp;f, const G &amp;g, const H &amp;h)</td></tr>
<tr class="separator:a114c05ece89fa47c224c9cc24a8b75ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8558eac51e25275cc3220c29e188373"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#ac8558eac51e25275cc3220c29e188373">isAlmostEqual</a> (f32 a, f32 b, f32 tolerance=(f32) 1)</td></tr>
<tr class="memdesc:ac8558eac51e25275cc3220c29e188373"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceTest.html" title="Copyright 2020 RWTH Aachen University. ">Test</a> for near-equality of floating point numbers.  <a href="#ac8558eac51e25275cc3220c29e188373">More...</a><br /></td></tr>
<tr class="separator:ac8558eac51e25275cc3220c29e188373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643ae5e548b281675d0c34f30c159142"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a643ae5e548b281675d0c34f30c159142"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAlmostEqual</b> (f64 a, f64 b, f64 tolerance=(f64) 1)</td></tr>
<tr class="separator:a643ae5e548b281675d0c34f30c159142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb136310ff0ad1c99123bb8c7f33fff0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb136310ff0ad1c99123bb8c7f33fff0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAlmostEqual</b> (const std::complex&lt; f32 &gt; &amp;a, const std::complex&lt; f32 &gt; &amp;b, const std::complex&lt; f32 &gt; tolerance=std::complex&lt; f32 &gt;((f32) 1,(f32) 1))</td></tr>
<tr class="separator:acb136310ff0ad1c99123bb8c7f33fff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6699564b4dc05e81e2cf698c3c912158"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6699564b4dc05e81e2cf698c3c912158"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAlmostEqual</b> (const std::complex&lt; f64 &gt; &amp;a, const std::complex&lt; f64 &gt; &amp;b, const std::complex&lt; f64 &gt; tolerance=std::complex&lt; f64 &gt;((f64) 1,(f64) 1))</td></tr>
<tr class="separator:a6699564b4dc05e81e2cf698c3c912158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c7a1b422d9d5a207bc32701a1f82f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98c7a1b422d9d5a207bc32701a1f82f0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSignificantlyGreater</b> (f32 a, f32 b, f32 tolerance=(f32) 1)</td></tr>
<tr class="separator:a98c7a1b422d9d5a207bc32701a1f82f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c54d1408dff9def7bd1aff01c9a0902"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c54d1408dff9def7bd1aff01c9a0902"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSignificantlyGreater</b> (f64 a, f64 b, f64 tolerance=(f64) 1)</td></tr>
<tr class="separator:a7c54d1408dff9def7bd1aff01c9a0902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffef9655ffdfe6af08c4c57a993249e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acffef9655ffdfe6af08c4c57a993249e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSignificantlyLess</b> (f32 a, f32 b, f32 tolerance=(f32) 1)</td></tr>
<tr class="separator:acffef9655ffdfe6af08c4c57a993249e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ba057ae8470ea59f2960553f6a5475"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3ba057ae8470ea59f2960553f6a5475"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSignificantlyLess</b> (f64 a, f64 b, f64 tolerance=(f64) 1)</td></tr>
<tr class="separator:ae3ba057ae8470ea59f2960553f6a5475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4f8b41abbca116d39034369eaf283e"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a4d4f8b41abbca116d39034369eaf283e">differenceUlp</a> (f32 a, f32 b)</td></tr>
<tr class="memdesc:a4d4f8b41abbca116d39034369eaf283e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference between two floating-point values in units of least precision (ULP).  <a href="#a4d4f8b41abbca116d39034369eaf283e">More...</a><br /></td></tr>
<tr class="separator:a4d4f8b41abbca116d39034369eaf283e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634cde8c80a54abe4665d6b33b6db5cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a634cde8c80a54abe4665d6b33b6db5cc"></a>
s64&#160;</td><td class="memItemRight" valign="bottom"><b>differenceUlp</b> (f64 a, f64 b)</td></tr>
<tr class="separator:a634cde8c80a54abe4665d6b33b6db5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26edba2ad21c9895aff86f5d756d179"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#ad26edba2ad21c9895aff86f5d756d179">isAlmostEqualUlp</a> (f32 a, f32 b, s32 tolerance)</td></tr>
<tr class="memdesc:ad26edba2ad21c9895aff86f5d756d179"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceTest.html" title="Copyright 2020 RWTH Aachen University. ">Test</a> for near-equality of floating point numbers with tolerance given in unit of least precision.  <a href="#ad26edba2ad21c9895aff86f5d756d179">More...</a><br /></td></tr>
<tr class="separator:ad26edba2ad21c9895aff86f5d756d179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b5796a4bf699d1e4211c8c1cda2e1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22b5796a4bf699d1e4211c8c1cda2e1f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAlmostEqualUlp</b> (f64 a, f64 b, s64 tolerance)</td></tr>
<tr class="separator:a22b5796a4bf699d1e4211c8c1cda2e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487742f348bc28ff2ffb3e743fd8b9c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a487742f348bc28ff2ffb3e743fd8b9c5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAlmostEqualUlp</b> (f64 a, f64 b, s32 tolerance)</td></tr>
<tr class="separator:a487742f348bc28ff2ffb3e743fd8b9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851d550fc4bfcedee0d8332e6dd04e99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a851d550fc4bfcedee0d8332e6dd04e99"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSignificantlyLessUlp</b> (f32 a, f32 b, s32 tolerance)</td></tr>
<tr class="separator:a851d550fc4bfcedee0d8332e6dd04e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf75f69cb1d6141467f279513586c3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaf75f69cb1d6141467f279513586c3d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSignificantlyLessUlp</b> (f64 a, f64 b, s64 tolerance)</td></tr>
<tr class="separator:acaf75f69cb1d6141467f279513586c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3c0917a94209a3f7fb5f2628e54fb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a3c0917a94209a3f7fb5f2628e54fb4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>timeDiff</b> (timeval &amp;start, timeval &amp;end)</td></tr>
<tr class="separator:a7a3c0917a94209a3f7fb5f2628e54fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa25bfd4ae0be61c09e95852d7b8e7c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa25bfd4ae0be61c09e95852d7b8e7c9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aaa25bfd4ae0be61c09e95852d7b8e7c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLattice_1_1Core_1_1XmlWriter.html">XmlWriter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classLattice_1_1Core_1_1XmlWriter.html">XmlWriter</a> &amp;os, const <a class="el" href="classLattice_1_1Core_1_1Statistics.html">Statistics</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="separator:aaa25bfd4ae0be61c09e95852d7b8e7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6712b10b1da5531bd720f4d0fcce2910"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6712b10b1da5531bd720f4d0fcce2910"></a>
<a class="el" href="classLattice_1_1Core_1_1XmlWriter.html">XmlWriter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classLattice_1_1Core_1_1XmlWriter.html">XmlWriter</a> &amp;os, const <a class="el" href="classLattice_1_1Core_1_1HistogramStatistics.html">HistogramStatistics</a> &amp;t)</td></tr>
<tr class="separator:a6712b10b1da5531bd720f4d0fcce2910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d081eccc31dcd0d83e0b44bd1279a49"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3d081eccc31dcd0d83e0b44bd1279a49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLattice_1_1Core_1_1Ref.html">Ref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a3d081eccc31dcd0d83e0b44bd1279a49">ref</a> (T *o)</td></tr>
<tr class="memdesc:a3d081eccc31dcd0d83e0b44bd1279a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience constructors for <a class="el" href="classLattice_1_1Core_1_1Ref.html" title="Class template for smart pointers using intrusive reference-counting. ">Ref</a> smart pointers.  <a href="#a3d081eccc31dcd0d83e0b44bd1279a49">More...</a><br /></td></tr>
<tr class="separator:a3d081eccc31dcd0d83e0b44bd1279a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa057ec60ed2e545f1bdd9be2d9a981ba"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa057ec60ed2e545f1bdd9be2d9a981ba"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa057ec60ed2e545f1bdd9be2d9a981ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLattice_1_1Core_1_1BinaryOutputStream.html">BinaryOutputStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classLattice_1_1Core_1_1BinaryOutputStream.html">BinaryOutputStream</a> &amp;o, const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:aa057ec60ed2e545f1bdd9be2d9a981ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b49f56b199735a3f82c237daf406d8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad3b49f56b199735a3f82c237daf406d8"></a>
template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ad3b49f56b199735a3f82c237daf406d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLattice_1_1Core_1_1BinaryOutputStream.html">BinaryOutputStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classLattice_1_1Core_1_1BinaryOutputStream.html">BinaryOutputStream</a> &amp;o, const std::map&lt; T1, T2 &gt; &amp;m)</td></tr>
<tr class="separator:ad3b49f56b199735a3f82c237daf406d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d94265da9613979fd963695e2c1e62"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa0d94265da9613979fd963695e2c1e62"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa0d94265da9613979fd963695e2c1e62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLattice_1_1Core_1_1BinaryOutputStream.html">BinaryOutputStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classLattice_1_1Core_1_1BinaryOutputStream.html">BinaryOutputStream</a> &amp;o, const std::set&lt; T &gt; &amp;s)</td></tr>
<tr class="separator:aa0d94265da9613979fd963695e2c1e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc7057dd91e9ec053b4a2ec9fd6433b"><td class="memTemplParams" colspan="2"><a class="anchor" id="adfc7057dd91e9ec053b4a2ec9fd6433b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adfc7057dd91e9ec053b4a2ec9fd6433b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLattice_1_1Core_1_1BinaryInputStream.html">BinaryInputStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classLattice_1_1Core_1_1BinaryInputStream.html">BinaryInputStream</a> &amp;is, std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:adfc7057dd91e9ec053b4a2ec9fd6433b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdeacc6e6a94628f7aa63160de1ea57"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0cdeacc6e6a94628f7aa63160de1ea57"></a>
template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a0cdeacc6e6a94628f7aa63160de1ea57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLattice_1_1Core_1_1BinaryInputStream.html">BinaryInputStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classLattice_1_1Core_1_1BinaryInputStream.html">BinaryInputStream</a> &amp;is, std::map&lt; T1, T2 &gt; &amp;m)</td></tr>
<tr class="separator:a0cdeacc6e6a94628f7aa63160de1ea57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5bc099791626220768b5e8eb7c7086"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8d5bc099791626220768b5e8eb7c7086"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8d5bc099791626220768b5e8eb7c7086"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLattice_1_1Core_1_1BinaryInputStream.html">BinaryInputStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classLattice_1_1Core_1_1BinaryInputStream.html">BinaryInputStream</a> &amp;is, std::set&lt; T &gt; &amp;s)</td></tr>
<tr class="separator:a8d5bc099791626220768b5e8eb7c7086"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3f3bb240b85cdc445dd6f32eb7e97d4c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classLattice_1_1Core_1_1Choice.html">Choice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a3f3bb240b85cdc445dd6f32eb7e97d4c">boolChoice</a></td></tr>
<tr class="memdesc:a3f3bb240b85cdc445dd6f32eb7e97d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined <a class="el" href="classLattice_1_1Core_1_1Choice.html" title="Choice class. ">Choice</a> for boolean values.  <a href="#a3f3bb240b85cdc445dd6f32eb7e97d4c">More...</a><br /></td></tr>
<tr class="separator:a3f3bb240b85cdc445dd6f32eb7e97d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc3f40a46dc40b78ff9f039168afdf9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classLattice_1_1Core_1_1Choice.html">Choice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLattice_1_1Core.html#a0fc3f40a46dc40b78ff9f039168afdf9">infinityChoice</a></td></tr>
<tr class="memdesc:a0fc3f40a46dc40b78ff9f039168afdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined <a class="el" href="classLattice_1_1Core_1_1Choice.html" title="Choice class. ">Choice</a> for "inifinite" numbers.  <a href="#a0fc3f40a46dc40b78ff9f039168afdf9">More...</a><br /></td></tr>
<tr class="separator:a0fc3f40a46dc40b78ff9f039168afdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667c28ad3bc9371f4de10180b2b0e6fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a667c28ad3bc9371f4de10180b2b0e6fc"></a>
const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>defaultEncoding</b> = &quot;ISO-8859-1&quot;</td></tr>
<tr class="separator:a667c28ad3bc9371f4de10180b2b0e6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33685828014ea708e7452f012539f209"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33685828014ea708e7452f012539f209"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>requireTrailingBlank</b> = 'Y'</td></tr>
<tr class="separator:a33685828014ea708e7452f012539f209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9c60ffcc5ec910e73cee8924ce192f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e9c60ffcc5ec910e73cee8924ce192f"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>prohibitTrailingBlank</b> = 'N'</td></tr>
<tr class="separator:a4e9c60ffcc5ec910e73cee8924ce192f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7895afcb30423efa4d34bb1cd147480"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7895afcb30423efa4d34bb1cd147480"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>tolerateTrailingBlank</b> = '='</td></tr>
<tr class="separator:aa7895afcb30423efa4d34bb1cd147480"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright 2020 RWTH Aachen University. </p>
<p>All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.Copyright 2020 RWTH Aachen University. All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.Copyright 2020 RWTH Aachen University. All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.Copyright 2020 RWTH Aachen University. All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.Copyright 2020 RWTH Aachen University. All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.Copyright 2020 RWTH Aachen University. All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.Copyright 2020 RWTH Aachen University. All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.Copyright 2020 RWTH Aachen University. All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.Copyright 2020 RWTH Aachen University. All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.Copyright 2020 RWTH Aachen University. All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.Copyright 2020 RWTH Aachen University. All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ad1a31d866b1764db70781d828595bc09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Lattice::Core::abs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceLattice_1_1Core.html#ad1a31d866b1764db70781d828595bc09" title="Core::abs : wrapper for several absolute value functions. ">Core::abs</a> : wrapper for several absolute value functions. </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00110">110</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

<p>Referenced by <a class="el" href="Posterior_8cc_source.html#l00098">Lattice::CheckPosteriorDfsState::finish()</a>.</p>

</div>
</div>
<a class="anchor" id="a6bcd98d04576fbec99b9c2a771033a48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Lattice::Core::ceil </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceLattice_1_1Core.html#a6bcd98d04576fbec99b9c2a771033a48" title="Core::ceil : wrapper for several ceil functions. ">Core::ceil</a> : wrapper for several ceil functions. </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00206">206</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a5597200d4c26cbb4956194f407f4b838"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Lattice::Core::clip </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is infinite and clips it to the largest representable value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is clipped value of </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x.</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00247">247</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a7547773712a8ce630a67decf8945f20c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Lattice::Core::convertToLowerCase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert UTF-8 string to lower case. </p>

</div>
</div>
<a class="anchor" id="a87c34d547b0bedd2e621d6b5df658c2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Lattice::Core::convertToUpperCase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert UTF-8 string to upper case. </p>

</div>
</div>
<a class="anchor" id="a4d4f8b41abbca116d39034369eaf283e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 Lattice::Core::differenceUlp </td>
          <td>(</td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Difference between two floating-point values in units of least precision (ULP). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of distinct floating-point values between <code>a</code> and <code>b</code>. I.e. If <code>b</code> is the smallest value greater than a, the return value is 1. </dd></dl>

</div>
</div>
<a class="anchor" id="a31f4d09204cb08adfefba928d0fc6ecb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lattice::Core::enforceTrailingBlank </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that a string ends with a single blank character. </p>

</div>
</div>
<a class="anchor" id="a95adc59ff5c608367f6ffa41edc22f86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Lattice::Core::floor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceLattice_1_1Core.html#a95adc59ff5c608367f6ffa41edc22f86" title="Core::floor : wrapper for several floor functions. ">Core::floor</a> : wrapper for several floor functions. </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00215">215</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a108690689ad333007f4330bd175df4d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Lattice::Core::form </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formatted output conversion. </p>
<p><a class="el" href="namespaceLattice_1_1Core.html#a108690689ad333007f4330bd175df4d9" title="Formatted output conversion. ">form()</a> is equivalent to snprintf(3) but returns the result as a string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>a printf-like format string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the formatted string </dd></dl>

</div>
</div>
<a class="anchor" id="ae6b7876df8caef37c7cf7c817e4c8027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Lattice::Core::getline </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads from input stream until one of the specified delimiters </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istream</td><td>input stream to read from </td></tr>
    <tr><td class="paramname">string</td><td>resulting string that has been read; will not include a trailing delimiter </td></tr>
    <tr><td class="paramname">delim</td><td>string of delimiters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns EOF if nothing has been read, but the end of stream has been reached, returns 0 at the end of the stream, but no delimiter has been found, returns the position + 1 of the delimiter in delim that the resulting string ends with </dd></dl>

</div>
</div>
<a class="anchor" id="ac8558eac51e25275cc3220c29e188373"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Lattice::Core::isAlmostEqual </td>
          <td>(</td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>(f32)1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceTest.html" title="Copyright 2020 RWTH Aachen University. ">Test</a> for near-equality of floating point numbers. </p>
<p>Due to finite precision, the bit-wise test (a == b) is almost always false. <a class="el" href="namespaceLattice_1_1Core.html#ac8558eac51e25275cc3220c29e188373" title="Test for near-equality of floating point numbers. ">isAlmostEqual()</a> compares the relative difference of a and b to the machine precision (epsilon) times the given tolerance factor.</p>
<p>Deprecation warning: For new code you should prefer isAlmostEqualUlp.</p>
<p>Remark: -A similar idea can be found under the name "chordal metric": chord(a, b) = |a - b| / (sqrt(1+a^2) * sqrt(1 + b^2)). -sorry for repeating the same implementation for each floating point type, but specialization to complex numbers seems to be a hard nut with templates. </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00316">316</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="ad26edba2ad21c9895aff86f5d756d179"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Lattice::Core::isAlmostEqualUlp </td>
          <td>(</td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceTest.html" title="Copyright 2020 RWTH Aachen University. ">Test</a> for near-equality of floating point numbers with tolerance given in unit of least precision. </p>
<p>Due to finite precision, the bit-wise test (a == b) should not be use for floating point values. This function was taken from "Comparing floating point
numbers" by Bruce Dawson [<a href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm</a>]. You will probably not be able to make sense of this code without reading the article.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>allowed difference between <code>a</code> and <code>b</code> measured in units of least precision (Ulp). This can be thought of as the number of different normalized floating point numbers between <code>a</code> and <code>b</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This method is preferrable to the older <a class="el" href="namespaceLattice_1_1Core.html#ac8558eac51e25275cc3220c29e188373" title="Test for near-equality of floating point numbers. ">isAlmostEqual()</a>, because it is faster and theoretically more sound. So maybe <a class="el" href="namespaceLattice_1_1Core.html#ac8558eac51e25275cc3220c29e188373" title="Test for near-equality of floating point numbers. ">isAlmostEqual()</a> should be removed some time. </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00384">384</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

<p>Referenced by <a class="el" href="Posterior_8cc_source.html#l00098">Lattice::CheckPosteriorDfsState::finish()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c652ff64080d9e1e54a00970f145983"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Lattice::Core::isMalformed </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>is true if </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>is "inf" or "nan". </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00238">238</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a4210491bf1d666fc36fdc88ab0c56e10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Lattice::Core::isMalformed </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>is true if [begin..end) interval contains any malformed value (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceLattice_1_1Core.html#a5c652ff64080d9e1e54a00970f145983">isMalformed(F f)</a>). </dd></dl>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00268">268</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a2588703558baf60a189deddc18504d96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Lattice::Core::isNormal </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>is true if [begin..end) interval does not contain any "inf", "nan" etc. value. </dd></dl>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00227">227</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="ada36bc5027686a9d1ad270996b6474e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Lattice::Core::isWhitespaceNormalized </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trailingBlank</em> = <code>prohibitTrailingBlank</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceTest.html" title="Copyright 2020 RWTH Aachen University. ">Test</a> if a string is whitespace-normalized. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff <code>s</code> matches (+ )* </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trailingBlank</td><td>specifies if a trailing blank is required. The default is to classify strings ending with a blank as not normalized. If <code>requireTrailingBlank</code> is given, the string is considered normalized only if it ends with a single blank. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a740e165a70b9604b8e8110cdea40357a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Lattice::Core::log </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceLattice_1_1Core.html#a740e165a70b9604b8e8110cdea40357a" title="Core::log : numerically robust wrapper for log functions. ">Core::log</a> : numerically robust wrapper for log functions. </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00255">255</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a87e2c1198bd03a3090596e35018b0695"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Lattice::Core::maxAbsoluteElement </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximal absolute value in <code>v</code> is returned in <code>m</code>. </p>
<p>If <code>v</code> is empty, result is set to Type&lt;T&gt;::min. </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00149">149</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a86d32932d9d88a94cfb55bb1714343f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lattice::Core::normalizeWhitespace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition: A string has "normalized whitespace" if and only if it matches one the following regular expressions: (+ )* or (+ )* + where  matches any non-whitespace character. </p>
<p>I.e. There are no whitespaces other than single blanks; the first character is non-blank, and the last character may be blank. Normalize whitespace in a string. All consecutive whitespaces in the passed string are replaced by a single blank. Leading whitespace is removed.</p>
<p>Attention: If tailing whitspaces exist, a single whitspace has to remain!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the string to be normalized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d081eccc31dcd0d83e0b44bd1279a49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLattice_1_1Core_1_1Ref.html">Ref</a>&lt;T&gt; Lattice::Core::ref </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience constructors for <a class="el" href="classLattice_1_1Core_1_1Ref.html" title="Class template for smart pointers using intrusive reference-counting. ">Ref</a> smart pointers. </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00301">301</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

<p>Referenced by <a class="el" href="Lattice_2Compose_8cc_source.html#l00075">Lattice::composeLm()</a>, and <a class="el" href="Lattice_2Compose_8cc_source.html#l00023">Lattice::composeMatching()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e8b332b91f47899a94954737d6b0610"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Lattice::Core::round </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceLattice_1_1Core.html#a3e8b332b91f47899a94954737d6b0610" title="Core::round : wrapper for several round functions. ">Core::round</a> : wrapper for several round functions. </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00197">197</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a1674734f0cd77f13980678e4c6ac2474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Lattice::Core::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split string into tokens. </p>
<p>Return a list of the tokens in the string, using <code>separator</code> as the delimiter string. Any Leading or trailing whitespace is stripped ffrom the word returned. Consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, split("1,,2", ",") returns ["1", "", "2"]"). The <code>separator</code> argument may consist of multiple characters (for example, split("1, 2, 3", ", ") returns ["1", "2", "3"]). Splitting an empty string with a specified separator returns an empty list. </p>

</div>
</div>
<a class="anchor" id="af9eb46a2999d91b02e1fa09ddbc59b7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Lattice::Core::startsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the python startswith method of strings. </p>
<p>return true is string starts with search </p>

</div>
</div>
<a class="anchor" id="a9cb86d519df068bee8a07c2707b9a976"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signed &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Lattice::Core::str2signed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Signed &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Primitive data type conversion. </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00217">217</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a42524f5eb89659d2ee2f665e29fe43bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Lattice::Core::str2vector </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>elemDelim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String to list conversion. </p>
<p>Vector of primitive datatypes conversion.</p>
<p>Used by strconv to convert a string to a list. Use instead of strconv if you need to specify element and range delimiter and range borders and step width. Default seperator is space or tab for strings and comma for any others; number ranges can be specified by placing a - between two numbers. </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00349">349</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a8538ea0129da43658d4c5681936049cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Lattice::Core::strconv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convinient functions to parse strings. </p>
<p>Generalized conversion.</p>
<p>returns true on successful conversion; the string argument may contain leading and tailing whitspaces. general string to something conversion; currently specialized for:</p><ul>
<li>standard datatypes</li>
<li>strings</li>
<li>vectors of standard datatypes</li>
<li>vectors of standard strings supports:</li>
<li>different representations of bool values</li>
<li>+/-inf for numerical types</li>
<li>ranges for numerical values </li>
</ul>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00185">185</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a3965f33d5b845714d376fbb4960b1321"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Lattice::Core::strconv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLattice_1_1Core_1_1Choice.html">Choice</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a given string to value of type T via the given <a class="el" href="classLattice_1_1Core_1_1Choice.html" title="Choice class. ">Choice</a> object; returns true on successful mapping. </p>
<p><a class="el" href="classLattice_1_1Core_1_1Choice.html" title="Choice class. ">Choice</a> conversion. </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00197">197</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a9610cf66c530fc0543e9157b9c298428"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Lattice::Core::strconv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>ss</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String conversion; strips whitspaces. </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00336">336</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="aa10805ef38ae392f6e105503e728fa1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Lattice::Core::strconv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of strings conversion; strips whitespaces. </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00537">537</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a0ffb2ff05ca31174288694ad6c974293"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lattice::Core::stripWhitespace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove leading and trailing whitespace. </p>

</div>
</div>
<a class="anchor" id="ae994ba10c3cd9452007937fcb929df64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lattice::Core::suppressTrailingBlank </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove trailing blank character. </p>
<p>Removes the last character if it is a blank. </p>

</div>
</div>
<a class="anchor" id="a93530755c306d4850dbdd23154e65dcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Lattice::Core::swapEndianess </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change endianess of a block of data. </p>
<p>The size argument is given as a template parameter, so the compiler can unroll the loop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>pointer to an array of data </td></tr>
    <tr><td class="paramname">size</td><td>size of the element data type in bytes. </td></tr>
    <tr><td class="paramname">count</td><td>number of elements </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Core_2Types_8cc_source.html#l00075">75</a> of file <a class="el" href="Core_2Types_8cc_source.html">Core/Types.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a01b72683537ae4618c831cea36d72fba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Lattice::Core::vector2str </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>elemDelim</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert vector to string, elements are separated by elemDelim </p>

<p>Definition at line <a class="el" href="WeightedAccumulator_8hh_source.html#l00559">559</a> of file <a class="el" href="WeightedAccumulator_8hh_source.html">WeightedAccumulator.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a3f3bb240b85cdc445dd6f32eb7e97d4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classLattice_1_1Core_1_1Choice.html">Choice</a> Lattice::Core::boolChoice</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predefined <a class="el" href="classLattice_1_1Core_1_1Choice.html" title="Choice class. ">Choice</a> for boolean values. </p>
<p>(e.g. "true", "false, "yes", "no" ...). </p>

</div>
</div>
<a class="anchor" id="a0fc3f40a46dc40b78ff9f039168afdf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classLattice_1_1Core_1_1Choice.html">Choice</a> Lattice::Core::infinityChoice</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predefined <a class="el" href="classLattice_1_1Core_1_1Choice.html" title="Choice class. ">Choice</a> for "inifinite" numbers. </p>
<p>(e.g. "infinite", "-infinity", "unlimited" ...) </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
