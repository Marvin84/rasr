<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Sprint: Math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sprint
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Copyright 2020 RWTH Aachen University.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1absoluteDifference.html">absoluteDifference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute difference function  <a href="structMath_1_1absoluteDifference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1absoluteDifferencePower.html">absoluteDifferencePower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute difference to the power function  <a href="classMath_1_1absoluteDifferencePower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1absoluteDifferenceSquare.html">absoluteDifferenceSquare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute difference square function  <a href="structMath_1_1absoluteDifferenceSquare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1absoluteDifferenceSquareRoot.html">absoluteDifferenceSquareRoot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute difference square-root function  <a href="structMath_1_1absoluteDifferenceSquareRoot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1AdditionFunction.html">AdditionFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x, y) = x + y  <a href="structMath_1_1AdditionFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1AnalyticFunction.html">AnalyticFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class for analytic functions.  <a href="classMath_1_1AnalyticFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1AnalyticFunctionFactory.html">AnalyticFunctionFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analytic function factory.  <a href="classMath_1_1AnalyticFunctionFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1AnalyticMultiplication.html">AnalyticMultiplication</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x)*g(x)  <a href="classMath_1_1AnalyticMultiplication.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1AnalyticNesting.html">AnalyticNesting</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(g(x))  <a href="classMath_1_1AnalyticNesting.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1AnalyticSummation.html">AnalyticSummation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x)+g(x)  <a href="classMath_1_1AnalyticSummation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1AnalyticUnaryComposition.html">AnalyticUnaryComposition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for Composition of two analytic functions.  <a href="classMath_1_1AnalyticUnaryComposition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1ArcCosh.html">ArcCosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x) = acosh(x) Remarks: -acosh(x) = log(x + sqrt(x^2 - 1)).  <a href="structMath_1_1ArcCosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1ArcSinh.html">ArcSinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x) = asinh(x) Remarks: -asinh(x) = log(x + sqrt(x^2 + 1)).  <a href="structMath_1_1ArcSinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1BilinearTransform.html">BilinearTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bilinear Transform.  <a href="structMath_1_1BilinearTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1BinaryAnalyticFunction.html">BinaryAnalyticFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class for binary analytic functions.  <a href="classMath_1_1BinaryAnalyticFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1CgPreconditioner.html">CgPreconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1conjugateMultiplies.html">conjugateMultiplies</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">functors for x * conjugate(y)  <a href="structMath_1_1conjugateMultiplies.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1ConstantFunction.html">ConstantFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x) = c  <a href="classMath_1_1ConstantFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1Cosh.html">Cosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x) = cosh(x)  <a href="structMath_1_1Cosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1cublasHandle__t.html">cublasHandle_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1CudaDataStructure.html">CudaDataStructure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1CudaMatrix.html">CudaMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1CudaVector.html">CudaVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1curandGenerator__t.html">curandGenerator_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1DerivedArcCosh.html">DerivedArcCosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x) = d acosh(x) / dx = 1 / sqrt(x^2 - 1)  <a href="structMath_1_1DerivedArcCosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1DerivedArcSinh.html">DerivedArcSinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x) = d asinh(x) / dx = 1 / sqrt(x^2 + 1)  <a href="structMath_1_1DerivedArcSinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1DerivedMelWarpingCore.html">DerivedMelWarpingCore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived Mel warping function core: d f_{Mel} / df = 1.0 / log(10) / (700.0 + f)  <a href="structMath_1_1DerivedMelWarpingCore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1DiagonalCgPreconditioner.html">DiagonalCgPreconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1DivisionFunction.html">DivisionFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x, y) = x / y  <a href="structMath_1_1DivisionFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1EigenvalueProblem.html">EigenvalueProblem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for eigenvalue problems.  <a href="classMath_1_1EigenvalueProblem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1EqualLoudnessPreemphasis.html">EqualLoudnessPreemphasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal Loudness Preemphasis E(f) = (omega^4 * (omega^2 + 56.8e6)) / ((omega^2 + 6.3e6))^2 * (omega^2 + 0.38e9) * (omega^6 + 9.58e26)) E(f) *= 9.58e26 (last pole's omega) to get values in order of magnitude of 1 at 4000 Hz.  <a href="structMath_1_1EqualLoudnessPreemphasis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1EqualLoudnessPreemphasis40dB.html">EqualLoudnessPreemphasis40dB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">40dB equal Loudness Preemphasis (taken from Sprachcore/ICSI) E(f) = (f^2 / (f^2 + 1.6e5)) * (f^2 / (f^2 + 1.6e5))  <a href="structMath_1_1EqualLoudnessPreemphasis40dB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1EqualLoudnessPreemphasis4Khz.html">EqualLoudnessPreemphasis4Khz</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal Loudness Preemphasis optimized for 4KHz bandwidth E(f) = (omega^4 * (omega^2 + 56.8e6)) / ((omega^2 + 6.3e6))^2 * (omega^2 + 0.38e9))  <a href="structMath_1_1EqualLoudnessPreemphasis4Khz.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1FastFourierTransform.html">FastFourierTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast Fourier Transformation.  <a href="classMath_1_1FastFourierTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1FastMatrix.html">FastMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1FastVector.html">FastVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1FloorFloatFunction.html">FloorFloatFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x) = floorf(x)  <a href="structMath_1_1FloorFloatFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1GeneralizedEigenvalueProblem.html">GeneralizedEigenvalueProblem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for generalized eigenvalue problems.  <a href="classMath_1_1GeneralizedEigenvalueProblem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1IdentityFunction.html">IdentityFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x) = x  <a href="structMath_1_1IdentityFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1InverseMelWarpingCore.html">InverseMelWarpingCore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of Mel warping function core: f = (10^(f_{Mel}) - 1) * 700.  <a href="structMath_1_1InverseMelWarpingCore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1LbfgsPreconditioner.html">LbfgsPreconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1LbfgsSolver.html">LbfgsSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1LevinsonLeastSquares.html">LevinsonLeastSquares</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Levinson algorithm to estimate all-pole linear predication parameters.  <a href="classMath_1_1LevinsonLeastSquares.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1LinearConjugateGradient.html">LinearConjugateGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1makeComplex.html">makeComplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">functor for the template constructor std::complex&lt;T&gt;::complex  <a href="structMath_1_1makeComplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for two-dimensional arrays.  <a href="classMath_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1MatrixTool.html">MatrixTool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1MelWarpingCore.html">MelWarpingCore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mel warping function core f_{Mel} = log10 (1 + f / 700)  <a href="structMath_1_1MelWarpingCore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1Module__.html">Module_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1MultiplicationFunction.html">MultiplicationFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x, y) = x * y  <a href="structMath_1_1MultiplicationFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1OffsetFunction.html">OffsetFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x) = x + b  <a href="classMath_1_1OffsetFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1PiecewiseConstantFunction.html">PiecewiseConstantFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piecewise constant function.  <a href="classMath_1_1PiecewiseConstantFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1PiecewiseLinearFunction.html">PiecewiseLinearFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1pointerAbs.html">pointerAbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">function pointer functor to the template function abs(const std::complex&lt;T&gt; &amp;)  <a href="structMath_1_1pointerAbs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1pointerArg.html">pointerArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">function pointer functor to the template function arg(const std::complex&lt;T&gt; &amp;)  <a href="structMath_1_1pointerArg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1pointerImag.html">pointerImag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">function pointer functor to the template function imag(const std::complex&lt;T&gt; &amp;)  <a href="structMath_1_1pointerImag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1pointerReal.html">pointerReal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">function pointer functor to the template function real(const std::complex&lt;T&gt; &amp;)  <a href="structMath_1_1pointerReal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1ReferenceCountedVector.html">ReferenceCountedVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1RefernceCountedMatrix.html">RefernceCountedMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refernce Counted <a class="el" href="classMath_1_1Matrix.html" title="Class for two-dimensional arrays. ">Matrix</a>.  <a href="classMath_1_1RefernceCountedMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1ScalingFunction.html">ScalingFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x) = a * x  <a href="classMath_1_1ScalingFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1Sinh.html">Sinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x) = sinh(x)  <a href="structMath_1_1Sinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1SubstractionFunction.html">SubstractionFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x, y) = x - y  <a href="structMath_1_1SubstractionFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1UnaryAnalyticFunction.html">UnaryAnalyticFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class for unary analytic functions.  <a href="classMath_1_1UnaryAnalyticFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1Vector.html">Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1VectorRangeCheckOffPolicy.html">VectorRangeCheckOffPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMath_1_1VectorRangeCheckOnPolicy.html">VectorRangeCheckOnPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8274f80bf3df6e1015d0c1cd5f7bf213"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8274f80bf3df6e1015d0c1cd5f7bf213"></a>
typedef <a class="el" href="classCore_1_1Ref.html">Core::Ref</a>&lt; const <a class="el" href="classMath_1_1UnaryAnalyticFunction.html">UnaryAnalyticFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>UnaryAnalyticFunctionRef</b></td></tr>
<tr class="separator:a8274f80bf3df6e1015d0c1cd5f7bf213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41ad4319e705fce287365fa3c4389bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad41ad4319e705fce287365fa3c4389bb"></a>
typedef <a class="el" href="classCore_1_1Ref.html">Core::Ref</a>&lt; const <a class="el" href="classMath_1_1BinaryAnalyticFunction.html">BinaryAnalyticFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BinaryAnalyticFunctionRef</b></td></tr>
<tr class="separator:ad41ad4319e705fce287365fa3c4389bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8509866409186542c7d0d41208b46f6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8509866409186542c7d0d41208b46f6f"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>curandRngType_t</b></td></tr>
<tr class="separator:a8509866409186542c7d0d41208b46f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44a2ae94e59fb10b7cb759f38487fb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af44a2ae94e59fb10b7cb759f38487fb5"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><b>cudaStream_t</b></td></tr>
<tr class="separator:af44a2ae94e59fb10b7cb759f38487fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0c12d2beeb80cdc45867687d4e7e59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d0c12d2beeb80cdc45867687d4e7e59"></a>
typedef <a class="el" href="classCore_1_1SingletonHolder.html">Core::SingletonHolder</a>&lt; <a class="el" href="classMath_1_1Module__.html">Module_</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Module</b></td></tr>
<tr class="separator:a4d0c12d2beeb80cdc45867687d4e7e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a73d10fa5f304d017a9cc9eabcd40ec32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73d10fa5f304d017a9cc9eabcd40ec32"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>cudaError_t</b> { <b>cudaSuccess</b> = 0
 }</td></tr>
<tr class="separator:a73d10fa5f304d017a9cc9eabcd40ec32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685057a1a65c55d1f5c49bdae96af4ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a685057a1a65c55d1f5c49bdae96af4ad"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>cublasStatus_t</b> { <b>CUBLAS_STATUS_SUCCESS</b> = 0
 }</td></tr>
<tr class="separator:a685057a1a65c55d1f5c49bdae96af4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c083427d10c3636c77bff810adc5e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91c083427d10c3636c77bff810adc5e3"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>curandStatus_t</b> { <b>CURAND_STATUS_SUCCESS</b> = 0
 }</td></tr>
<tr class="separator:a91c083427d10c3636c77bff810adc5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af1892bf101eafdb2dbd572be51b28375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMath.html#af1892bf101eafdb2dbd572be51b28375">operator+</a> (<a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a> f, <a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a> g)</td></tr>
<tr class="memdesc:af1892bf101eafdb2dbd572be51b28375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classMath_1_1AnalyticSummation.html" title="f(x)+g(x) ">AnalyticSummation</a> object.  <a href="#af1892bf101eafdb2dbd572be51b28375">More...</a><br /></td></tr>
<tr class="separator:af1892bf101eafdb2dbd572be51b28375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01e9b90be52ed22f0f4a9e10cf0e06f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMath.html#ac01e9b90be52ed22f0f4a9e10cf0e06f">operator*</a> (<a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a> f, <a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a> g)</td></tr>
<tr class="memdesc:ac01e9b90be52ed22f0f4a9e10cf0e06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classMath_1_1AnalyticMultiplication.html" title="f(x)*g(x) ">AnalyticMultiplication</a> object.  <a href="#ac01e9b90be52ed22f0f4a9e10cf0e06f">More...</a><br /></td></tr>
<tr class="separator:ac01e9b90be52ed22f0f4a9e10cf0e06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181795f43bb7c66a8254cfcae4d922d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMath.html#a181795f43bb7c66a8254cfcae4d922d4">nest</a> (<a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a> f, <a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a> g)</td></tr>
<tr class="memdesc:a181795f43bb7c66a8254cfcae4d922d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classMath_1_1AnalyticNesting.html" title="f(g(x)) ">AnalyticNesting</a> object.  <a href="#a181795f43bb7c66a8254cfcae4d922d4">More...</a><br /></td></tr>
<tr class="separator:a181795f43bb7c66a8254cfcae4d922d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1184da98ac274b10bd5ab8e4dd727f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca1184da98ac274b10bd5ab8e4dd727f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#aca1184da98ac274b10bd5ab8e4dd727f">swap</a> (const int N, T *X, const int incX, T *Y, const int incY)</td></tr>
<tr class="memdesc:aca1184da98ac274b10bd5ab8e4dd727f"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap ()  <a href="#aca1184da98ac274b10bd5ab8e4dd727f">More...</a><br /></td></tr>
<tr class="separator:aca1184da98ac274b10bd5ab8e4dd727f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3e8691ef3da1f59ecc554d1c6a4d26"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9a3e8691ef3da1f59ecc554d1c6a4d26"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9a3e8691ef3da1f59ecc554d1c6a4d26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (const int N, float *X, const int incX, float *Y, const int incY)</td></tr>
<tr class="separator:a9a3e8691ef3da1f59ecc554d1c6a4d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b4ca7a0f3b740b4ff1903d9ed4563b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a63b4ca7a0f3b740b4ff1903d9ed4563b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a63b4ca7a0f3b740b4ff1903d9ed4563b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (const int N, double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="separator:a63b4ca7a0f3b740b4ff1903d9ed4563b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb16729d0a6885632ca02913fe6b7f44"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb16729d0a6885632ca02913fe6b7f44"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#adb16729d0a6885632ca02913fe6b7f44">nrm2</a> (const int N, const T *X, const int incX)</td></tr>
<tr class="memdesc:adb16729d0a6885632ca02913fe6b7f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">nrm2 ( Euclidean norm)  <a href="#adb16729d0a6885632ca02913fe6b7f44">More...</a><br /></td></tr>
<tr class="separator:adb16729d0a6885632ca02913fe6b7f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4ca3aebfe51aacef5091a1e3ac1e32"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8e4ca3aebfe51aacef5091a1e3ac1e32"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8e4ca3aebfe51aacef5091a1e3ac1e32"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nrm2</b> (const int N, const float *X, const int incX)</td></tr>
<tr class="separator:a8e4ca3aebfe51aacef5091a1e3ac1e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68014a0174504fd1510bddf9dfc939a8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a68014a0174504fd1510bddf9dfc939a8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a68014a0174504fd1510bddf9dfc939a8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nrm2</b> (const int N, const double *X, const int incX)</td></tr>
<tr class="separator:a68014a0174504fd1510bddf9dfc939a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8229c25908db3f6986fc56b32012fd99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8229c25908db3f6986fc56b32012fd99"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#a8229c25908db3f6986fc56b32012fd99">asum</a> (const int N, const T *X, const int incX)</td></tr>
<tr class="memdesc:a8229c25908db3f6986fc56b32012fd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">asum (one-norm)  <a href="#a8229c25908db3f6986fc56b32012fd99">More...</a><br /></td></tr>
<tr class="separator:a8229c25908db3f6986fc56b32012fd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806d0a2d30e90eb82dd7df6c3e4b9ed4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a806d0a2d30e90eb82dd7df6c3e4b9ed4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a806d0a2d30e90eb82dd7df6c3e4b9ed4"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>asum&lt; double &gt;</b> (const int N, const double *X, const int incX)</td></tr>
<tr class="separator:a806d0a2d30e90eb82dd7df6c3e4b9ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd03bd19fd07f467b77be1127971f96b"><td class="memTemplParams" colspan="2"><a class="anchor" id="abd03bd19fd07f467b77be1127971f96b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abd03bd19fd07f467b77be1127971f96b"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><b>asum&lt; float &gt;</b> (const int N, const float *X, const int incX)</td></tr>
<tr class="separator:abd03bd19fd07f467b77be1127971f96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef8b4cc949f2fbf51b443ebd80e6528"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ef8b4cc949f2fbf51b443ebd80e6528"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#a3ef8b4cc949f2fbf51b443ebd80e6528">iamax</a> (const int N, const T *X, const int incX)</td></tr>
<tr class="memdesc:a3ef8b4cc949f2fbf51b443ebd80e6528"><td class="mdescLeft">&#160;</td><td class="mdescRight">iamax  <a href="#a3ef8b4cc949f2fbf51b443ebd80e6528">More...</a><br /></td></tr>
<tr class="separator:a3ef8b4cc949f2fbf51b443ebd80e6528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffa2da4fc5f8ebc36d134508a2aaa1f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7ffa2da4fc5f8ebc36d134508a2aaa1f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7ffa2da4fc5f8ebc36d134508a2aaa1f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iamax&lt; double &gt;</b> (const int N, const double *X, const int incX)</td></tr>
<tr class="separator:a7ffa2da4fc5f8ebc36d134508a2aaa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a6be848df0737a95a7578281c1004e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a19a6be848df0737a95a7578281c1004e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a19a6be848df0737a95a7578281c1004e"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iamax&lt; float &gt;</b> (const int N, const float *X, const int incX)</td></tr>
<tr class="separator:a19a6be848df0737a95a7578281c1004e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994c78e8c5671930de56f949b0dca8e2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a994c78e8c5671930de56f949b0dca8e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#a994c78e8c5671930de56f949b0dca8e2">scal</a> (const int N, const T alpha, T *X, const int incX)</td></tr>
<tr class="memdesc:a994c78e8c5671930de56f949b0dca8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">scal ( vector scaling)  <a href="#a994c78e8c5671930de56f949b0dca8e2">More...</a><br /></td></tr>
<tr class="separator:a994c78e8c5671930de56f949b0dca8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab399d97bd5d5ae88742b30a11664a237"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab399d97bd5d5ae88742b30a11664a237"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab399d97bd5d5ae88742b30a11664a237"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scal&lt; double &gt;</b> (const int N, const double alpha, double *X, const int incX)</td></tr>
<tr class="separator:ab399d97bd5d5ae88742b30a11664a237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be0bc33c0ab9db777228175abcb9b52"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5be0bc33c0ab9db777228175abcb9b52"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5be0bc33c0ab9db777228175abcb9b52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scal&lt; float &gt;</b> (const int N, const float alpha, float *X, const int incX)</td></tr>
<tr class="separator:a5be0bc33c0ab9db777228175abcb9b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9a58436b6a438b08d2fa61d1cb8391"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a5a9a58436b6a438b08d2fa61d1cb8391"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#a5a9a58436b6a438b08d2fa61d1cb8391">axpy</a> (const int N, const T alpha, const T *X, const int incX, S *Y, const int incY)</td></tr>
<tr class="memdesc:a5a9a58436b6a438b08d2fa61d1cb8391"><td class="mdescLeft">&#160;</td><td class="mdescRight">axpy (weighted vector sum)  <a href="#a5a9a58436b6a438b08d2fa61d1cb8391">More...</a><br /></td></tr>
<tr class="separator:a5a9a58436b6a438b08d2fa61d1cb8391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed2292698b7c8e37863b38248ea8386"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeed2292698b7c8e37863b38248ea8386"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aeed2292698b7c8e37863b38248ea8386"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>axpy&lt; double, double &gt;</b> (const int N, const double alpha, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="separator:aeed2292698b7c8e37863b38248ea8386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d22460fa498e6685141b6c63fee4b0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab8d22460fa498e6685141b6c63fee4b0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab8d22460fa498e6685141b6c63fee4b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>axpy&lt; float, float &gt;</b> (const int N, const float alpha, const float *X, const int incX, float *Y, const int incY)</td></tr>
<tr class="separator:ab8d22460fa498e6685141b6c63fee4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad732fbcf622b46ad384ce958f1d74dee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ad732fbcf622b46ad384ce958f1d74dee"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#ad732fbcf622b46ad384ce958f1d74dee">dot</a> (const int N, const T *X, const int incX, const S *Y, const int incY, int nThreads=1)</td></tr>
<tr class="memdesc:ad732fbcf622b46ad384ce958f1d74dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">dot (dot product)  <a href="#ad732fbcf622b46ad384ce958f1d74dee">More...</a><br /></td></tr>
<tr class="separator:ad732fbcf622b46ad384ce958f1d74dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3247f50749d79b65d5d8eab9b8f5c04"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae3247f50749d79b65d5d8eab9b8f5c04"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae3247f50749d79b65d5d8eab9b8f5c04"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dot&lt; double, double &gt;</b> (const int N, const double *X, const int incX, const double *Y, const int incY, int nThreads)</td></tr>
<tr class="separator:ae3247f50749d79b65d5d8eab9b8f5c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab642d5570290f97711f4b3f87fd7aeb3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab642d5570290f97711f4b3f87fd7aeb3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab642d5570290f97711f4b3f87fd7aeb3"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dot&lt; float, float &gt;</b> (const int N, const float *X, const int incX, const float *Y, const int incY, int nThreads)</td></tr>
<tr class="separator:ab642d5570290f97711f4b3f87fd7aeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca9005a7de9e2e67fc1f4aa778467d5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a0ca9005a7de9e2e67fc1f4aa778467d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#a0ca9005a7de9e2e67fc1f4aa778467d5">copy</a> (const int N, const T *X, const int incX, S *Y, const int incY)</td></tr>
<tr class="memdesc:a0ca9005a7de9e2e67fc1f4aa778467d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy  <a href="#a0ca9005a7de9e2e67fc1f4aa778467d5">More...</a><br /></td></tr>
<tr class="separator:a0ca9005a7de9e2e67fc1f4aa778467d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308b809584a2a9bd7fb4395fcd6fbe67"><td class="memTemplParams" colspan="2"><a class="anchor" id="a308b809584a2a9bd7fb4395fcd6fbe67"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a308b809584a2a9bd7fb4395fcd6fbe67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy&lt; double, double &gt;</b> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="separator:a308b809584a2a9bd7fb4395fcd6fbe67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda99997bfab2266102dc0968c8fd21c"><td class="memTemplParams" colspan="2"><a class="anchor" id="acda99997bfab2266102dc0968c8fd21c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acda99997bfab2266102dc0968c8fd21c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy&lt; float, float &gt;</b> (const int N, const float *X, const int incX, float *Y, const int incY)</td></tr>
<tr class="separator:acda99997bfab2266102dc0968c8fd21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf8fcf326d2a29c40539fb5a5e35c9d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7bf8fcf326d2a29c40539fb5a5e35c9d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7bf8fcf326d2a29c40539fb5a5e35c9d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ger</b> (const CBLAS_ORDER order, const int M, const int N, const T alpha, const T *X, const int incX, const T *Y, const int incY, T *A, const int lda)</td></tr>
<tr class="separator:a7bf8fcf326d2a29c40539fb5a5e35c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4848d1e0d5b1d3af7ba9bb7dccb7de0b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4848d1e0d5b1d3af7ba9bb7dccb7de0b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4848d1e0d5b1d3af7ba9bb7dccb7de0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ger</b> (const CBLAS_ORDER order, const int M, const int N, const float alpha, const float *X, const int incX, const float *Y, const int incY, float *A, const int lda)</td></tr>
<tr class="separator:a4848d1e0d5b1d3af7ba9bb7dccb7de0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab450388ab8f2d9f36b579670cc08ff11"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab450388ab8f2d9f36b579670cc08ff11"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab450388ab8f2d9f36b579670cc08ff11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ger</b> (const CBLAS_ORDER order, const int M, const int N, const double alpha, const double *X, const int incX, const double *Y, const int incY, double *A, const int lda)</td></tr>
<tr class="separator:ab450388ab8f2d9f36b579670cc08ff11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e92e8f0e76ce7c5cdca8dce55d6351"><td class="memTemplParams" colspan="2"><a class="anchor" id="a26e92e8f0e76ce7c5cdca8dce55d6351"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26e92e8f0e76ce7c5cdca8dce55d6351"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gemv</b> (const CBLAS_ORDER order, const CBLAS_TRANSPOSE TransA, const int M, const int N, const T alpha, const T *A, const int lda, const T *X, const int incX, const T beta, T *Y, const int incY)</td></tr>
<tr class="separator:a26e92e8f0e76ce7c5cdca8dce55d6351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac659b47b5b593e0d07666311d071ac39"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac659b47b5b593e0d07666311d071ac39"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac659b47b5b593e0d07666311d071ac39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gemv&lt; double &gt;</b> (const CBLAS_ORDER order, const CBLAS_TRANSPOSE TransA, const int M, const int N, const double alpha, const double *A, const int lda, const double *X, const int incX, const double beta, double *Y, const int incY)</td></tr>
<tr class="separator:ac659b47b5b593e0d07666311d071ac39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef1dfaa702466c16b59d7d82172fdb9"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeef1dfaa702466c16b59d7d82172fdb9"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aeef1dfaa702466c16b59d7d82172fdb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gemv&lt; float &gt;</b> (const CBLAS_ORDER order, const CBLAS_TRANSPOSE TransA, const int M, const int N, const float alpha, const float *A, const int lda, const float *X, const int incX, const float beta, float *Y, const int incY)</td></tr>
<tr class="separator:aeef1dfaa702466c16b59d7d82172fdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8496bf2c98e3e1d18cf7b05a54ac9b16"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8496bf2c98e3e1d18cf7b05a54ac9b16"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8496bf2c98e3e1d18cf7b05a54ac9b16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gemm</b> (const CBLAS_ORDER order, const CBLAS_TRANSPOSE TransA, const CBLAS_TRANSPOSE TransB, const int M, const int N, const int K, const T alpha, const T *A, const int lda, const T *B, const int ldb, const T beta, T *C, const int ldc)</td></tr>
<tr class="separator:a8496bf2c98e3e1d18cf7b05a54ac9b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53014245ecb086c194d6ebee028e836"><td class="memTemplParams" colspan="2"><a class="anchor" id="af53014245ecb086c194d6ebee028e836"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af53014245ecb086c194d6ebee028e836"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gemm&lt; float &gt;</b> (const CBLAS_ORDER order, const CBLAS_TRANSPOSE transMatrixA, const CBLAS_TRANSPOSE transMatrixB, const int sizeM, const int sizeN, const int sizeK, const float scaleMatrixA, const float *matrixA, const int lda, const float *matrixB, const int ldab, const float scaleMatrixC, float *matrixC, const int ldc)</td></tr>
<tr class="separator:af53014245ecb086c194d6ebee028e836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b99961e662a97b7c0ca8244d0e54470"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b99961e662a97b7c0ca8244d0e54470"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4b99961e662a97b7c0ca8244d0e54470"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gemm&lt; double &gt;</b> (const CBLAS_ORDER order, const CBLAS_TRANSPOSE transMatrixA, const CBLAS_TRANSPOSE transMatrixB, const int sizeM, const int sizeN, const int sizeK, const double scaleMatrixA, const double *matrixA, const int lda, const double *matrixB, const int ldb, const double scaleMatrixC, double *matrixC, const int ldc)</td></tr>
<tr class="separator:a4b99961e662a97b7c0ca8244d0e54470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91ce72d4a25fc97547271f893672fd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac91ce72d4a25fc97547271f893672fd3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getMathLibrary</b> ()</td></tr>
<tr class="separator:ac91ce72d4a25fc97547271f893672fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12246d87e8e0aac82133fa5164103bca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a12246d87e8e0aac82133fa5164103bca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#a12246d87e8e0aac82133fa5164103bca">mt_scal</a> (int N, T alpha, T *X, int nThreads)</td></tr>
<tr class="memdesc:a12246d87e8e0aac82133fa5164103bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">(simplified) multithreaded versions that are not automatically parallelized by corresponding math library  <a href="#a12246d87e8e0aac82133fa5164103bca">More...</a><br /></td></tr>
<tr class="separator:a12246d87e8e0aac82133fa5164103bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545621724af810e1183931bcb6b3fa05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a545621724af810e1183931bcb6b3fa05"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__mt_scal_f</b> (int N, float alpha, const float *dummy, float *X)</td></tr>
<tr class="separator:a545621724af810e1183931bcb6b3fa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3764dc79b26f05f078a1bd6266280eec"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3764dc79b26f05f078a1bd6266280eec"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3764dc79b26f05f078a1bd6266280eec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_scal</b> (int N, float alpha, float *X, int nThreads)</td></tr>
<tr class="separator:a3764dc79b26f05f078a1bd6266280eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabef236c8e5741ad987d1689ac11dc7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabef236c8e5741ad987d1689ac11dc7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__mt_scal_d</b> (int N, double alpha, const double *dummy, double *X)</td></tr>
<tr class="separator:aabef236c8e5741ad987d1689ac11dc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4bc597b7b147605558bcc3ebc12cf6"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb4bc597b7b147605558bcc3ebc12cf6"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abb4bc597b7b147605558bcc3ebc12cf6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_scal</b> (int N, double alpha, double *X, int nThreads)</td></tr>
<tr class="separator:abb4bc597b7b147605558bcc3ebc12cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f800545a57bab45300f924e323ada7"><td class="memTemplParams" colspan="2"><a class="anchor" id="af2f800545a57bab45300f924e323ada7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2f800545a57bab45300f924e323ada7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_axpy</b> (int N, T alpha, const T *X, T *Y, int nThreads)</td></tr>
<tr class="separator:af2f800545a57bab45300f924e323ada7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52588f38abca329783e9fbdb19dde403"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52588f38abca329783e9fbdb19dde403"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__mt_axpy_f</b> (int N, float alpha, const float *X, float *Y)</td></tr>
<tr class="separator:a52588f38abca329783e9fbdb19dde403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5740693fa22a7aa7d1f762f4c889ad"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2e5740693fa22a7aa7d1f762f4c889ad"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2e5740693fa22a7aa7d1f762f4c889ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_axpy</b> (int N, float alpha, const float *X, float *Y, int nThreads)</td></tr>
<tr class="separator:a2e5740693fa22a7aa7d1f762f4c889ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af352bdaec2d377507d4194d467c0e699"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af352bdaec2d377507d4194d467c0e699"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__mt_axpy_d</b> (int N, double alpha, const double *X, double *Y)</td></tr>
<tr class="separator:af352bdaec2d377507d4194d467c0e699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0a14fd9643921d07af8032e7a6bb64"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed0a14fd9643921d07af8032e7a6bb64"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aed0a14fd9643921d07af8032e7a6bb64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_axpy</b> (int N, double alpha, const double *X, double *Y, int nThreads)</td></tr>
<tr class="separator:aed0a14fd9643921d07af8032e7a6bb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9bcb8ffcc943d2534fdbd6960df709"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa9bcb8ffcc943d2534fdbd6960df709"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa9bcb8ffcc943d2534fdbd6960df709"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_dot</b> (int N, const T *X, const T *Y, int nThreads)</td></tr>
<tr class="separator:aaa9bcb8ffcc943d2534fdbd6960df709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0da9781b4f345568e5da12cf7c20360"><td class="memTemplParams" colspan="2"><a class="anchor" id="af0da9781b4f345568e5da12cf7c20360"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af0da9781b4f345568e5da12cf7c20360"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_dot</b> (int N, T alpha, const T *X, const T *Y, int nThreads)</td></tr>
<tr class="separator:af0da9781b4f345568e5da12cf7c20360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37073c3a615585e57433c275f0a974b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37073c3a615585e57433c275f0a974b6"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>__mt_dot_f</b> (int N, float dummy, const float *X, const float *Y)</td></tr>
<tr class="separator:a37073c3a615585e57433c275f0a974b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9404879ee08152b939bdd51f1b6e027a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9404879ee08152b939bdd51f1b6e027a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9404879ee08152b939bdd51f1b6e027a"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_dot</b> (int N, const float *X, const float *Y, int nThreads)</td></tr>
<tr class="separator:a9404879ee08152b939bdd51f1b6e027a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7611194411cf7fb83824c090758987"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a7611194411cf7fb83824c090758987"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>__mt_dot_d</b> (int N, double dummy, const double *X, const double *Y)</td></tr>
<tr class="separator:a4a7611194411cf7fb83824c090758987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0caf09fd78ef7144f3ceb832d2800d7b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0caf09fd78ef7144f3ceb832d2800d7b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0caf09fd78ef7144f3ceb832d2800d7b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_dot</b> (int N, const double *X, const double *Y, int nThreads)</td></tr>
<tr class="separator:a0caf09fd78ef7144f3ceb832d2800d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba310ecdc34f6e77ebe55a66d567b07"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ba310ecdc34f6e77ebe55a66d567b07"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ba310ecdc34f6e77ebe55a66d567b07"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_nrm2</b> (int N, const T *X, int nThreads)</td></tr>
<tr class="separator:a8ba310ecdc34f6e77ebe55a66d567b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d79894ccf4a6088569ede3e29bb683"><td class="memTemplParams" colspan="2"><a class="anchor" id="a69d79894ccf4a6088569ede3e29bb683"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69d79894ccf4a6088569ede3e29bb683"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_nrm2</b> (int N, T alpha, const T *X, int nThreads)</td></tr>
<tr class="separator:a69d79894ccf4a6088569ede3e29bb683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af058684fb367770ca6ce47a04280342b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af058684fb367770ca6ce47a04280342b"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>__mt_nrm2_f</b> (int N, float dummy1, const float *X, const float *dummy2)</td></tr>
<tr class="separator:af058684fb367770ca6ce47a04280342b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3fb0511324c7583332d398d0370063"><td class="memTemplParams" colspan="2"><a class="anchor" id="ada3fb0511324c7583332d398d0370063"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ada3fb0511324c7583332d398d0370063"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_nrm2</b> (int N, const float *X, int nThreads)</td></tr>
<tr class="separator:ada3fb0511324c7583332d398d0370063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6601b66108e575b9b7547219fe56c22c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6601b66108e575b9b7547219fe56c22c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>__mt_nrm2_d</b> (int N, double dummy1, const double *X, const double *dummy2)</td></tr>
<tr class="separator:a6601b66108e575b9b7547219fe56c22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1105db98a85373ed62d141dfcf1ced2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac1105db98a85373ed62d141dfcf1ced2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac1105db98a85373ed62d141dfcf1ced2"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_nrm2</b> (int N, const double *X, int nThreads)</td></tr>
<tr class="separator:ac1105db98a85373ed62d141dfcf1ced2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da3ecda99b788060674c1fccacc8a19"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2da3ecda99b788060674c1fccacc8a19"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2da3ecda99b788060674c1fccacc8a19"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_asum</b> (int N, const T *X, int nThreads)</td></tr>
<tr class="separator:a2da3ecda99b788060674c1fccacc8a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad962a96fd437e0c399c6293218802cf7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad962a96fd437e0c399c6293218802cf7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad962a96fd437e0c399c6293218802cf7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_asum</b> (int N, T alpha, const T *X, int nThreads)</td></tr>
<tr class="separator:ad962a96fd437e0c399c6293218802cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc245bae5c2f699c825b9f1e5639ed73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc245bae5c2f699c825b9f1e5639ed73"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>__mt_asum_f</b> (int N, float dummy1, const float *X, const float *dummy2)</td></tr>
<tr class="separator:adc245bae5c2f699c825b9f1e5639ed73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b432990b0e385365ff6a94e59e7355d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2b432990b0e385365ff6a94e59e7355d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2b432990b0e385365ff6a94e59e7355d"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_asum</b> (int N, const float *X, int nThreads)</td></tr>
<tr class="separator:a2b432990b0e385365ff6a94e59e7355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8344d9ab1ceef540051704df7875644f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8344d9ab1ceef540051704df7875644f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>__mt_asum_d</b> (int N, double dummy1, const double *X, const double *dummy2)</td></tr>
<tr class="separator:a8344d9ab1ceef540051704df7875644f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ac11f80c51048d3f6b8a51759f50d0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a50ac11f80c51048d3f6b8a51759f50d0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a50ac11f80c51048d3f6b8a51759f50d0"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_asum</b> (int N, const double *X, int nThreads)</td></tr>
<tr class="separator:a50ac11f80c51048d3f6b8a51759f50d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73085744d407619c9839cee8ca7a0fde"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class Operation &gt; </td></tr>
<tr class="memitem:a73085744d407619c9839cee8ca7a0fde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#a73085744d407619c9839cee8ca7a0fde">transformAlternatingComplex</a> (InputIterator first, InputIterator last, OutputIterator result, Operation operation)</td></tr>
<tr class="memdesc:a73085744d407619c9839cee8ca7a0fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">tranforms alternating complex vector into an arbitrary type (Alternating complex vectors are stored in a standard container by storing the real and the imaginary parts alternating.)  <a href="#a73085744d407619c9839cee8ca7a0fde">More...</a><br /></td></tr>
<tr class="separator:a73085744d407619c9839cee8ca7a0fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fc1fa727e1b4765e598ae1ba88463a"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class Operation &gt; </td></tr>
<tr class="memitem:a95fc1fa727e1b4765e598ae1ba88463a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#a95fc1fa727e1b4765e598ae1ba88463a">transformToAlternatingComplex</a> (InputIterator first, InputIterator last, OutputIterator result, Operation operation)</td></tr>
<tr class="memdesc:a95fc1fa727e1b4765e598ae1ba88463a"><td class="mdescLeft">&#160;</td><td class="mdescRight">tranforms a vector of arbitrary type into an alternating complex vector (Alternating complex vectors are stored in a standard container by storing the real and the imaginary parts alternating.) Operation is a unary function (derived from std::unary_function): Argument is of arbitrary type For the result type the functions real and imag must exist.  <a href="#a95fc1fa727e1b4765e598ae1ba88463a">More...</a><br /></td></tr>
<tr class="separator:a95fc1fa727e1b4765e598ae1ba88463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8c1a8a5893b683210e08b795f2814c"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator , class Operation &gt; </td></tr>
<tr class="memitem:a9d8c1a8a5893b683210e08b795f2814c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#a9d8c1a8a5893b683210e08b795f2814c">transformAlternatingComplexToAlternatingComplex</a> (InputIterator first1, InputIterator last1, InputIterator first2, OutputIterator result, Operation operation)</td></tr>
<tr class="memdesc:a9d8c1a8a5893b683210e08b795f2814c"><td class="mdescLeft">&#160;</td><td class="mdescRight">tranforms an alternating complex vector into an alternating complex vector (Alternating complex vectors are stored in a standard container by storing the real and the imaginary parts alternating.)  <a href="#a9d8c1a8a5893b683210e08b795f2814c">More...</a><br /></td></tr>
<tr class="separator:a9d8c1a8a5893b683210e08b795f2814c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab12596867204131645b226dbbcaac1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ab12596867204131645b226dbbcaac1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ab12596867204131645b226dbbcaac1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1XmlWriter.html">Core::XmlWriter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classCore_1_1XmlWriter.html">Core::XmlWriter</a> &amp;os, const <a class="el" href="classMath_1_1CudaVector.html">CudaVector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a2ab12596867204131645b226dbbcaac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1390255bdc70e252fb16817470443fd3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1390255bdc70e252fb16817470443fd3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1390255bdc70e252fb16817470443fd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1XmlWriter.html">Core::XmlWriter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classCore_1_1XmlWriter.html">Core::XmlWriter</a> &amp;os, const <a class="el" href="classMath_1_1FastVector.html">FastVector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a1390255bdc70e252fb16817470443fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069b1a1a1b15df8a0de8041c8c5e6f68"><td class="memTemplParams" colspan="2"><a class="anchor" id="a069b1a1a1b15df8a0de8041c8c5e6f68"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a069b1a1a1b15df8a0de8041c8c5e6f68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vr_exp</b> (int n, T *x, T *y)</td></tr>
<tr class="separator:a069b1a1a1b15df8a0de8041c8c5e6f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ab2dad67bf8c1c9524fec5d350736b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a08ab2dad67bf8c1c9524fec5d350736b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a08ab2dad67bf8c1c9524fec5d350736b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_vr_exp</b> (int n, T *x, T *y, int nThreads)</td></tr>
<tr class="separator:a08ab2dad67bf8c1c9524fec5d350736b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5567af24f5b1d3504ea27b23400b56"><td class="memTemplParams" colspan="2"><a class="anchor" id="aac5567af24f5b1d3504ea27b23400b56"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aac5567af24f5b1d3504ea27b23400b56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vr_log</b> (int n, T *x, T *y)</td></tr>
<tr class="separator:aac5567af24f5b1d3504ea27b23400b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba89da5322da2bc97b068b11b84c9a6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5ba89da5322da2bc97b068b11b84c9a6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ba89da5322da2bc97b068b11b84c9a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vr_powx</b> (int n, T *x, T y, T *z)</td></tr>
<tr class="separator:a5ba89da5322da2bc97b068b11b84c9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd30338c91e24794265e4dd5a9948101"><td class="memTemplParams" colspan="2"><a class="anchor" id="afd30338c91e24794265e4dd5a9948101"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afd30338c91e24794265e4dd5a9948101"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeDiagonalMatrix</b> (size_t dimension, T init=(T) 1)</td></tr>
<tr class="separator:afd30338c91e24794265e4dd5a9948101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405094c15eaf0974f28c708edad632f5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a405094c15eaf0974f28c708edad632f5"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a405094c15eaf0974f28c708edad632f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeDiagonalMatrix</b> (const <a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; T, P &gt; &amp;diagonal)</td></tr>
<tr class="separator:a405094c15eaf0974f28c708edad632f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec8e745c7bc20ee218c18488f485895"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaec8e745c7bc20ee218c18488f485895"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:aaec8e745c7bc20ee218c18488f485895"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; T, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>diagonal</b> (const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt; &amp;m)</td></tr>
<tr class="separator:aaec8e745c7bc20ee218c18488f485895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0b26cde6ba3aecea7072a919ae6a9b"><td class="memTemplParams" colspan="2"><a class="anchor" id="afd0b26cde6ba3aecea7072a919ae6a9b"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:afd0b26cde6ba3aecea7072a919ae6a9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const T &amp;scalar, const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt; &amp;matrix)</td></tr>
<tr class="separator:afd0b26cde6ba3aecea7072a919ae6a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e74c99a2bfb3c1debf6e125daca20f5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e74c99a2bfb3c1debf6e125daca20f5"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a9e74c99a2bfb3c1debf6e125daca20f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multiplyElementwise</b> (const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt; &amp;m1, const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt; &amp;m2)</td></tr>
<tr class="separator:a9e74c99a2bfb3c1debf6e125daca20f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a62efd41528daf2a0e2aa72ae8c770"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae9a62efd41528daf2a0e2aa72ae8c770"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:ae9a62efd41528daf2a0e2aa72ae8c770"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorInnerProduct</b> (const <a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; T, P &gt; &amp;l, const <a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; T, P &gt; &amp;r)</td></tr>
<tr class="separator:ae9a62efd41528daf2a0e2aa72ae8c770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42073d80c6eea2a0c717f70cdd7592a"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa42073d80c6eea2a0c717f70cdd7592a"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:aa42073d80c6eea2a0c717f70cdd7592a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; std::complex&lt; T &gt;, P &gt; &amp;m)</td></tr>
<tr class="separator:aa42073d80c6eea2a0c717f70cdd7592a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cb273332fb955bfed7c3a826f400ad"><td class="memTemplParams" colspan="2"><a class="anchor" id="a76cb273332fb955bfed7c3a826f400ad"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a76cb273332fb955bfed7c3a826f400ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>imag</b> (const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; std::complex&lt; T &gt;, P &gt; &amp;m)</td></tr>
<tr class="separator:a76cb273332fb955bfed7c3a826f400ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d21b4acacf2e836ae85f7095f075f80"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7d21b4acacf2e836ae85f7095f075f80"></a>
template&lt;class T , class P , class TA , class PA &gt; </td></tr>
<tr class="memitem:a7d21b4acacf2e836ae85f7095f075f80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt; &amp;m, <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; TA, PA &gt; &amp;a)</td></tr>
<tr class="separator:a7d21b4acacf2e836ae85f7095f075f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184b903ff7a3bad034124191e42eb9e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a184b903ff7a3bad034124191e42eb9e4"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a184b903ff7a3bad034124191e42eb9e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt; &amp;m)</td></tr>
<tr class="separator:a184b903ff7a3bad034124191e42eb9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0550b0438dc5619683df157ffe0a059"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab0550b0438dc5619683df157ffe0a059"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:ab0550b0438dc5619683df157ffe0a059"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; std::complex&lt; T &gt;, P &gt; &amp;m)</td></tr>
<tr class="separator:ab0550b0438dc5619683df157ffe0a059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a38c7fbf899f20f59b3957b41093d1"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa1a38c7fbf899f20f59b3957b41093d1"></a>
template&lt;class T , class P , class M &gt; </td></tr>
<tr class="memitem:aa1a38c7fbf899f20f59b3957b41093d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>maxAbsoluteElement</b> (const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt; &amp;m, M &amp;r)</td></tr>
<tr class="separator:aa1a38c7fbf899f20f59b3957b41093d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd766ab2971d9c27943e8a0acb7227b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="acd766ab2971d9c27943e8a0acb7227b1"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:acd766ab2971d9c27943e8a0acb7227b1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>maxAbsoluteElement</b> (const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt; &amp;m)</td></tr>
<tr class="separator:acd766ab2971d9c27943e8a0acb7227b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e38292da1d253e5f6e823ffecc1f065"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e38292da1d253e5f6e823ffecc1f065"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a9e38292da1d253e5f6e823ffecc1f065"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>maxAbsoluteElement</b> (const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; std::complex&lt; T &gt;, P &gt; &amp;m)</td></tr>
<tr class="separator:a9e38292da1d253e5f6e823ffecc1f065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7d5232671c8a497e7465d849bc663a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b7d5232671c8a497e7465d849bc663a"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a4b7d5232671c8a497e7465d849bc663a"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (std::istream &amp;is, <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt; &amp;m)</td></tr>
<tr class="separator:a4b7d5232671c8a497e7465d849bc663a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16699048e47a0d2789a2f965781357dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a16699048e47a0d2789a2f965781357dd"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a16699048e47a0d2789a2f965781357dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1XmlWriter.html">Core::XmlWriter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classCore_1_1XmlWriter.html">Core::XmlWriter</a> &amp;os, const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt; &amp;m)</td></tr>
<tr class="separator:a16699048e47a0d2789a2f965781357dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1065a06ef0d2115d7ec79f6b36f152"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1c1065a06ef0d2115d7ec79f6b36f152"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a1c1065a06ef0d2115d7ec79f6b36f152"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1BinaryOutputStream.html">Core::BinaryOutputStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classCore_1_1BinaryOutputStream.html">Core::BinaryOutputStream</a> &amp;o, const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt; &amp;m)</td></tr>
<tr class="separator:a1c1065a06ef0d2115d7ec79f6b36f152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec553ccfc207fee76a97fcefa9e9fe94"><td class="memTemplParams" colspan="2"><a class="anchor" id="aec553ccfc207fee76a97fcefa9e9fe94"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:aec553ccfc207fee76a97fcefa9e9fe94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1BinaryInputStream.html">Core::BinaryInputStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classCore_1_1BinaryInputStream.html">Core::BinaryInputStream</a> &amp;i, <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T, P &gt; &amp;m)</td></tr>
<tr class="separator:aec553ccfc207fee76a97fcefa9e9fe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67311a170bd82fd20570f5da5c580819"><td class="memTemplParams" colspan="2"><a class="anchor" id="a67311a170bd82fd20570f5da5c580819"></a>
template&lt;typename T1 , typename P1 , typename T2 , typename P2 &gt; </td></tr>
<tr class="memitem:a67311a170bd82fd20570f5da5c580819"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T1, P1 &gt; &amp;m1, const <a class="el" href="classMath_1_1Matrix.html">Matrix</a>&lt; T2, P2 &gt; &amp;m2)</td></tr>
<tr class="separator:a67311a170bd82fd20570f5da5c580819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2912c7297444e58088d00220fb0aabc7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2912c7297444e58088d00220fb0aabc7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#a2912c7297444e58088d00220fb0aabc7">mt_sv2v</a> (int N, T alpha, const T *X, T *Y, void(*fn)(int, T, const T *, T *), int nThreads)</td></tr>
<tr class="memdesc:a2912c7297444e58088d00220fb0aabc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic multithreading for vector operations useful for BLAS 1 operations or similar which are not automatically parallelized  <a href="#a2912c7297444e58088d00220fb0aabc7">More...</a><br /></td></tr>
<tr class="separator:a2912c7297444e58088d00220fb0aabc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4ea4c18d60eb6419a7fc97a90d39eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2e4ea4c18d60eb6419a7fc97a90d39eb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e4ea4c18d60eb6419a7fc97a90d39eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_v2v</b> (int N, T *X, T *Y, void(*fn)(int, T *, T *), int nThreads)</td></tr>
<tr class="separator:a2e4ea4c18d60eb6419a7fc97a90d39eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5d45e5dd68e688ef407b0bf2f44dbf"><td class="memTemplParams" colspan="2"><a class="anchor" id="abc5d45e5dd68e688ef407b0bf2f44dbf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc5d45e5dd68e688ef407b0bf2f44dbf"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mt_svv2s</b> (int N, T alpha, const T *X, const T *Y, T(*fn)(int, T, const T *, const T *), int nThreads)</td></tr>
<tr class="separator:abc5d45e5dd68e688ef407b0bf2f44dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f1c96dc6b05879a945221602695407"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8f1c96dc6b05879a945221602695407"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>randomSeed</b> (long seed)</td></tr>
<tr class="separator:ae8f1c96dc6b05879a945221602695407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd45638ef778f3881c9a4d4ca058a82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bd45638ef778f3881c9a4d4ca058a82"></a>
static std::uniform_int_distribution&#160;</td><td class="memItemRight" valign="bottom"><b>randIntUniform</b> (0, RAND_MAX)</td></tr>
<tr class="separator:a0bd45638ef778f3881c9a4d4ca058a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd84c013a6f2ca0c39642bfbb201e87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafd84c013a6f2ca0c39642bfbb201e87"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>rand</b> ()</td></tr>
<tr class="separator:aafd84c013a6f2ca0c39642bfbb201e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c8f3e035d4fd768b121620f0347d8b"><td class="memTemplParams" colspan="2"><a class="anchor" id="af5c8f3e035d4fd768b121620f0347d8b"></a>
template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:af5c8f3e035d4fd768b121620f0347d8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>random_shuffle</b> (Iter begin, Iter end)</td></tr>
<tr class="separator:af5c8f3e035d4fd768b121620f0347d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda11c5f09d65578b71fecefd9b26acb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMath.html#afda11c5f09d65578b71fecefd9b26acb">createConstant</a> (UnaryAnalyticFunction::Argument c)</td></tr>
<tr class="memdesc:afda11c5f09d65578b71fecefd9b26acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classMath_1_1ConstantFunction.html" title="f(x) = c ">ConstantFunction</a> object.  <a href="#afda11c5f09d65578b71fecefd9b26acb">More...</a><br /></td></tr>
<tr class="separator:afda11c5f09d65578b71fecefd9b26acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928d8d788e7d67590ffd10a5b98cf8e3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a928d8d788e7d67590ffd10a5b98cf8e3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a928d8d788e7d67590ffd10a5b98cf8e3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solveQuadraticEquation</b> (T p, T q, T &amp;xplus, T &amp;xminus)</td></tr>
<tr class="separator:a928d8d788e7d67590ffd10a5b98cf8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4a7868ba587405f51a7f3ff5a8efc7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f4a7868ba587405f51a7f3ff5a8efc7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#a7f4a7868ba587405f51a7f3ff5a8efc7">isnan</a> (T val)</td></tr>
<tr class="memdesc:a7f4a7868ba587405f51a7f3ff5a8efc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">isnan(val) returns true if val is nan.  <a href="#a7f4a7868ba587405f51a7f3ff5a8efc7">More...</a><br /></td></tr>
<tr class="separator:a7f4a7868ba587405f51a7f3ff5a8efc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ef9d964e48f1702801e1855edbdcd4"><td class="memTemplParams" colspan="2"><a class="anchor" id="af4ef9d964e48f1702801e1855edbdcd4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af4ef9d964e48f1702801e1855edbdcd4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan&lt; float &gt;</b> (float val)</td></tr>
<tr class="separator:af4ef9d964e48f1702801e1855edbdcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00f35ce54b4bb3a5354ec3ea6063b5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad00f35ce54b4bb3a5354ec3ea6063b5d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad00f35ce54b4bb3a5354ec3ea6063b5d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan&lt; double &gt;</b> (double val)</td></tr>
<tr class="separator:ad00f35ce54b4bb3a5354ec3ea6063b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e1712cf98abb33efb247e016b09c44"><td class="memTemplParams" colspan="2"><a class="anchor" id="a27e1712cf98abb33efb247e016b09c44"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a27e1712cf98abb33efb247e016b09c44"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan&lt; long double &gt;</b> (long double val)</td></tr>
<tr class="separator:a27e1712cf98abb33efb247e016b09c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f9da66aec069570fcd3cfbd7006eba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a35f9da66aec069570fcd3cfbd7006eba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#a35f9da66aec069570fcd3cfbd7006eba">isinf</a> (T val)</td></tr>
<tr class="memdesc:a35f9da66aec069570fcd3cfbd7006eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as isnan (see above)  <a href="#a35f9da66aec069570fcd3cfbd7006eba">More...</a><br /></td></tr>
<tr class="separator:a35f9da66aec069570fcd3cfbd7006eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327099123faec1172ada1895e74d51bf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a327099123faec1172ada1895e74d51bf"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a327099123faec1172ada1895e74d51bf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isinf&lt; float &gt;</b> (float val)</td></tr>
<tr class="separator:a327099123faec1172ada1895e74d51bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf5d8c3e6bc7d27c14953c82a1f48ad"><td class="memTemplParams" colspan="2"><a class="anchor" id="adbf5d8c3e6bc7d27c14953c82a1f48ad"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adbf5d8c3e6bc7d27c14953c82a1f48ad"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isinf&lt; double &gt;</b> (double val)</td></tr>
<tr class="separator:adbf5d8c3e6bc7d27c14953c82a1f48ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa5fd0ae366d63fa6dcdc236768eac1"><td class="memTemplParams" colspan="2"><a class="anchor" id="afaa5fd0ae366d63fa6dcdc236768eac1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:afaa5fd0ae366d63fa6dcdc236768eac1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isinf&lt; long double &gt;</b> (long double val)</td></tr>
<tr class="separator:afaa5fd0ae366d63fa6dcdc236768eac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7206e28b744b75ee2dca97b16b19839"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7206e28b744b75ee2dca97b16b19839"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#ad7206e28b744b75ee2dca97b16b19839">scoreSum</a> (T a, T b)</td></tr>
<tr class="memdesc:ad7206e28b744b75ee2dca97b16b19839"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the sum of two scores in probability space and convert back to score space (e.g.  <a href="#ad7206e28b744b75ee2dca97b16b19839">More...</a><br /></td></tr>
<tr class="separator:ad7206e28b744b75ee2dca97b16b19839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa865e4911cad6c73061e0113b25ab06d"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa865e4911cad6c73061e0113b25ab06d"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:aa865e4911cad6c73061e0113b25ab06d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; T, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const T weight, const <a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; T, P &gt; &amp;v)</td></tr>
<tr class="separator:aa865e4911cad6c73061e0113b25ab06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e6081f445bda46b287e87a9d0e126f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a05e6081f445bda46b287e87a9d0e126f"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a05e6081f445bda46b287e87a9d0e126f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1BinaryOutputStream.html">Core::BinaryOutputStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classCore_1_1BinaryOutputStream.html">Core::BinaryOutputStream</a> &amp;o, const <a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; T, P &gt; &amp;v)</td></tr>
<tr class="separator:a05e6081f445bda46b287e87a9d0e126f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30907f8139caf030e50d641bc2fd62c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad30907f8139caf030e50d641bc2fd62c"></a>
template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:ad30907f8139caf030e50d641bc2fd62c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1BinaryInputStream.html">Core::BinaryInputStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classCore_1_1BinaryInputStream.html">Core::BinaryInputStream</a> &amp;i, <a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; T, P &gt; &amp;v)</td></tr>
<tr class="separator:ad30907f8139caf030e50d641bc2fd62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358bf7838e84a5e065de5741c4c2c9e2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a358bf7838e84a5e065de5741c4c2c9e2"></a>
template&lt;typename T , class P &gt; </td></tr>
<tr class="memitem:a358bf7838e84a5e065de5741c4c2c9e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; T, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (const <a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; std::complex&lt; T &gt;, P &gt; &amp;v)</td></tr>
<tr class="separator:a358bf7838e84a5e065de5741c4c2c9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceeaeb136d7195b4aa655a3a68a559c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7ceeaeb136d7195b4aa655a3a68a559c"></a>
template&lt;typename T , class P &gt; </td></tr>
<tr class="memitem:a7ceeaeb136d7195b4aa655a3a68a559c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; T, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>imag</b> (const <a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; std::complex&lt; T &gt;, P &gt; &amp;v)</td></tr>
<tr class="separator:a7ceeaeb136d7195b4aa655a3a68a559c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af044d578ffa873011d5534b906047dd2"><td class="memTemplParams" colspan="2"><a class="anchor" id="af044d578ffa873011d5534b906047dd2"></a>
template&lt;typename V &gt; </td></tr>
<tr class="memitem:af044d578ffa873011d5534b906047dd2"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (std::istream &amp;is, <a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; V &gt; &amp;v)</td></tr>
<tr class="separator:af044d578ffa873011d5534b906047dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffb440a9b88d7282e8451325efa590e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ffb440a9b88d7282e8451325efa590e"></a>
template&lt;typename T , class P &gt; </td></tr>
<tr class="memitem:a4ffb440a9b88d7282e8451325efa590e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1XmlWriter.html">Core::XmlWriter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classCore_1_1XmlWriter.html">Core::XmlWriter</a> &amp;os, const <a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; T, P &gt; &amp;v)</td></tr>
<tr class="separator:a4ffb440a9b88d7282e8451325efa590e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2aea8903dd76f79497f60ceb8869ea"><td class="memTemplParams" colspan="2"><a class="anchor" id="aff2aea8903dd76f79497f60ceb8869ea"></a>
template&lt;typename T1 , typename P1 , typename T2 , typename P2 &gt; </td></tr>
<tr class="memitem:aff2aea8903dd76f79497f60ceb8869ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; T1, P1 &gt; &amp;v1, const <a class="el" href="classMath_1_1Vector.html">Vector</a>&lt; T2, P2 &gt; &amp;v2)</td></tr>
<tr class="separator:aff2aea8903dd76f79497f60ceb8869ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae5bb88ef28669b9a79c611b1e772939d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5bb88ef28669b9a79c611b1e772939d"></a>
std::mt19937&#160;</td><td class="memItemRight" valign="bottom"><b>randomEngine</b></td></tr>
<tr class="separator:ae5bb88ef28669b9a79c611b1e772939d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9c92630025cf59fab04ee84165b1bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c9c92630025cf59fab04ee84165b1bc"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>MINLOGEPS</b> = 11.513f</td></tr>
<tr class="separator:a8c9c92630025cf59fab04ee84165b1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright 2020 RWTH Aachen University. </p>
<p>All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.to use <a class="el" href="Assertions_8hh.html#ae925d7587e34145cd52f674b2012539a" title="Check precondition. ">require()</a> for convert functions to use std::cout </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8229c25908db3f6986fc56b32012fd99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Math::asum </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asum (one-norm) </p>
<dl class="section return"><dt>Returns</dt><dd>sum_i abs(x_i)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>input vector dimension </td></tr>
    <tr><td class="paramname">X</td><td>input vector </td></tr>
    <tr><td class="paramname">incX</td><td>increment of X </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="Blas_8hh_source.html#l00474">mt_scal()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a9a58436b6a438b08d2fa61d1cb8391"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Math::axpy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>axpy (weighted vector sum) </p>
<p>y += alpha * x</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>input vector dimension </td></tr>
    <tr><td class="paramname">alpha</td><td>scaling factor </td></tr>
    <tr><td class="paramname">X</td><td>input vector </td></tr>
    <tr><td class="paramname">incX</td><td>increment of X </td></tr>
    <tr><td class="paramname">Y</td><td>result vector </td></tr>
    <tr><td class="paramname">incY</td><td>increment of Y </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Blas_8hh_source.html#l00184">184</a> of file <a class="el" href="Blas_8hh_source.html">Blas.hh</a>.</p>

<p>References <a class="el" href="Blas_8hh_source.html#l00228">dot()</a>.</p>

<p>Referenced by <a class="el" href="Blas_8hh_source.html#l00474">mt_scal()</a>.</p>

</div>
</div>
<a class="anchor" id="a0ca9005a7de9e2e67fc1f4aa778467d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Math::copy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy </p>
<p>y = x</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>result vector dimension </td></tr>
    <tr><td class="paramname">X</td><td>input vector </td></tr>
    <tr><td class="paramname">incX</td><td>increment of X </td></tr>
    <tr><td class="paramname">Y</td><td>result vector </td></tr>
    <tr><td class="paramname">incY</td><td>increment of Y </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Blas_8hh_source.html#l00274">274</a> of file <a class="el" href="Blas_8hh_source.html">Blas.hh</a>.</p>

<p>References <a class="el" href="Blas_8hh_source.html#l00474">mt_scal()</a>, and <a class="el" href="namespaceMath.html#a994c78e8c5671930de56f949b0dca8e2">scal()</a>.</p>

<p>Referenced by <a class="el" href="FastMatrix_8hh_source.html#l00529">Math::FastMatrix&lt; T &gt;::allocate()</a>, <a class="el" href="Lapack_2EigenvalueProblem_8cc_source.html#l00502">Math::Lapack::GenEigenProblemWithSchurDecomposition::copyEigenvectors()</a>, <a class="el" href="Blas_8hh_source.html#l00228">dot()</a>, <a class="el" href="Lapack_2EigenvalueProblem_8cc_source.html#l00168">Math::Lapack::SymmetricEigenvalueProblem::dsyevr()</a>, <a class="el" href="Lapack_2EigenvalueProblem_8cc_source.html#l00635">Math::Lapack::GenSymmetricDefiniteEigenProblem::dsygvx()</a>, <a class="el" href="EmissionLatticeRescorer_8cc_source.html#l00131">Nn::EmissionLatticeRescorer::finalize()</a>, <a class="el" href="Nn_2Statistics_8cc_source.html#l00193">Nn::Statistics&lt; T &gt;::gradientL1Norm()</a>, <a class="el" href="Lapack_2Matrix_8hh_source.html#l00118">Math::Lapack::Matrix&lt; f64 &gt;::resize()</a>, and <a class="el" href="Lapack_2EigenvalueProblem_8cc_source.html#l00283">Math::Lapack::GenEigenProblemWithSchurDecomposition::solveSymmetric()</a>.</p>

</div>
</div>
<a class="anchor" id="afda11c5f09d65578b71fecefd9b26acb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a> Math::createConstant </td>
          <td>(</td>
          <td class="paramtype">UnaryAnalyticFunction::Argument&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classMath_1_1ConstantFunction.html" title="f(x) = c ">ConstantFunction</a> object. </p>

<p>Definition at line <a class="el" href="SimpleAnalyticFunctions_8hh_source.html#l00043">43</a> of file <a class="el" href="SimpleAnalyticFunctions_8hh_source.html">SimpleAnalyticFunctions.hh</a>.</p>

<p>Referenced by <a class="el" href="AnalyticFunctionFactory_8hh_source.html#l00231">Math::AnalyticFunctionFactory::createConstant()</a>, and <a class="el" href="AnalyticFunctionFactory_8cc_source.html#l00219">Math::AnalyticFunctionFactory::parseConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="ad732fbcf622b46ad384ce958f1d74dee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Math::dot </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nThreads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dot (dot product) </p>
<dl class="section return"><dt>Returns</dt><dd>x^T y</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>input vector dimension </td></tr>
    <tr><td class="paramname">X</td><td>first input vector </td></tr>
    <tr><td class="paramname">incX</td><td>increment of X </td></tr>
    <tr><td class="paramname">Y</td><td>second input vector </td></tr>
    <tr><td class="paramname">incY</td><td>increment of Y </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Blas_8hh_source.html#l00228">228</a> of file <a class="el" href="Blas_8hh_source.html">Blas.hh</a>.</p>

<p>References <a class="el" href="Blas_8hh_source.html#l00274">copy()</a>.</p>

<p>Referenced by <a class="el" href="FastMatrix_8hh_source.html#l00529">Math::FastMatrix&lt; T &gt;::allocate()</a>, <a class="el" href="Blas_8hh_source.html#l00184">axpy()</a>, <a class="el" href="FastVector_8hh_source.html#l00329">Math::FastVector&lt; T &gt;::copy()</a>, and <a class="el" href="Blas_8hh_source.html#l00474">mt_scal()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ef8b4cc949f2fbf51b443ebd80e6528"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Math::iamax </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>iamax </p>
<dl class="section return"><dt>Returns</dt><dd>the first index of the maximum absolute value of vector x</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>input vector dimension </td></tr>
    <tr><td class="paramname">X</td><td>input vector </td></tr>
    <tr><td class="paramname">incX</td><td>increment of X </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="FastMatrix_8hh_source.html#l00529">Math::FastMatrix&lt; T &gt;::allocate()</a>.</p>

</div>
</div>
<a class="anchor" id="a35f9da66aec069570fcd3cfbd7006eba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Math::isinf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>same as isnan (see above) </p>

<p>Referenced by <a class="el" href="TFRecurrentLanguageModel_8cc_source.html#l00494">Lm::TFRecurrentLanguageModel::scoreCached()</a>.</p>

</div>
</div>
<a class="anchor" id="a7f4a7868ba587405f51a7f3ff5a8efc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Math::isnan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>isnan(val) returns true if val is nan. </p>
<p>We cannot rely on std::isnan or x!=x, because GCC may wrongly optimize it away when compiling with -ffast-math (default in RASR), even with volatile, because -ffast-math implies -ffinite-math-only. Earlier, we checked the binary representation here, but that is of course architecture dependent. Most platforms have __isnan, which is not handled by the compiler, but implemented in libm (C stdlib). Some references: <a href="http://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/baselib&mdash;isnan.html">http://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/baselib&amp;mdash;isnan.html</a> <a href="http://stackoverflow.com/questions/22931147/stdisinf-does-not-work-with-ffast-math-how-to-check-for-infinity">http://stackoverflow.com/questions/22931147/stdisinf-does-not-work-with-ffast-math-how-to-check-for-infinity</a> </p>

<p>Referenced by <a class="el" href="FastMatrix_8hh_source.html#l00529">Math::FastMatrix&lt; T &gt;::allocate()</a>, <a class="el" href="FastVector_8hh_source.html#l00329">Math::FastVector&lt; T &gt;::copy()</a>, <a class="el" href="CtcCriterion_8cc_source.html#l01105">Nn::CtcCriterion&lt; FloatT &gt;::inputSpeechSegment()</a>, <a class="el" href="LatticeExtractor_8cc_source.html#l00232">Speech::LmLatticeRescorerAutomaton::score()</a>, and <a class="el" href="Math_2Utilities_8hh_source.html#l00177">scoreSum()</a>.</p>

</div>
</div>
<a class="anchor" id="a12246d87e8e0aac82133fa5164103bca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Math::mt_scal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(simplified) multithreaded versions that are not automatically parallelized by corresponding math library </p>

<p>Definition at line <a class="el" href="Blas_8hh_source.html#l00474">474</a> of file <a class="el" href="Blas_8hh_source.html">Blas.hh</a>.</p>

<p>References <a class="el" href="namespaceMath.html#a8229c25908db3f6986fc56b32012fd99">asum()</a>, <a class="el" href="Blas_8hh_source.html#l00184">axpy()</a>, <a class="el" href="Blas_8hh_source.html#l00228">dot()</a>, <a class="el" href="MultithreadingHelper_8hh_source.html#l00038">mt_sv2v()</a>, <a class="el" href="namespaceMath.html#adb16729d0a6885632ca02913fe6b7f44">nrm2()</a>, and <a class="el" href="namespaceMath.html#a994c78e8c5671930de56f949b0dca8e2">scal()</a>.</p>

<p>Referenced by <a class="el" href="FastMatrix_8hh_source.html#l00529">Math::FastMatrix&lt; T &gt;::allocate()</a>, and <a class="el" href="Blas_8hh_source.html#l00274">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a2912c7297444e58088d00220fb0aabc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Math::mt_sv2v </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int, T, const T *, T *)&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generic multithreading for vector operations useful for BLAS 1 operations or similar which are not automatically parallelized </p>
<p>(application would be much easier in C++x11 with std::bind) </p>

<p>Definition at line <a class="el" href="MultithreadingHelper_8hh_source.html#l00038">38</a> of file <a class="el" href="MultithreadingHelper_8hh_source.html">MultithreadingHelper.hh</a>.</p>

<p>Referenced by <a class="el" href="Blas_8hh_source.html#l00474">mt_scal()</a>.</p>

</div>
</div>
<a class="anchor" id="a181795f43bb7c66a8254cfcae4d922d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a> Math::nest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a>&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classMath_1_1AnalyticNesting.html" title="f(g(x)) ">AnalyticNesting</a> object. </p>

<p>Definition at line <a class="el" href="AnalyticFunction_8hh_source.html#l00128">128</a> of file <a class="el" href="AnalyticFunction_8hh_source.html">AnalyticFunction.hh</a>.</p>

<p>Referenced by <a class="el" href="AnalyticFunctionFactory_8cc_source.html#l00369">Math::AnalyticFunctionFactory::createBarkWarpingFunction()</a>, <a class="el" href="AnalyticFunctionFactory_8hh_source.html#l00247">Math::AnalyticFunctionFactory::createLinear()</a>, <a class="el" href="AnalyticFunctionFactory_8hh_source.html#l00256">Math::AnalyticFunctionFactory::createMaximumNormalization()</a>, <a class="el" href="AnalyticFunctionFactory_8cc_source.html#l00338">Math::AnalyticFunctionFactory::createMelWarpingFunction()</a>, and <a class="el" href="AnalyticFunctionFactory_8cc_source.html#l00161">Math::AnalyticFunctionFactory::parseNesting()</a>.</p>

</div>
</div>
<a class="anchor" id="adb16729d0a6885632ca02913fe6b7f44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Math::nrm2 </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>nrm2 ( Euclidean norm) </p>
<dl class="section return"><dt>Returns</dt><dd>(X^T X)^0.5</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>input vector dimension </td></tr>
    <tr><td class="paramname">X</td><td>input vector </td></tr>
    <tr><td class="paramname">incX</td><td>increment of X </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="Blas_8hh_source.html#l00474">mt_scal()</a>.</p>

</div>
</div>
<a class="anchor" id="ac01e9b90be52ed22f0f4a9e10cf0e06f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a> Math::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a>&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classMath_1_1AnalyticMultiplication.html" title="f(x)*g(x) ">AnalyticMultiplication</a> object. </p>

<p>Definition at line <a class="el" href="AnalyticFunction_8hh_source.html#l00105">105</a> of file <a class="el" href="AnalyticFunction_8hh_source.html">AnalyticFunction.hh</a>.</p>

<p>Referenced by <a class="el" href="Math_2Vector_8hh_source.html#l00095">Math::Vector&lt; Math::Vector&lt; T, P &gt;, P &gt;::operator*()</a>, and <a class="el" href="Math_2Vector_8hh_source.html#l00246">Math::Vector&lt; Math::Vector&lt; T, P &gt;, P &gt;::takeSquareRoot()</a>.</p>

</div>
</div>
<a class="anchor" id="af1892bf101eafdb2dbd572be51b28375"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a> Math::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCore_1_1Ref.html">UnaryAnalyticFunctionRef</a>&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classMath_1_1AnalyticSummation.html" title="f(x)+g(x) ">AnalyticSummation</a> object. </p>

<p>Definition at line <a class="el" href="AnalyticFunction_8hh_source.html#l00083">83</a> of file <a class="el" href="AnalyticFunction_8hh_source.html">AnalyticFunction.hh</a>.</p>

<p>Referenced by <a class="el" href="Math_2Vector_8hh_source.html#l00095">Math::Vector&lt; Math::Vector&lt; T, P &gt;, P &gt;::operator*()</a>.</p>

</div>
</div>
<a class="anchor" id="a994c78e8c5671930de56f949b0dca8e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Math::scal </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scal ( vector scaling) </p>
<p>X = alpha * X</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>input vector dimension </td></tr>
    <tr><td class="paramname">X</td><td>input vector </td></tr>
    <tr><td class="paramname">alpha</td><td>scaling factor </td></tr>
    <tr><td class="paramname">incX</td><td>increment of X </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="FastMatrix_8hh_source.html#l00529">Math::FastMatrix&lt; T &gt;::allocate()</a>, <a class="el" href="Blas_8hh_source.html#l00274">copy()</a>, and <a class="el" href="Blas_8hh_source.html#l00474">mt_scal()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7206e28b744b75ee2dca97b16b19839"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Math::scoreSum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the sum of two scores in probability space and convert back to score space (e.g. </p>
<p>-log(exp(-a) + exp(-b)) ) in a numerically stable way </p>

<p>Definition at line <a class="el" href="Math_2Utilities_8hh_source.html#l00177">177</a> of file <a class="el" href="Math_2Utilities_8hh_source.html">Math/Utilities.hh</a>.</p>

<p>References <a class="el" href="namespaceMath.html#a7f4a7868ba587405f51a7f3ff5a8efc7">isnan()</a>.</p>

<p>Referenced by <a class="el" href="CombineLm_8cc_source.html#l00165">Lm::CombineLanguageModel::score()</a>, and <a class="el" href="CombineLm_8cc_source.html#l00210">Lm::CombineLanguageModel::sentenceEndScore()</a>.</p>

</div>
</div>
<a class="anchor" id="aca1184da98ac274b10bd5ab8e4dd727f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Math::swap </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap () </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>input vector dimension </td></tr>
    <tr><td class="paramname">X</td><td>input vector </td></tr>
    <tr><td class="paramname">incX</td><td>increment of X </td></tr>
    <tr><td class="paramname">Y</td><td>input vector </td></tr>
    <tr><td class="paramname">incY</td><td>increment of X </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73085744d407619c9839cee8ca7a0fde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class Operation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Math::transformAlternatingComplex </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tranforms alternating complex vector into an arbitrary type (Alternating complex vectors are stored in a standard container by storing the real and the imaginary parts alternating.) </p>
<p>Alternating complex numbers are first transformed to a complex&lt;InputType&gt; object. Operation is transforms the complex&lt;InputType&gt; object: operation must support the function: OutputType operator()(const complex&lt;InputType&gt; &amp;). Operation is a unary function (derived from std::unary_function): Argument must have a constructor with two parameters Result is of arbitrary type </p>

<p>Definition at line <a class="el" href="Complex_8hh_source.html#l00077">77</a> of file <a class="el" href="Complex_8hh_source.html">Complex.hh</a>.</p>

<p>Referenced by <a class="el" href="ComplexVectorFunction_8hh_source.html#l00036">Signal::alternatingComplexVectorAmplitude&lt; T &gt;::operator()()</a>, <a class="el" href="ComplexVectorFunction_8hh_source.html#l00056">Signal::alternatingComplexVectorPhase&lt; T &gt;::operator()()</a>, <a class="el" href="ComplexVectorFunction_8hh_source.html#l00076">Signal::alternatingComplexVectorRealPart&lt; T &gt;::operator()()</a>, and <a class="el" href="ComplexVectorFunction_8hh_source.html#l00096">Signal::alternatingComplexVectorImaginaryPart&lt; T &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d8c1a8a5893b683210e08b795f2814c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class Operation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Math::transformAlternatingComplexToAlternatingComplex </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tranforms an alternating complex vector into an alternating complex vector (Alternating complex vectors are stored in a standard container by storing the real and the imaginary parts alternating.) </p>
<p>Operation is a binary function derived from std::binary_function: Arguments must have a constructor with two parameters For the result type the functions real and imag must exist. </p>

<p>Definition at line <a class="el" href="Complex_8hh_source.html#l00116">116</a> of file <a class="el" href="Complex_8hh_source.html">Complex.hh</a>.</p>

<p>Referenced by <a class="el" href="Convolution_8cc_source.html#l00057">Signal::Convolution::apply()</a>, and <a class="el" href="CrossCorrelation_8cc_source.html#l00026">Signal::CrossCorrelation::crossCorrelation()</a>.</p>

</div>
</div>
<a class="anchor" id="a95fc1fa727e1b4765e598ae1ba88463a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator , class Operation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Math::transformToAlternatingComplex </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tranforms a vector of arbitrary type into an alternating complex vector (Alternating complex vectors are stored in a standard container by storing the real and the imaginary parts alternating.) Operation is a unary function (derived from std::unary_function): Argument is of arbitrary type For the result type the functions real and imag must exist. </p>

<p>Definition at line <a class="el" href="Complex_8hh_source.html#l00097">97</a> of file <a class="el" href="Complex_8hh_source.html">Complex.hh</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
