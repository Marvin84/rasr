<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Sprint: Search Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sprint
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Search Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Copyright 2020 RWTH Aachen University.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1AccessiblePriorityQueue.html">AccessiblePriorityQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1AdvancedTreeSearchManager.html">AdvancedTreeSearchManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1Aligner.html">Aligner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forced state-level alignment of network with observation seqeuence.  <a href="classSearch_1_1Aligner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1AlternativeHistory.html">AlternativeHistory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1AlternativeHistoryCompare.html">AlternativeHistoryCompare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1ApproxLinearIntHash.html">ApproxLinearIntHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For efficiency-reasons, the default-value is hardcoded to U16_MAX This is a tiny bit faster than the standard approximative mini-hash, but also a bit less precise.  <a href="classSearch_1_1ApproxLinearIntHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1ApproxLinearMiniHash.html">ApproxLinearMiniHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For efficiency-reasons, the default-value is hardcoded to F32_MAX.  <a href="classSearch_1_1ApproxLinearMiniHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1ConvertTree.html">ConvertTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1CountSizeTreeWalkerBackend.html">CountSizeTreeWalkerBackend</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1DynamicBeamPruningStrategy.html">DynamicBeamPruningStrategy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1EarlyWordEndHypothesis.html">EarlyWordEndHypothesis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1Histogram.html">Histogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">histogram of scores for histogram pruning  <a href="classSearch_1_1Histogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1HistoryStateHash.html">HistoryStateHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1HMMState.html">HMMState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standard network state, representing a state and its successor-links.  <a href="structSearch_1_1HMMState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1HMMStateNetwork.html">HMMStateNetwork</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1InitialTraceChanger.html">InitialTraceChanger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1Instance.html">Instance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1InstanceKey.html">InstanceKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object that contains the information that <em>conditions</em> a network, and thereby makes the network unique.  <a href="structSearch_1_1InstanceKey.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1LanguageModelLookahead.html">LanguageModelLookahead</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Language model look-ahead.  <a href="classSearch_1_1LanguageModelLookahead.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1LatticeAdaptor.html">LatticeAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic interface for various types of lattices generated by the decoders.  <a href="classSearch_1_1LatticeAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1LatticeHandler.html">LatticeHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input and output of lattices in various formats.  <a href="classSearch_1_1LatticeHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1LinearMiniHash.html">LinearMiniHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialized hash-map, which is optimized for the following case:  <a href="classSearch_1_1LinearMiniHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1LinearPrediction.html">LinearPrediction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1LinearSearch.html">LinearSearch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1LinearSearchHistoryData.html">LinearSearchHistoryData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1LmCache.html">LmCache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1LmCacheEqual.html">LmCacheEqual</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1LmCacheHash.html">LmCacheHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1LmCacheItem.html">LmCacheItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1LmCacheKey.html">LmCacheKey</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1MaximumDelayBeamPruningStrategy.html">MaximumDelayBeamPruningStrategy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1MinimumBayesRiskAStarSearch.html">MinimumBayesRiskAStarSearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes minimum Bayes risk hypothesis as proposed by Byrne and Goel.  <a href="classSearch_1_1MinimumBayesRiskAStarSearch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1MinimumBayesRiskMapSearch.html">MinimumBayesRiskMapSearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standard approach to speech recognition is based on a 0-1-loss Bayes decision rule.  <a href="classSearch_1_1MinimumBayesRiskMapSearch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1MinimumBayesRiskNBestListNaiveSearch.html">MinimumBayesRiskNBestListNaiveSearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the naive approach for minimum Bayes risk using an nbestlist for both the evaluation space as well as for the summation space.  <a href="classSearch_1_1MinimumBayesRiskNBestListNaiveSearch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1MinimumBayesRiskNBestListSearch.html">MinimumBayesRiskNBestListSearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for search process of minimum Bayes risk using nbestlists as evaluation space, i.e.  <a href="classSearch_1_1MinimumBayesRiskNBestListSearch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1MinimumBayesRiskSearch.html">MinimumBayesRiskSearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for performing a search for the best string in an <a class="el" href="namespaceFsa.html" title="Copyright 2020 RWTH Aachen University. ">Fsa</a> w.r.t.  <a href="classSearch_1_1MinimumBayesRiskSearch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1MinimumCombine.html">MinimumCombine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1Module__.html">Module_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1PartialNbestlist.html">PartialNbestlist</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1PathRecombination.html">PathRecombination</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1PathRecombinationApproximation.html">PathRecombinationApproximation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1PathTrace.html">PathTrace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1PersistentStateTree.html">PersistentStateTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1PrefixFilter.html">PrefixFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1RootTraceSearcher.html">RootTraceSearcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1ScoreDependentStatistic.html">ScoreDependentStatistic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1ScoreDependentVectorStatistic.html">ScoreDependentVectorStatistic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1SearchAlgorithm.html">SearchAlgorithm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1SearchSpace.html">SearchSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1SearchSpaceStatistics.html">SearchSpaceStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1SentenceEndAutomaton.html">SentenceEndAutomaton</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1SparseVector.html">SparseVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1StandardApproxValueHash.html">StandardApproxValueHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1StandardValueHash.html">StandardValueHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1StateHypothesis.html">StateHypothesis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state hypothesis consists of the probability of a network state within one specific network copy, together with its back-pointer (the trace).  <a href="structSearch_1_1StateHypothesis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1StateTree.html">StateTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acoustic prefix tree.  <a href="classSearch_1_1StateTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1StateTreeIo.html">StateTreeIo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State tree input / output functions.  <a href="classSearch_1_1StateTreeIo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1StateTreeReader.html">StateTreeReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a state tree from a file.  <a href="classSearch_1_1StateTreeReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1StateTreeWriter.html">StateTreeWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a state tree to a binary file.  <a href="classSearch_1_1StateTreeWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1StaticSearchAutomaton.html">StaticSearchAutomaton</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1StringHypothesis.html">StringHypothesis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1SubTreeWalker.html">SubTreeWalker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit this, and then in the given base, implement nodeVisited(TreeNodeIndex, token), visitExit(uint exit, token), and visitNode(TreeNodeIndex, token)  <a href="classSearch_1_1SubTreeWalker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1Trace.html">Trace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1TraceItem.html">TraceItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1TraceManager.html">TraceManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1Tree.html">Tree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1WordConditionedTreeSearch.html">WordConditionedTreeSearch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSearch_1_1WordEndHypothesis.html">WordEndHypothesis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1WordPronunciationState.html">WordPronunciationState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearch_1_1WordSequenceAligner.html">WordSequenceAligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afdf25e77eb66eeda21446b0a5b44bfe0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdf25e77eb66eeda21446b0a5b44bfe0"></a>
typedef s32&#160;</td><td class="memItemRight" valign="bottom"><b>StateHypothesisIndex</b></td></tr>
<tr class="separator:afdf25e77eb66eeda21446b0a5b44bfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d42171bb8c0738eff52005d3d484829"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d42171bb8c0738eff52005d3d484829"></a>
typedef std::vector&lt; <a class="el" href="structSearch_1_1WordEndHypothesis.html">WordEndHypothesis</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>WordEndHypothesisList</b></td></tr>
<tr class="separator:a2d42171bb8c0738eff52005d3d484829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec10ee76eeed3533b302093e2c29f75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaec10ee76eeed3533b302093e2c29f75"></a>
typedef std::vector&lt; <a class="el" href="structSearch_1_1EarlyWordEndHypothesis.html">EarlyWordEndHypothesis</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EarlyWordEndHypothesisList</b></td></tr>
<tr class="separator:aaec10ee76eeed3533b302093e2c29f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7351da4cb17e062bec8e1f3db1207bfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7351da4cb17e062bec8e1f3db1207bfc"></a>
typedef std::pair&lt; <a class="el" href="classLm_1_1History.html">Lm::History</a>, <a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ReducedContextRecombinationKey</b></td></tr>
<tr class="separator:a7351da4cb17e062bec8e1f3db1207bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8a2ece895775131c8a5287ab55e1e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e8a2ece895775131c8a5287ab55e1e6"></a>
typedef std::unordered_map&lt; ReducedContextRecombinationKey, WordEndHypothesisList::iterator, <a class="el" href="structSearch_1_1HistoryStateHash.html">HistoryStateHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ReducedContextRecombinationMap</b></td></tr>
<tr class="separator:a1e8a2ece895775131c8a5287ab55e1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1497fc74a74ef563f5b99853b127d392"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1497fc74a74ef563f5b99853b127d392"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AlternativeHistoryQueue</b> = <a class="el" href="classSearch_1_1AccessiblePriorityQueue.html">AccessiblePriorityQueue</a>&lt; <a class="el" href="structSearch_1_1AlternativeHistory.html">AlternativeHistory</a>, std::vector&lt; <a class="el" href="structSearch_1_1AlternativeHistory.html">AlternativeHistory</a> &gt;, <a class="el" href="structSearch_1_1AlternativeHistoryCompare.html">AlternativeHistoryCompare</a> &gt;</td></tr>
<tr class="separator:a1497fc74a74ef563f5b99853b127d392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4936e5c9edc3dcb9dbc8386bfee3ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd4936e5c9edc3dcb9dbc8386bfee3ff"></a>
typedef u32&#160;</td><td class="memItemRight" valign="bottom"><b>TraceId</b></td></tr>
<tr class="separator:abd4936e5c9edc3dcb9dbc8386bfee3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0cff107c7f9e71d4f2d77efb631ffa"><td class="memItemLeft" align="right" valign="top">typedef u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#a0f0cff107c7f9e71d4f2d77efb631ffa">SuccessorBatchId</a></td></tr>
<tr class="memdesc:a0f0cff107c7f9e71d4f2d77efb631ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This index represents an arbitrary list of successor-states and labels.  <a href="#a0f0cff107c7f9e71d4f2d77efb631ffa">More...</a><br /></td></tr>
<tr class="separator:a0f0cff107c7f9e71d4f2d77efb631ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4630d7f0a64cb3317190d22f0bc2e4"><td class="memItemLeft" align="right" valign="top">typedef u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#a9b4630d7f0a64cb3317190d22f0bc2e4">TreeIndex</a></td></tr>
<tr class="memdesc:a9b4630d7f0a64cb3317190d22f0bc2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global index of a tree or subtree.  <a href="#a9b4630d7f0a64cb3317190d22f0bc2e4">More...</a><br /></td></tr>
<tr class="separator:a9b4630d7f0a64cb3317190d22f0bc2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b661f14c566570312f3dd56d120dee"><td class="memItemLeft" align="right" valign="top">typedef u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a></td></tr>
<tr class="memdesc:ad5b661f14c566570312f3dd56d120dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of a state or label (see IS_LABEL, ID_FROM_LABEL, and LABEL_FROM_ID)  <a href="#ad5b661f14c566570312f3dd56d120dee">More...</a><br /></td></tr>
<tr class="separator:ad5b661f14c566570312f3dd56d120dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db22ea3065285134fef597f8933b87f"><td class="memItemLeft" align="right" valign="top">typedef u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#a6db22ea3065285134fef597f8933b87f">SubTreeListId</a></td></tr>
<tr class="memdesc:a6db22ea3065285134fef597f8933b87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index representing the batch of all nodes that are contained by one tree.  <a href="#a6db22ea3065285134fef597f8933b87f">More...</a><br /></td></tr>
<tr class="separator:a6db22ea3065285134fef597f8933b87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9f5864fafb9a6afa09236d6a1a5733"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec9f5864fafb9a6afa09236d6a1a5733"></a>
typedef <a class="el" href="classSearch_1_1SubTreeWalker.html">Search::SubTreeWalker</a>&lt; int, <a class="el" href="structSearch_1_1CountSizeTreeWalkerBackend.html">CountSizeTreeWalkerBackend</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CountSizeTreeWalker</b></td></tr>
<tr class="separator:aec9f5864fafb9a6afa09236d6a1a5733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cc3442dad9eb91285cdd83e0da8484"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classCore_1_1Ref.html">Core::Ref</a>&lt; <a class="el" href="classSearch_1_1WordPronunciationState.html">WordPronunciationState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#a08cc3442dad9eb91285cdd83e0da8484">WordPronunciationStatePointer</a></td></tr>
<tr class="memdesc:a08cc3442dad9eb91285cdd83e0da8484"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pronunciation including its current state.  <a href="#a08cc3442dad9eb91285cdd83e0da8484">More...</a><br /></td></tr>
<tr class="separator:a08cc3442dad9eb91285cdd83e0da8484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e25b0b0817dce0c15642f93a85e3a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59e25b0b0817dce0c15642f93a85e3a1"></a>
typedef <a class="el" href="classCore_1_1Ref.html">MinimumBayesRiskAStarSearch::ConstSearchNodeRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ConstSearchNodeRef</b></td></tr>
<tr class="separator:a59e25b0b0817dce0c15642f93a85e3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e20291082e3d645a923e615902ebb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64e20291082e3d645a923e615902ebb9"></a>
typedef <a class="el" href="classCore_1_1Ref.html">MinimumBayesRiskAStarSearch::SearchNodeRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SearchNodeRef</b></td></tr>
<tr class="separator:a64e20291082e3d645a923e615902ebb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e79416aa9acffb4a299d1e1d1e9d8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7e79416aa9acffb4a299d1e1d1e9d8c"></a>
typedef std::vector&lt; <a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Sentence</b></td></tr>
<tr class="separator:ac7e79416aa9acffb4a299d1e1d1e9d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1ce1bcc243ad8c17d4fa98e9e3459a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef1ce1bcc243ad8c17d4fa98e9e3459a"></a>
typedef std::vector&lt; <a class="el" href="structSearch_1_1StringHypothesis.html">StringHypothesis</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HypothesisVector</b></td></tr>
<tr class="separator:aef1ce1bcc243ad8c17d4fa98e9e3459a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42889b68a45787b5046dab385fb7c737"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42889b68a45787b5046dab385fb7c737"></a>
typedef <a class="el" href="classCore_1_1SingletonHolder.html">Core::SingletonHolder</a>&lt; <a class="el" href="classSearch_1_1Module__.html">Module_</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Module</b></td></tr>
<tr class="separator:a42889b68a45787b5046dab385fb7c737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b2294cdb446be6dab6a17e6216edfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7b2294cdb446be6dab6a17e6216edfd"></a>
typedef f32&#160;</td><td class="memItemRight" valign="bottom"><b>Score</b></td></tr>
<tr class="separator:ab7b2294cdb446be6dab6a17e6216edfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716be0f51c86ad9d9f1268c763100806"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a716be0f51c86ad9d9f1268c763100806"></a>
typedef u32&#160;</td><td class="memItemRight" valign="bottom"><b>TimeframeIndex</b></td></tr>
<tr class="separator:a716be0f51c86ad9d9f1268c763100806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26e7219340d33ef61bbcca157f65ebc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab26e7219340d33ef61bbcca157f65ebc"></a>
typedef u32&#160;</td><td class="memItemRight" valign="bottom"><b>Index</b></td></tr>
<tr class="separator:ab26e7219340d33ef61bbcca157f65ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035f02151362ef18aaa16effa5ac7647"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a035f02151362ef18aaa16effa5ac7647"></a>
typedef std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexVector</b></td></tr>
<tr class="separator:a035f02151362ef18aaa16effa5ac7647"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa488b5ce753f10794f198d4bbe1a3b5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa488b5ce753f10794f198d4bbe1a3b5f"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>MaxFadeInPruningDistance</b> = 255
 }</td></tr>
<tr class="separator:aa488b5ce753f10794f198d4bbe1a3b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02a40bad1cbff39ab5efd9bcfd80e9f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespaceSearch.html#aa02a40bad1cbff39ab5efd9bcfd80e9fad646ab382f6afce3c2703c5c0663984c">SingleSuccessorBatchMask</a> = 1 &lt;&lt; 30, 
<b>LabelMask</b> = 1 &lt;&lt; 27
 }</td></tr>
<tr class="separator:aa02a40bad1cbff39ab5efd9bcfd80e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83de5ed303953b20bacb87110d37fe2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83de5ed303953b20bacb87110d37fe2a"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>InvalidBatchId</b> = 0
 }</td></tr>
<tr class="separator:a83de5ed303953b20bacb87110d37fe2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97f9089265611ae8f20897322b6d487"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae97f9089265611ae8f20897322b6d487"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SearchType</b> { <b>WordConditionedTreeSearchType</b>, 
<b>AdvancedTreeSearch</b>, 
<b>LinearSearchType</b>, 
<b>ExpandingFsaSearchType</b>
 }</td></tr>
<tr class="separator:ae97f9089265611ae8f20897322b6d487"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa08c703f8af8f9490f48d5cabb35d567"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa08c703f8af8f9490f48d5cabb35d567"></a>
std::unique_ptr&lt; <a class="el" href="classSearch_1_1DynamicBeamPruningStrategy.html">DynamicBeamPruningStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>createDynamicBeamPruningStrategy</b> (<a class="el" href="classCore_1_1Configuration.html">Core::Configuration</a> const &amp;config, <a class="el" href="classCore_1_1Ref.html">SearchAlgorithm::PruningRef</a> initialPruning)</td></tr>
<tr class="separator:aa08c703f8af8f9490f48d5cabb35d567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6491020804bee451aad9651f632892"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb6491020804bee451aad9651f632892"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abb6491020804bee451aad9651f632892"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1MappedArchiveReader.html">MappedArchiveReader</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classCore_1_1MappedArchiveReader.html">MappedArchiveReader</a> &amp;reader, std::set&lt; T &gt; &amp;target)</td></tr>
<tr class="separator:abb6491020804bee451aad9651f632892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892b48e9ce5fc8146b64a658cbb56223"><td class="memTemplParams" colspan="2"><a class="anchor" id="a892b48e9ce5fc8146b64a658cbb56223"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a892b48e9ce5fc8146b64a658cbb56223"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1MappedArchiveWriter.html">MappedArchiveWriter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classCore_1_1MappedArchiveWriter.html">MappedArchiveWriter</a> &amp;writer, const std::set&lt; T &gt; &amp;set)</td></tr>
<tr class="separator:a892b48e9ce5fc8146b64a658cbb56223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ed09aa695686faaf83c5b0c7fe0ce1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab5ed09aa695686faaf83c5b0c7fe0ce1"></a>
template&lt;class T , class T2 &gt; </td></tr>
<tr class="memitem:ab5ed09aa695686faaf83c5b0c7fe0ce1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1MappedArchiveReader.html">MappedArchiveReader</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classCore_1_1MappedArchiveReader.html">MappedArchiveReader</a> &amp;reader, std::map&lt; T, T2 &gt; &amp;target)</td></tr>
<tr class="separator:ab5ed09aa695686faaf83c5b0c7fe0ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e8992956b5c53eed5e8cba8766ff57"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa8e8992956b5c53eed5e8cba8766ff57"></a>
template&lt;class T , class T2 &gt; </td></tr>
<tr class="memitem:aa8e8992956b5c53eed5e8cba8766ff57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCore_1_1MappedArchiveWriter.html">MappedArchiveWriter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classCore_1_1MappedArchiveWriter.html">MappedArchiveWriter</a> &amp;writer, const std::map&lt; T, T2 &gt; &amp;set)</td></tr>
<tr class="separator:aa8e8992956b5c53eed5e8cba8766ff57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfe0531312411cd2000804311868bc5"><td class="memItemLeft" align="right" valign="top">inline_ bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#a7bfe0531312411cd2000804311868bc5">IS_LABEL</a> (const <a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a> x)</td></tr>
<tr class="memdesc:a7bfe0531312411cd2000804311868bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given edge-successor index represents a label rather than a state.  <a href="#a7bfe0531312411cd2000804311868bc5">More...</a><br /></td></tr>
<tr class="separator:a7bfe0531312411cd2000804311868bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c583ae675f86488e953acc7bbf7d29"><td class="memItemLeft" align="right" valign="top">inline_ <a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#af9c583ae675f86488e953acc7bbf7d29">ID_FROM_LABEL</a> (const u32 x)</td></tr>
<tr class="memdesc:af9c583ae675f86488e953acc7bbf7d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the representation index of this label as an edge-successor.  <a href="#af9c583ae675f86488e953acc7bbf7d29">More...</a><br /></td></tr>
<tr class="separator:af9c583ae675f86488e953acc7bbf7d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3db4fa1c38a3c0e7e9a3979f50f0fc5"><td class="memItemLeft" align="right" valign="top">inline_ u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#ac3db4fa1c38a3c0e7e9a3979f50f0fc5">LABEL_FROM_ID</a> (<a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a> x)</td></tr>
<tr class="memdesc:ac3db4fa1c38a3c0e7e9a3979f50f0fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the given index as an edge-successor so that it represents a label.  <a href="#ac3db4fa1c38a3c0e7e9a3979f50f0fc5">More...</a><br /></td></tr>
<tr class="separator:ac3db4fa1c38a3c0e7e9a3979f50f0fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21156f602bb91344c85b16db4c268c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af21156f602bb91344c85b16db4c268c5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extractAlignment</b> (<a class="el" href="classSpeech_1_1Alignment.html">Speech::Alignment</a> &amp;out, <a class="el" href="classCore_1_1Ref.html">Fsa::ConstAutomatonRef</a> alignmentPosteriorFsa, Mm::Weight minProbGT=0.0, Mm::Weight gamma=1.0)</td></tr>
<tr class="separator:af21156f602bb91344c85b16db4c268c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a1dfd3c69bcdc294d3b664ec6ccd91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#ac6a1dfd3c69bcdc294d3b664ec6ccd91">computeLevenshteinColumn</a> (const <a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> symbol, const std::vector&lt; <a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> &gt; &amp;hypothesis, const std::vector&lt; u32 &gt; &amp;oldScores, std::vector&lt; u32 &gt; &amp;newScores, const u32 initialNewScore)</td></tr>
<tr class="memdesc:ac6a1dfd3c69bcdc294d3b664ec6ccd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes one column of the DP levenshtein distance algorithm.  <a href="#ac6a1dfd3c69bcdc294d3b664ec6ccd91">More...</a><br /></td></tr>
<tr class="separator:ac6a1dfd3c69bcdc294d3b664ec6ccd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091b11c85a1998eb7d8c355b1be3caba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a091b11c85a1998eb7d8c355b1be3caba"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><b>minimum</b> (const std::vector&lt; u32 &gt; &amp;scores)</td></tr>
<tr class="separator:a091b11c85a1998eb7d8c355b1be3caba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cbc76020efdfa8b0deed2728518d2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#a62cbc76020efdfa8b0deed2728518d2a">operator&lt;</a> (<a class="el" href="classCore_1_1Ref.html">SearchNodeRef</a> &amp;lower, <a class="el" href="classCore_1_1Ref.html">SearchNodeRef</a> &amp;taller)</td></tr>
<tr class="separator:a62cbc76020efdfa8b0deed2728518d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fa259b43cfaf96ebfa90f860872041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#a48fa259b43cfaf96ebfa90f860872041">posteriorRiskNBestList</a> (const std::vector&lt; <a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> &gt; &amp;trueSentence, const std::vector&lt; <a class="el" href="structSearch_1_1StringHypothesis.html">StringHypothesis</a> &gt; &amp;hypotheses, <a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a> &amp;distanceOne, <a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a> &amp;maximumDistanceOne)</td></tr>
<tr class="memdesc:a48fa259b43cfaf96ebfa90f860872041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Naive computation of Bayes posterior risk assuming the Levenshtein loss function.  <a href="#a48fa259b43cfaf96ebfa90f860872041">More...</a><br /></td></tr>
<tr class="separator:a48fa259b43cfaf96ebfa90f860872041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96230b8612605b7f47556e7bea187e01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#a96230b8612605b7f47556e7bea187e01">posteriorRiskNBestList</a> (const std::vector&lt; <a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> &gt; &amp;trueSentence, const std::vector&lt; <a class="el" href="structSearch_1_1StringHypothesis.html">StringHypothesis</a> &gt; &amp;hypotheses, const <a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a> &amp;pruningThreshold=Fsa::LogSemiring-&gt;max())</td></tr>
<tr class="memdesc:a96230b8612605b7f47556e7bea187e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Naive computation of Bayes posterior risk assuming the Levenshtein loss function.  <a href="#a96230b8612605b7f47556e7bea187e01">More...</a><br /></td></tr>
<tr class="separator:a96230b8612605b7f47556e7bea187e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b543c02121ef17f5972f851f92c0c7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b543c02121ef17f5972f851f92c0c7d"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><b>levenshteinDistance</b> (const std::vector&lt; LabelId &gt; &amp;A, const std::vector&lt; LabelId &gt; &amp;B)</td></tr>
<tr class="separator:a4b543c02121ef17f5972f851f92c0c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6979cc602b0aae533f332a612024a133"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6979cc602b0aae533f332a612024a133"></a>
std::set&lt; <a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getContour</b> (std::set&lt; <a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a> &gt; oldContour, ConstAutomatonRef fsa)</td></tr>
<tr class="separator:a6979cc602b0aae533f332a612024a133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5712d7cc73e7b6ecabf4f1c87ddc49b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5712d7cc73e7b6ecabf4f1c87ddc49b"></a>
std::vector&lt; <a class="el" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getDistances</b> (ConstAutomatonRef fsa)</td></tr>
<tr class="separator:ac5712d7cc73e7b6ecabf4f1c87ddc49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6f35a15438c0449332176f8ad7fc06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf6f35a15438c0449332176f8ad7fc06"></a>
ConstAutomatonRef&#160;</td><td class="memItemRight" valign="bottom"><b>createLinearAutomatonFromVector</b> (const std::vector&lt; LabelId &gt; &amp;sequence, const <a class="el" href="classFsa_1_1Weight.html">Weight</a> &amp;score, ConstAlphabetRef inputAlphabet, ConstAlphabetRef outputAlphabet, ConstSemiringRef semiring)</td></tr>
<tr class="separator:aaf6f35a15438c0449332176f8ad7fc06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7eb41c0bbddfc5ea2774b68ded37ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa7eb41c0bbddfc5ea2774b68ded37ae"></a>
<a class="el" href="classFsa_1_1Weight.html">Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNbestNormalizationConstant</b> (ConstAutomatonRef nbestlist)</td></tr>
<tr class="separator:afa7eb41c0bbddfc5ea2774b68ded37ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8538c4e020e43a9bcd42391b3087759f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8538c4e020e43a9bcd42391b3087759f"></a>
ConstAutomatonRef&#160;</td><td class="memItemRight" valign="bottom"><b>normalizeNbestlist</b> (ConstAutomatonRef nbest)</td></tr>
<tr class="separator:a8538c4e020e43a9bcd42391b3087759f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeba4de45103f9afc5618538dc1f90be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afeba4de45103f9afc5618538dc1f90be"></a>
ConstAutomatonRef&#160;</td><td class="memItemRight" valign="bottom"><b>partialNbestlist</b> (ConstAutomatonRef nbestlist, u32 size)</td></tr>
<tr class="separator:afeba4de45103f9afc5618538dc1f90be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3b34748d535a3c51245aed86a7be9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb3b34748d535a3c51245aed86a7be9a"></a>
<a class="el" href="classFsa_1_1Weight.html">Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><b>posteriorExpectedRisk</b> (ConstAutomatonRef center, ConstAutomatonRef hypotheses)</td></tr>
<tr class="separator:adb3b34748d535a3c51245aed86a7be9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39f86cedb1aaffb42354c9dd4b4bdcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae39f86cedb1aaffb42354c9dd4b4bdcb"></a>
<a class="el" href="classFsa_1_1Weight.html">Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><b>collectWeights</b> (ConstSemiringRef sr, const <a class="el" href="classCore_1_1Vector.html">Core::Vector</a>&lt; <a class="el" href="classFsa_1_1Weight.html">Weight</a> &gt; &amp;weights)</td></tr>
<tr class="separator:ae39f86cedb1aaffb42354c9dd4b4bdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab599fc551a6eff03bee523f0e7767114"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab599fc551a6eff03bee523f0e7767114"></a>
<a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNbestNormalizationConstant</b> (<a class="el" href="classCore_1_1Ref.html">Fsa::ConstAutomatonRef</a> nbestlist)</td></tr>
<tr class="separator:ab599fc551a6eff03bee523f0e7767114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe2deb3ffecc99c253fe23b684312ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafe2deb3ffecc99c253fe23b684312ed"></a>
<a class="el" href="classCore_1_1Ref.html">Fsa::ConstAutomatonRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>normalizeNbestlist</b> (<a class="el" href="classCore_1_1Ref.html">Fsa::ConstAutomatonRef</a> nbestlist)</td></tr>
<tr class="separator:aafe2deb3ffecc99c253fe23b684312ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c3f4348f72c75eceb0407c98c781e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48c3f4348f72c75eceb0407c98c781e6"></a>
<a class="el" href="classCore_1_1Ref.html">Fsa::ConstAutomatonRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>partialNbestlist</b> (<a class="el" href="classCore_1_1Ref.html">Fsa::ConstAutomatonRef</a> nbestlist, u32 size)</td></tr>
<tr class="separator:a48c3f4348f72c75eceb0407c98c781e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63958f6873f05cf8621fe063be4fca1e"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#a63958f6873f05cf8621fe063be4fca1e">levenshteinDistance</a> (const std::vector&lt; <a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> &gt; &amp;B)</td></tr>
<tr class="memdesc:a63958f6873f05cf8621fe063be4fca1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute levenshtein distance between two sentences using the dynamic programming algorithm.  <a href="#a63958f6873f05cf8621fe063be4fca1e">More...</a><br /></td></tr>
<tr class="separator:a63958f6873f05cf8621fe063be4fca1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c614c56c4c8b06b95700fb8f75efd29"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#a1c614c56c4c8b06b95700fb8f75efd29">getContour</a> (std::set&lt; <a class="el" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> &gt; oldContour, <a class="el" href="classCore_1_1Ref.html">Fsa::ConstAutomatonRef</a> fsa)</td></tr>
<tr class="separator:a1c614c56c4c8b06b95700fb8f75efd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240c1dcf0016c70b47f6f62d029a410a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#a240c1dcf0016c70b47f6f62d029a410a">getDistances</a> (<a class="el" href="classCore_1_1Ref.html">Fsa::ConstAutomatonRef</a> fsa)</td></tr>
<tr class="memdesc:a240c1dcf0016c70b47f6f62d029a410a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the longest distance for a state from the source of the fsa.  <a href="#a240c1dcf0016c70b47f6f62d029a410a">More...</a><br /></td></tr>
<tr class="separator:a240c1dcf0016c70b47f6f62d029a410a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f0153b2fd1ffb313160e46d1e62b5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0f0153b2fd1ffb313160e46d1e62b5e"></a>
<a class="el" href="classCore_1_1Ref.html">Fsa::ConstAutomatonRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>createLinearAutomatonFromVector</b> (const std::vector&lt; <a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> &gt; &amp;sequence, const <a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a> &amp;score=<a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a>(), <a class="el" href="namespaceFsa.html#aed2b7f9150f889dd08c2e6be52b17809">Fsa::ConstAlphabetRef</a> inputAlphabet=<a class="el" href="namespaceFsa.html#aed2b7f9150f889dd08c2e6be52b17809">Fsa::ConstAlphabetRef</a>(), <a class="el" href="namespaceFsa.html#aed2b7f9150f889dd08c2e6be52b17809">Fsa::ConstAlphabetRef</a> outputAlphabet=<a class="el" href="namespaceFsa.html#aed2b7f9150f889dd08c2e6be52b17809">Fsa::ConstAlphabetRef</a>(), <a class="el" href="classCore_1_1Ref.html">Fsa::ConstSemiringRef</a> semiring=<a class="el" href="classCore_1_1Ref.html">Fsa::ConstSemiringRef</a>(Fsa::UnknownSemiring))</td></tr>
<tr class="separator:ae0f0153b2fd1ffb313160e46d1e62b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f44c408c14caa4627ffae9e87e54a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8f44c408c14caa4627ffae9e87e54a8"></a>
<a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><b>posteriorExpectedRisk</b> (<a class="el" href="classCore_1_1Ref.html">Fsa::ConstAutomatonRef</a> center, <a class="el" href="classCore_1_1Ref.html">Fsa::ConstAutomatonRef</a> hypotheses)</td></tr>
<tr class="separator:aa8f44c408c14caa4627ffae9e87e54a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fac05f63337c0751a42e638f5acc370"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fac05f63337c0751a42e638f5acc370"></a>
<a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><b>collectWeights</b> (<a class="el" href="classCore_1_1Ref.html">Fsa::ConstSemiringRef</a> sr, const <a class="el" href="classCore_1_1Vector.html">Core::Vector</a>&lt; <a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a> &gt; &amp;weights)</td></tr>
<tr class="separator:a0fac05f63337c0751a42e638f5acc370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1c18e908f34cedb42f44d64ed04b57"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7d1c18e908f34cedb42f44d64ed04b57"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7d1c18e908f34cedb42f44d64ed04b57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StateTreeIo::read&lt; StateTree::Exit &gt;</b> (Input &amp;i, <a class="el" href="structSearch_1_1StateTree_1_1Exit.html">StateTree::Exit</a> &amp;exit) const </td></tr>
<tr class="separator:a7d1c18e908f34cedb42f44d64ed04b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50fa2c824440c94e0328e282b489597"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad50fa2c824440c94e0328e282b489597"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad50fa2c824440c94e0328e282b489597"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StateTreeIo::write&lt; StateTree::Exit &gt;</b> (Output &amp;o, const <a class="el" href="structSearch_1_1StateTree_1_1Exit.html">StateTree::Exit</a> &amp;exit) const </td></tr>
<tr class="separator:ad50fa2c824440c94e0328e282b489597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456c15d8514694c65fb6dc52d62d8bf3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a456c15d8514694c65fb6dc52d62d8bf3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a456c15d8514694c65fb6dc52d62d8bf3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StateTreeIo::read&lt; StateTree::StateDesc &gt;</b> (Input &amp;i, <a class="el" href="structSearch_1_1StateTree_1_1StateDesc.html">StateTree::StateDesc</a> &amp;desc) const </td></tr>
<tr class="separator:a456c15d8514694c65fb6dc52d62d8bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af273c1d7f84bd1211b0c8d63eb65f362"><td class="memTemplParams" colspan="2"><a class="anchor" id="af273c1d7f84bd1211b0c8d63eb65f362"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af273c1d7f84bd1211b0c8d63eb65f362"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StateTreeIo::write&lt; StateTree::StateDesc &gt;</b> (Output &amp;o, const <a class="el" href="structSearch_1_1StateTree_1_1StateDesc.html">StateTree::StateDesc</a> &amp;desc) const </td></tr>
<tr class="separator:af273c1d7f84bd1211b0c8d63eb65f362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3997ab5e1d64d11e8df4b6b7f3ad24"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8c3997ab5e1d64d11e8df4b6b7f3ad24"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8c3997ab5e1d64d11e8df4b6b7f3ad24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StateTreeIo::read&lt; StateTree::State &gt;</b> (Input &amp;i, <a class="el" href="structSearch_1_1StateTree_1_1State.html">StateTree::State</a> &amp;state) const </td></tr>
<tr class="separator:a8c3997ab5e1d64d11e8df4b6b7f3ad24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b4fd763152ae700e0899d7cbefd035"><td class="memTemplParams" colspan="2"><a class="anchor" id="a41b4fd763152ae700e0899d7cbefd035"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a41b4fd763152ae700e0899d7cbefd035"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StateTreeIo::write&lt; StateTree::State &gt;</b> (Output &amp;o, const <a class="el" href="structSearch_1_1StateTree_1_1State.html">StateTree::State</a> &amp;state) const </td></tr>
<tr class="separator:a41b4fd763152ae700e0899d7cbefd035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f7e54cea2b943f8ff17bec0f62f8ad"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa8f7e54cea2b943f8ff17bec0f62f8ad"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa8f7e54cea2b943f8ff17bec0f62f8ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StateTreeIo::read&lt; StateTree::CoarticulationStructure::PhonemePair &gt;</b> (Input &amp;i, <a class="el" href="structSearch_1_1StateTree_1_1CoarticulationStructure_1_1PhonemePair.html">StateTree::CoarticulationStructure::PhonemePair</a> &amp;pair) const </td></tr>
<tr class="separator:aa8f7e54cea2b943f8ff17bec0f62f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3109a033e776ebd46dab1dd143ba8987"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3109a033e776ebd46dab1dd143ba8987"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3109a033e776ebd46dab1dd143ba8987"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StateTreeIo::write&lt; StateTree::CoarticulationStructure::PhonemePair &gt;</b> (Output &amp;o, const <a class="el" href="structSearch_1_1StateTree_1_1CoarticulationStructure_1_1PhonemePair.html">StateTree::CoarticulationStructure::PhonemePair</a> &amp;pair) const </td></tr>
<tr class="separator:a3109a033e776ebd46dab1dd143ba8987"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2a4cc625eacaa446c3b91a30a7dc5612"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a4cc625eacaa446c3b91a30a7dc5612"></a>
const <a class="el" href="classCore_1_1ParameterString.html">Core::ParameterString</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramPrefixWords</b> (&quot;prefix-words&quot;,&quot;&quot;,&quot;&quot;)</td></tr>
<tr class="separator:a2a4cc625eacaa446c3b91a30a7dc5612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe773e0cdeef25896e6e92c593c7a761"><td class="memItemLeft" align="right" valign="top">static const f32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#abe773e0cdeef25896e6e92c593c7a761">defaultBeamPruning</a> = 12.0</td></tr>
<tr class="memdesc:abe773e0cdeef25896e6e92c593c7a761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pruning (NOTE: pruning values are relative to the lm-scale, if not noted otherwise):  <a href="#abe773e0cdeef25896e6e92c593c7a761">More...</a><br /></td></tr>
<tr class="separator:abe773e0cdeef25896e6e92c593c7a761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9d8191204df7b4725fca8cfec26e86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf9d8191204df7b4725fca8cfec26e86"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramBeamPruning</b> (&quot;beam-pruning&quot;,&quot;Beam size used for pruning state hypotheses, relative to the lm-scale. \
   Typically between 8 and 12. Default: 12.0 if nothing else is set.&quot;, Core::Type&lt; f32 &gt;::max, 0)</td></tr>
<tr class="separator:acf9d8191204df7b4725fca8cfec26e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac954493a0b923b85cd112afa20764d31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac954493a0b923b85cd112afa20764d31"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramHistogramIsMasterPruning</b> (&quot;histogram-pruning-is-master-pruning&quot;,&quot;&quot;, false)</td></tr>
<tr class="separator:ac954493a0b923b85cd112afa20764d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3d4c7f1ee084cda29d04b1c5d40257"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc3d4c7f1ee084cda29d04b1c5d40257"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramAcousticPruning</b> (&quot;acoustic-pruning&quot;,&quot;DEPRECATED: Use beam-pruning instead! (difference: beam-pruning is relative to the lm-scale, while this is not)&quot;, Core::Type&lt; f32 &gt;::max, 0.0)</td></tr>
<tr class="separator:adc3d4c7f1ee084cda29d04b1c5d40257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3259181da6e5d169cfaef451157766e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3259181da6e5d169cfaef451157766e"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramBeamPruningLimit</b> (&quot;beam-pruning-limit&quot;,&quot;maximum number of active states, enforced by histogram pruning \
   this value is important, because it sets an upper bound for the runtime.&quot;, 500000, 1)</td></tr>
<tr class="separator:ab3259181da6e5d169cfaef451157766e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6826c9d3c59668f5500f1b9990c10db0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6826c9d3c59668f5500f1b9990c10db0"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramAcousticPruningLimit</b> (&quot;acoustic-pruning-limit&quot;,&quot;DEPRECATED: Use beam-pruning-limit instead.&quot;, Core::Type&lt; s32 &gt;::max, 1)</td></tr>
<tr class="separator:a6826c9d3c59668f5500f1b9990c10db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe89b256c10d14949af3176072ade6f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe89b256c10d14949af3176072ade6f3"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramWordEndPruning</b> (&quot;word-end-pruning&quot;,&quot;threshold for pruning of word end hypotheses \
   If the value is below 1.0, eg. 0.7, then it is relative to acoustic-pruning (recommended).&quot;, Core::Type&lt; f32 &gt;::max, 0.0)</td></tr>
<tr class="separator:afe89b256c10d14949af3176072ade6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c92667fb5765a50cbdb9d5babc6b93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7c92667fb5765a50cbdb9d5babc6b93"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramWordEndPruningLimit</b> (&quot;word-end-pruning-limit&quot;,&quot;maximum number of word ends, enforced by histogram pruning \
   this value is important, because it sets an upper bound for the runtime \
   20000 is a good default value, reduce it more if the runtime becomes too slow for some segments.&quot;, Core::Type&lt; s32 &gt;::max, 1)</td></tr>
<tr class="separator:ad7c92667fb5765a50cbdb9d5babc6b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd288ddfbe8667090a4d7c19dadd27ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd288ddfbe8667090a4d7c19dadd27ca"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramLmPruning</b> (&quot;lm-pruning&quot;,&quot;DEPRECATED: Use word-end-pruning instead (difference: word-end-pruning is relative to the lm-scale, while this value is absolute).&quot;, Core::Type&lt; f32 &gt;::max, 0.0)</td></tr>
<tr class="separator:afd288ddfbe8667090a4d7c19dadd27ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a8406ca10cd96a011fb2248fc74668"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06a8406ca10cd96a011fb2248fc74668"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramLmPruningLimit</b> (&quot;lm-pruning-limit&quot;,&quot;DEPRECATED: Use word-end-pruning-limit instead.&quot;, Core::Type&lt; s32 &gt;::max, 1)</td></tr>
<tr class="separator:a06a8406ca10cd96a011fb2248fc74668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb985f07a8a5c3086ff8009cdc50889"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedb985f07a8a5c3086ff8009cdc50889"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lmStatePruning</b> (&quot;lm-state-pruning&quot;,&quot;pruning that is applied to all state hypotheses which are on the same state in the prefix network (can be lower than lm-pruning) \
   If the value is below one, eg. 0.7, then it is relative to word-end-pruning (recommended). \
   This pruning is effective only if the search network is minimized (eg. build-minimized-tree-from-scratch=true and min-phones &lt;= 1)&quot;, Core::Type&lt; f32 &gt;::max)</td></tr>
<tr class="separator:aedb985f07a8a5c3086ff8009cdc50889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88d222c77efca1aed876a85fc26cf13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa88d222c77efca1aed876a85fc26cf13"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramAcousticLookaheadTemporalApproximationScale</b> (&quot;acoustic-lookahead-temporal-approximation-scale&quot;,&quot;scaling factor of temporal acoustic look-ahead (1.5 is a good value)&quot;, 0)</td></tr>
<tr class="separator:aa88d222c77efca1aed876a85fc26cf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa289645a1c8b8cd3fc4ef4eb9624a123"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa289645a1c8b8cd3fc4ef4eb9624a123"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramPerInstanceAcousticPruningScale</b> (&quot;per-instance-acoustic-pruning-scale&quot;,&quot;when using per instance pruning thresholds the pruning threshold is the beam-pruning threshold times this scale&quot;, 1.0)</td></tr>
<tr class="separator:aa289645a1c8b8cd3fc4ef4eb9624a123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a8043d2fd11148695653f01fa73351"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33a8043d2fd11148695653f01fa73351"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramEarlyWordEndPruningMinimumLmScore</b> (&quot;early-word-end-pruning-minimum-lm-score&quot;,&quot;expected lm-score that will be used for early word-end pruning (safe if it is always lower than the real score)&quot;, 0)</td></tr>
<tr class="separator:a33a8043d2fd11148695653f01fa73351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2f2521b60274550160db8d95cdcedf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc2f2521b60274550160db8d95cdcedf"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramWordEndPhonemePruningThreshold</b> (&quot;word-end-phoneme-pruning&quot;,&quot;pruning applied to word ends which have the same final phoneme (relative to word-end-pruning if the value is below 1.0)&quot;, Core::Type&lt; Score &gt;::max)</td></tr>
<tr class="separator:afc2f2521b60274550160db8d95cdcedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade6246eb4c90f34989698a1a0e9b9d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aade6246eb4c90f34989698a1a0e9b9d5"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramWordEndPruningFadeInInterval</b> (&quot;word-end-pruning-fadein&quot;,&quot;inverted depth at which the lm pruning influence reaches zero&quot;, 0, 0, MaxFadeInPruningDistance)</td></tr>
<tr class="separator:aade6246eb4c90f34989698a1a0e9b9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8d04ed6b489d53f4741772f345c904"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#a0d8d04ed6b489d53f4741772f345c904">paramBuildMinimizedTreeFromScratch</a> (&quot;build-minimized-network-from-scratch&quot;,&quot;&quot;, true)</td></tr>
<tr class="memdesc:a0d8d04ed6b489d53f4741772f345c904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal parameters (with good default-values)  <a href="#a0d8d04ed6b489d53f4741772f345c904">More...</a><br /></td></tr>
<tr class="separator:a0d8d04ed6b489d53f4741772f345c904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cf8757e33a2830facb6403c5d381ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63cf8757e33a2830facb6403c5d381ee"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramConditionPredecessorWord</b> (&quot;condition-on-predecessor-word&quot;,&quot;&quot;, false)</td></tr>
<tr class="separator:a63cf8757e33a2830facb6403c5d381ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3d87b7e80dbe7a276918d2bc17597b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd3d87b7e80dbe7a276918d2bc17597b"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramDecodeMesh</b> (&quot;decode-mesh&quot;,&quot;produce a mesh-like reduced lattice, which can later be expanded by mesh-construction and lattice-decoding to the full search space&quot;, false)</td></tr>
<tr class="separator:acd3d87b7e80dbe7a276918d2bc17597b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62770abb51f470a848d51793349c16ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62770abb51f470a848d51793349c16ec"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramDecodeMeshPhones</b> (&quot;decode-mesh-phones&quot;,&quot;-1 means full pronunciation, eg. word pair approximation. 0 means no context. otherwise number of condition phones.&quot;,-1,-1)</td></tr>
<tr class="separator:a62770abb51f470a848d51793349c16ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4708615497de570e2f6aa83272d9c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c4708615497de570e2f6aa83272d9c1"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramEnableLmLookahead</b> (&quot;lm-lookahead&quot;,&quot;enable language model lookahead (recommended)&quot;, true)</td></tr>
<tr class="separator:a4c4708615497de570e2f6aa83272d9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671ba0557eecfbe8c0cd85bf5e6d621f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a671ba0557eecfbe8c0cd85bf5e6d621f"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramSeparateLookaheadLm</b> (&quot;separate-lookahead-lm&quot;,&quot;use a separate lm for lookahead (one that is not provided by the main language-model)&quot;, false)</td></tr>
<tr class="separator:a671ba0557eecfbe8c0cd85bf5e6d621f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136c16b359bb35dfeb599bfa54389206"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a136c16b359bb35dfeb599bfa54389206"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramSeparateRecombinationLm</b> (&quot;separate-recombination-lm&quot;,&quot;use a separate lm for recombination (one that is not provided by the main language-model)&quot;, false)</td></tr>
<tr class="separator:a136c16b359bb35dfeb599bfa54389206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037a9b51f590b789eb863a55f43ff1ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a037a9b51f590b789eb863a55f43ff1ff"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramDisableUnigramLookahead</b> (&quot;disable-unigram-lookahead&quot;,&quot;&quot;, false)</td></tr>
<tr class="separator:a037a9b51f590b789eb863a55f43ff1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1a8aa62be9ec44b5709dcee7e8971c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea1a8aa62be9ec44b5709dcee7e8971c"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramSparseLmLookAhead</b> (&quot;sparse-lm-lookahead&quot;,&quot;use sparse n-gram LM look-ahead (recommended)&quot;, true)</td></tr>
<tr class="separator:aea1a8aa62be9ec44b5709dcee7e8971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d2bdc7d6ae22ac694b3d640a70887f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4d2bdc7d6ae22ac694b3d640a70887f"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramSymmetrizePenalties</b> (&quot;symmetrize-penalties&quot;,&quot;&quot;, false)</td></tr>
<tr class="separator:ae4d2bdc7d6ae22ac694b3d640a70887f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419b308e36365a9f471495d326b07ec8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a419b308e36365a9f471495d326b07ec8"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramReduceLookAheadBeforeDepth</b> (&quot;full-lookahead-min-depth&quot;,&quot;only apply unigram lookahead for states that have a lookahead-network-depth lower than this. negative values allow considering the pushed fan-out.&quot;, 0)</td></tr>
<tr class="separator:a419b308e36365a9f471495d326b07ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0919705560939b7bcc94b51ed0f07835"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0919705560939b7bcc94b51ed0f07835"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramReduceLookAheadStateMinimum</b> (&quot;full-lookahead-min-states&quot;,&quot;apply full lookahead in instances that more than this number of active states&quot;, 0)</td></tr>
<tr class="separator:a0919705560939b7bcc94b51ed0f07835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778ce9fbaf19f7d57ca846e4a493e378"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a778ce9fbaf19f7d57ca846e4a493e378"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramReduceLookAheadDominanceMinimum</b> (&quot;full-lookahead-min-dominance&quot;,&quot;apply full-order lookahead in instances that have at least this dominance&quot;, 0.05)</td></tr>
<tr class="separator:a778ce9fbaf19f7d57ca846e4a493e378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda3d87acf3c245ca61d0354c7e7e60f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adda3d87acf3c245ca61d0354c7e7e60f"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramEarlyBeamPruning</b> (&quot;early-beam-pruning&quot;,&quot;Whether beam pruning should already be performed before computing the acoustic scores, but after look-ahead scores have been applied.&quot;, true)</td></tr>
<tr class="separator:adda3d87acf3c245ca61d0354c7e7e60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0f583dd3f6384347d43c21d46bd095"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc0f583dd3f6384347d43c21d46bd095"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramEarlyWordEndPruning</b> (&quot;early-word-end-pruning&quot;,&quot;enable earlier pruning of word-ends during the recombiniation&quot;, true)</td></tr>
<tr class="separator:abc0f583dd3f6384347d43c21d46bd095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ccddbdda6810b0d6bf68d8ce141138"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64ccddbdda6810b0d6bf68d8ce141138"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramReducedContextWordRecombination</b> (&quot;reduced-context-word-recombination&quot;,&quot;reduce the context of word-end hypotheses before recombination&quot;, false)</td></tr>
<tr class="separator:a64ccddbdda6810b0d6bf68d8ce141138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920c1dcc172d026e9ad8a2fff8a30db3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a920c1dcc172d026e9ad8a2fff8a30db3"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramReducedContextWordRecombinationLimit</b> (&quot;reduced-context-word-recombination-limit&quot;,&quot;the maximum context length to consider when doing word combination&quot;, 1, 0)</td></tr>
<tr class="separator:a920c1dcc172d026e9ad8a2fff8a30db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a78832861efae6238cff1f14d05afd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77a78832861efae6238cff1f14d05afd"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramReducedContextTreeKey</b> (&quot;reduced-context-tree-key&quot;,&quot;reduce the context of tree instance key (to reuse the tree)&quot;, false)</td></tr>
<tr class="separator:a77a78832861efae6238cff1f14d05afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f922940b6171079089081dad21574d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f922940b6171079089081dad21574d7"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramOnTheFlyRescoring</b> (&quot;on-the-fly-rescoring&quot;,&quot;keep track of recombined histories and use those aswell when searching for word ends&quot;, false)</td></tr>
<tr class="separator:a0f922940b6171079089081dad21574d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653c0978ec1691717cef8403591e86ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a653c0978ec1691717cef8403591e86ba"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramOnTheFlyRescoringMaxHistories</b> (&quot;on-the-fly-rescoring-history-limit&quot;,&quot;what is the maximum number of alternative histories that should be kept&quot;, 5, 0)</td></tr>
<tr class="separator:a653c0978ec1691717cef8403591e86ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdc6c798544af13f6b40ca3f4491945"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cdc6c798544af13f6b40ca3f4491945"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramMaximumMutableSuffixLength</b> (&quot;maximum-mutable-suffix-length&quot;,&quot;maximum length of words that are allowed to change&quot;, Core::Type&lt; int &gt;::max, 0)</td></tr>
<tr class="separator:a6cdc6c798544af13f6b40ca3f4491945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b74df85116bc0ab1161d380f81ead77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b74df85116bc0ab1161d380f81ead77"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramMaximumMutableSuffixPruningInterval</b> (&quot;maximum-mutable-suffix-pruning-interval&quot;,&quot;perform mutable-suffix-pruning every n frames&quot;, 0, 0)</td></tr>
<tr class="separator:a2b74df85116bc0ab1161d380f81ead77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309a614d4c136cf36b9f976324436ce0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a309a614d4c136cf36b9f976324436ce0"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramExtendedStatistics</b> (&quot;expensive-statistics&quot;,&quot;add additional performance-wise expensive statistics&quot;, false)</td></tr>
<tr class="separator:a309a614d4c136cf36b9f976324436ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2beb05a120344891586aa901f0a3fff0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2beb05a120344891586aa901f0a3fff0"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramEarlyBackOff</b> (&quot;early-backoff&quot;,&quot;enable early backing-off right at the root states, as done in WFST based decoders (lazy dominance-based look-ahead activation is recommended, eg. for example full-lookahead-min-dominance=0.1)&quot;, false)</td></tr>
<tr class="separator:a2beb05a120344891586aa901f0a3fff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe324e018a3f841c96590dd371a8808"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafe324e018a3f841c96590dd371a8808"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramCorrectPushedWordBoundaryTimes</b> (&quot;correct-pushed-word-boundary-times&quot;,&quot;correct the word boundary times that are changed through word-end pushing. Activate this if you want to generate alignments or similar&quot;, true)</td></tr>
<tr class="separator:aafe324e018a3f841c96590dd371a8808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7285016d759356983f8216036a4b569e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7285016d759356983f8216036a4b569e"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramCorrectPushedAcousticScores</b> (&quot;correct-pushed-acoustic-scores&quot;,&quot;correct the acoustic scores that were changed through word-end pushing. Activate this if you need to compute confidence-scores or similar&quot;, true)</td></tr>
<tr class="separator:a7285016d759356983f8216036a4b569e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572542e035320bc2e8a86b8ea692f2b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a572542e035320bc2e8a86b8ea692f2b3"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramUnigramLookaheadBackOffFactor</b> (&quot;unigram-lookahead-backoff-factor&quot;,&quot;&quot;, 0.0)</td></tr>
<tr class="separator:a572542e035320bc2e8a86b8ea692f2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12852b349a058ccd48d7e8bda295e22e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12852b349a058ccd48d7e8bda295e22e"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramOverflowLmScoreToAm</b> (&quot;overflow-lm-score-to-am&quot;,&quot;if the models can produce negative scores, then sometimes it can happen that an acoustic word score is negative in the lattice, thereby making the lattice invalid. \
   with this option, the acoustic score 'overflows' into the LM score, leading to a valid lattice with correct per-word scores, but with wrong score distribution \
   between AM/LM&quot;, false)</td></tr>
<tr class="separator:a12852b349a058ccd48d7e8bda295e22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ea9aeb3349babb03ec394c952a40ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64ea9aeb3349babb03ec394c952a40ef"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramSparseLmLookaheadSlowPropagation</b> (&quot;sparse-lm-lookahead-slow-propagation&quot;,&quot;prevent skipping multiple look-ahead n-gram order levels at the same timeframe (very minor effect)&quot;, false)</td></tr>
<tr class="separator:a64ea9aeb3349babb03ec394c952a40ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd078ff9b03697d8d44c0f739ac844e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd078ff9b03697d8d44c0f739ac844e0"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramWordEndPruningBins</b> (&quot;word-end-pruning-bins&quot;,&quot;number of bins for histogram pruning of word ends (very minor effect)&quot;, 100, 2)</td></tr>
<tr class="separator:acd078ff9b03697d8d44c0f739ac844e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2839dce8671e143b278b78ccc200622"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2839dce8671e143b278b78ccc200622"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramAcousticPruningBins</b> (&quot;acoustic-pruning-bins&quot;,&quot;number of bins for histogram pruning of states (very minor effect)&quot;, 100, 2)</td></tr>
<tr class="separator:af2839dce8671e143b278b78ccc200622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae373e690d3f7e1a669d9b346b828519c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae373e690d3f7e1a669d9b346b828519c"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramInstanceDeletionLatency</b> (&quot;instance-deletion-latency&quot;,&quot;timeframes of inactivity before an instance is deleted&quot;, 3, 0)</td></tr>
<tr class="separator:ae373e690d3f7e1a669d9b346b828519c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce2d8a0a7e57aa982569520ba0b7b7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ce2d8a0a7e57aa982569520ba0b7b7e"></a>
const <a class="el" href="classCore_1_1ParameterString.html">Core::ParameterString</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramDumpDotGraph</b> (&quot;search-network-dump-dot-graph&quot;,&quot;&quot;,&quot;&quot;)</td></tr>
<tr class="separator:a1ce2d8a0a7e57aa982569520ba0b7b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac956744b1a856ecb29936cadf7b6d3d3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#ac956744b1a856ecb29936cadf7b6d3d3">paramEncodeStateInTrace</a> (&quot;encode-state-in-trace&quot;,&quot;encode the network state in the boundary transition-information of lattices. this is only useful in auto-correcting search, and only actually used if lattice-generation is explicitly disabled in the recognition-context.&quot;, true)</td></tr>
<tr class="memdesc:ac956744b1a856ecb29936cadf7b6d3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special parameters for auto-correcting search:  <a href="#ac956744b1a856ecb29936cadf7b6d3d3">More...</a><br /></td></tr>
<tr class="separator:ac956744b1a856ecb29936cadf7b6d3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191a57a18c50925ecaf59f6990a114b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a191a57a18c50925ecaf59f6990a114b1"></a>
const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramEncodeStateInTraceAlways</b> (&quot;encode-state-in-trace-always&quot;,&quot;&quot;, false)</td></tr>
<tr class="separator:a191a57a18c50925ecaf59f6990a114b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b369f2a08adb6863c2e9bfb865e4cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4b369f2a08adb6863c2e9bfb865e4cb"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramMinimumBeamPruning</b> (&quot;minimum-beam-pruning&quot;,&quot;minimum beam pruning allowed during automatic tightening for auto-correcting search&quot;, 2.0)</td></tr>
<tr class="separator:af4b369f2a08adb6863c2e9bfb865e4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f20823bfa334460ba43d2b22fe2f87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3f20823bfa334460ba43d2b22fe2f87"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramMaximumBeamPruning</b> (&quot;maximum-beam-pruning&quot;,&quot;maximum beam pruning allowed during automatic relaxation for auto-correcting search&quot;, 100, 0)</td></tr>
<tr class="separator:ac3f20823bfa334460ba43d2b22fe2f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6ccffa1ae5a9d65ddbe2fef9610f2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d6ccffa1ae5a9d65ddbe2fef9610f2c"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramMaximumAcousticPruningLimit</b> (&quot;maximum-beam-pruning-limit&quot;,&quot;&quot;, 250000, 1)</td></tr>
<tr class="separator:a9d6ccffa1ae5a9d65ddbe2fef9610f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567db1fd64b81dfe44b5759be4e0cd8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a567db1fd64b81dfe44b5759be4e0cd8e"></a>
const <a class="el" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramMinimumAcousticPruningLimit</b> (&quot;minimum-beam-pruning-limit&quot;,&quot;&quot;, 100, 1)</td></tr>
<tr class="separator:a567db1fd64b81dfe44b5759be4e0cd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f376cbbc4d42bf6ad8c50c7b3bb94b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21f376cbbc4d42bf6ad8c50c7b3bb94b"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramMinimumWordLemmasAfterRecombination</b> (&quot;minimum-word-lemmas-after-recombination&quot;,&quot;minimum number of average different observed word lemmas per timeframe to consider the search-space non-degenerated for auto-correcting search&quot;, 0)</td></tr>
<tr class="separator:a21f376cbbc4d42bf6ad8c50c7b3bb94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b3fbc94b3eee300f0bd09164953798"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1b3fbc94b3eee300f0bd09164953798"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramMinimumStatesAfterPruning</b> (&quot;minimum-states-after-pruning&quot;,&quot;minimum number of average states after pruning to consider the search-space non-degenerated for auto-correcting search (better: use minimum-word-lemmas-after-recombination)&quot;, 50)</td></tr>
<tr class="separator:ac1b3fbc94b3eee300f0bd09164953798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b4f1d17ede2ef70379cde575fba8d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21b4f1d17ede2ef70379cde575fba8d3"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramMinimumWordEndsAfterPruning</b> (&quot;minimum-word-ends-after-pruning&quot;,&quot;minimum number of average word ends after pruning to consider the search-space non-degenerated for auto-correcting search (better: use minimum-word-lemmas-after-recombination)&quot;, 10)</td></tr>
<tr class="separator:a21b4f1d17ede2ef70379cde575fba8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a64d39860c13be8d66369cd9010fd65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a64d39860c13be8d66369cd9010fd65"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramMaximumAcousticPruningSaturation</b> (&quot;maximum-acoustic-pruning-saturation&quot;,&quot;maximum percentage of frames at which the acoustic-pruning-limit may be hit during auto-correcting search&quot;, 0.5, 0.0, 0.9)</td></tr>
<tr class="separator:a5a64d39860c13be8d66369cd9010fd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae583c212462e3fe65d662d59ea5b94af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae583c212462e3fe65d662d59ea5b94af"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramMaximumStatesAfterPruning</b> (&quot;maximum-states-after-pruning&quot;,&quot;maximum absolute number of states after pruning allowed during auto-correcting-search (better: use maximum-acoustic-pruning-saturation and acoustic-pruning-limit instead)&quot;, Core::Type&lt; Score &gt;::max)</td></tr>
<tr class="separator:ae583c212462e3fe65d662d59ea5b94af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19447941375c1ae63c887f4ff15bdc13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19447941375c1ae63c887f4ff15bdc13"></a>
const <a class="el" href="classCore_1_1ParameterFloat.html">Core::ParameterFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>paramMaximumWordEndsAfterPruning</b> (&quot;maximum-word-ends-after-pruning&quot;,&quot;maximum absolute number of word end hypotheses after pruning allowed during auto-correcting-search (better: use maximum-acoustic-pruning-saturation and acoustic-pruning-limit instead)&quot;, Core::Type&lt; Score &gt;::max)</td></tr>
<tr class="separator:a19447941375c1ae63c887f4ff15bdc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5818fcdc885be15a8ab57435bef32d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c5818fcdc885be15a8ab57435bef32d"></a>
static const TraceId&#160;</td><td class="memItemRight" valign="bottom"><b>invalidTraceId</b> = <a class="el" href="structCore_1_1Type.html">Core::Type</a>&lt;TraceId&gt;::max</td></tr>
<tr class="separator:a7c5818fcdc885be15a8ab57435bef32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf94240d77ec07d15534b2a7d2d33174"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSearch.html#aaf94240d77ec07d15534b2a7d2d33174">invalidTreeNodeIndex</a> = (<a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a>)-1</td></tr>
<tr class="separator:aaf94240d77ec07d15534b2a7d2d33174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c13e9af4f0ae37380c61ef30aa304b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0c13e9af4f0ae37380c61ef30aa304b"></a>
static constexpr TimeframeIndex&#160;</td><td class="memItemRight" valign="bottom"><b>InvalidTimeframeIndex</b> = <a class="el" href="structCore_1_1Type.html">Core::Type</a>&lt;u32&gt;::max</td></tr>
<tr class="separator:af0c13e9af4f0ae37380c61ef30aa304b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab3ed10ff5c025f3a46689face00925"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acab3ed10ff5c025f3a46689face00925"></a>
static const Index&#160;</td><td class="memItemRight" valign="bottom"><b>noIndex</b> = <a class="el" href="structCore_1_1Type.html">Core::Type</a>&lt;Index&gt;::max</td></tr>
<tr class="separator:acab3ed10ff5c025f3a46689face00925"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright 2020 RWTH Aachen University. </p>
<p>This file contains a storable, efficient and dynamic structure that allows representing the state-network in speech recognition flexibly.</p>
<p>All rights reserved.</p>
<p>Licensed under the RWTH ASR License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>The structure can dynamically be changed by creating new states and successor-links, and a "cleanup" operation can be used to optimize the structure after significant changes.</p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000064">Todo:</a></b></dt><dd>Enable batch-merging (mergeBatches_), and make sure the structure is optimal.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000065">Todo:</a></b></dt><dd>Allow "freezing" all batches: No follower-gap in the middle (should save 1/3 of space for the batches) </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ad5b661f14c566570312f3dd56d120dee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef u32 <a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">Search::StateId</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of a state or label (see IS_LABEL, ID_FROM_LABEL, and LABEL_FROM_ID) </p>

<p>Definition at line <a class="el" href="TreeStructure_8hh_source.html#l00049">49</a> of file <a class="el" href="TreeStructure_8hh_source.html">TreeStructure.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a6db22ea3065285134fef597f8933b87f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef u32 <a class="el" href="namespaceSearch.html#a6db22ea3065285134fef597f8933b87f">Search::SubTreeListId</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index representing the batch of all nodes that are contained by one tree. </p>

<p>Definition at line <a class="el" href="TreeStructure_8hh_source.html#l00055">55</a> of file <a class="el" href="TreeStructure_8hh_source.html">TreeStructure.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a0f0cff107c7f9e71d4f2d77efb631ffa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef u32 <a class="el" href="namespaceSearch.html#a0f0cff107c7f9e71d4f2d77efb631ffa">Search::SuccessorBatchId</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This index represents an arbitrary list of successor-states and labels. </p>

<p>Definition at line <a class="el" href="TreeStructure_8hh_source.html#l00036">36</a> of file <a class="el" href="TreeStructure_8hh_source.html">TreeStructure.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a9b4630d7f0a64cb3317190d22f0bc2e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef u32 <a class="el" href="namespaceSearch.html#a9b4630d7f0a64cb3317190d22f0bc2e4">Search::TreeIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global index of a tree or subtree. </p>

<p>Definition at line <a class="el" href="TreeStructure_8hh_source.html#l00046">46</a> of file <a class="el" href="TreeStructure_8hh_source.html">TreeStructure.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a08cc3442dad9eb91285cdd83e0da8484"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classCore_1_1Ref.html">Core::Ref</a>&lt;<a class="el" href="classSearch_1_1WordPronunciationState.html">WordPronunciationState</a>&gt; <a class="el" href="namespaceSearch.html#a08cc3442dad9eb91285cdd83e0da8484">Search::WordPronunciationStatePointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The pronunciation including its current state. </p>

<p>Definition at line <a class="el" href="LinearSearch_8hh_source.html#l00030">30</a> of file <a class="el" href="LinearSearch_8hh_source.html">LinearSearch.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="aa02a40bad1cbff39ab5efd9bcfd80e9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aa02a40bad1cbff39ab5efd9bcfd80e9fad646ab382f6afce3c2703c5c0663984c"></a>SingleSuccessorBatchMask&#160;</td><td class="fielddoc">
<p>When this bitmask set on an SuccessorBatchId, the id represents only one successor (or label), and the index can be extracted through "id &amp; (~SingleSuccessorBatchMask)". </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="TreeStructure_8hh_source.html#l00038">38</a> of file <a class="el" href="TreeStructure_8hh_source.html">TreeStructure.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac6a1dfd3c69bcdc294d3b664ec6ccd91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Search::computeLevenshteinColumn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a>&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hypothesis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; u32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldScores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; u32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>newScores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u32&#160;</td>
          <td class="paramname"><em>initialNewScore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes one column of the DP levenshtein distance algorithm. </p>

<p>Definition at line <a class="el" href="MinimumBayesRiskAStarSearch_8cc_source.html#l00076">76</a> of file <a class="el" href="MinimumBayesRiskAStarSearch_8cc_source.html">MinimumBayesRiskAStarSearch.cc</a>.</p>

<p>References <a class="el" href="WeightedAccumulator_8hh_source.html#l00210">require</a>.</p>

<p>Referenced by <a class="el" href="MinimumBayesRiskAStarSearch_8cc_source.html#l00414">Search::MinimumBayesRiskAStarSearch::updateStack()</a>.</p>

</div>
</div>
<a class="anchor" id="a1c614c56c4c8b06b95700fb8f75efd29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a>&gt; Search::getContour </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> &gt;&#160;</td>
          <td class="paramname"><em>oldContour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCore_1_1Ref.html">Fsa::ConstAutomatonRef</a>&#160;</td>
          <td class="paramname"><em>fsa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>contour for all states in oldContour </dd></dl>

</div>
</div>
<a class="anchor" id="a240c1dcf0016c70b47f6f62d029a410a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a>&gt; Search::getDistances </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCore_1_1Ref.html">Fsa::ConstAutomatonRef</a>&#160;</td>
          <td class="paramname"><em>fsa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the longest distance for a state from the source of the fsa. </p>
<dl class="section return"><dt>Returns</dt><dd>vector assigning each state id a distance. </dd></dl>

</div>
</div>
<a class="anchor" id="af9c583ae675f86488e953acc7bbf7d29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline_ <a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a> Search::ID_FROM_LABEL </td>
          <td>(</td>
          <td class="paramtype">const u32&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the representation index of this label as an edge-successor. </p>

<p>Definition at line <a class="el" href="TreeStructure_8hh_source.html#l00063">63</a> of file <a class="el" href="TreeStructure_8hh_source.html">TreeStructure.hh</a>.</p>

<p>Referenced by <a class="el" href="TreeStructure_8cc_source.html#l00112">Search::HMMStateNetwork::addOutputToEdge()</a>, and <a class="el" href="TreeStructure_8cc_source.html#l00041">Search::HMMStateNetwork::clearOutputEdges()</a>.</p>

</div>
</div>
<a class="anchor" id="a7bfe0531312411cd2000804311868bc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline_ bool Search::IS_LABEL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the given edge-successor index represents a label rather than a state. </p>

<p>Definition at line <a class="el" href="TreeStructure_8hh_source.html#l00058">58</a> of file <a class="el" href="TreeStructure_8hh_source.html">TreeStructure.hh</a>.</p>

<p>Referenced by <a class="el" href="TreeStructure_8hh_source.html#l00444">Search::HMMStateNetwork::batchSuccessorsSimple()</a>, <a class="el" href="TreeStructure_8cc_source.html#l00156">Search::HMMStateNetwork::cleanup()</a>, and <a class="el" href="TreeStructure_8cc_source.html#l00041">Search::HMMStateNetwork::clearOutputEdges()</a>.</p>

</div>
</div>
<a class="anchor" id="ac3db4fa1c38a3c0e7e9a3979f50f0fc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline_ u32 Search::LABEL_FROM_ID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the given index as an edge-successor so that it represents a label. </p>

<p>Definition at line <a class="el" href="TreeStructure_8hh_source.html#l00068">68</a> of file <a class="el" href="TreeStructure_8hh_source.html">TreeStructure.hh</a>.</p>

<p>Referenced by <a class="el" href="TreeStructure_8cc_source.html#l00041">Search::HMMStateNetwork::clearOutputEdges()</a>.</p>

</div>
</div>
<a class="anchor" id="a63958f6873f05cf8621fe063be4fca1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 Search::levenshteinDistance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute levenshtein distance between two sentences using the dynamic programming algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>levenshtein distance between sentence A and sentence B </dd></dl>

</div>
</div>
<a class="anchor" id="a62cbc76020efdfa8b0deed2728518d2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Search::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCore_1_1Ref.html">SearchNodeRef</a> &amp;&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCore_1_1Ref.html">SearchNodeRef</a> &amp;&#160;</td>
          <td class="paramname"><em>taller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stack nodes are first sorted by their underestimate ascending and then by their probability mass descending. </p>

<p>Definition at line <a class="el" href="MinimumBayesRiskAStarSearch_8cc_source.html#l00203">203</a> of file <a class="el" href="MinimumBayesRiskAStarSearch_8cc_source.html">MinimumBayesRiskAStarSearch.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a48fa259b43cfaf96ebfa90f860872041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a> Search::posteriorRiskNBestList </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trueSentence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structSearch_1_1StringHypothesis.html">StringHypothesis</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hypotheses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a> &amp;&#160;</td>
          <td class="paramname"><em>distanceOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a> &amp;&#160;</td>
          <td class="paramname"><em>maximumDistanceOne</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Naive computation of Bayes posterior risk assuming the Levenshtein loss function. </p>
<p>This method is usually used for computation of Bayes risk for the MAP hypothesis, as it sets the values needed for checking whether the distance-one criterion is fulfilled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trueSentence</td><td>the sentence for which the risk shall be computed. </td></tr>
    <tr><td class="paramname">hypotheses</td><td>vector with concurrent hypotheses </td></tr>
    <tr><td class="paramname">distanceOne</td><td>this parameter will store the accumulated weight of all hypotheses with Levenshtein distance = 1. </td></tr>
    <tr><td class="paramname">maxdistanceOne</td><td>this parameter will store the maximum weight of all hypotheses with Levenshtein distance = 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Bayes risk of the true sentence as <a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a>. </dd></dl>

<p>Definition at line <a class="el" href="MinimumBayesRiskNBestListSearch_8cc_source.html#l00161">161</a> of file <a class="el" href="MinimumBayesRiskNBestListSearch_8cc_source.html">MinimumBayesRiskNBestListSearch.cc</a>.</p>

<p>Referenced by <a class="el" href="MinimumBayesRiskNBestListSearch_8cc_source.html#l00065">Search::MinimumBayesRiskNBestListNaiveSearch::performSearch()</a>.</p>

</div>
</div>
<a class="anchor" id="a96230b8612605b7f47556e7bea187e01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a> Search::posteriorRiskNBestList </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trueSentence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structSearch_1_1StringHypothesis.html">StringHypothesis</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hypotheses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a> &amp;&#160;</td>
          <td class="paramname"><em>pruningThreshold</em> = <code>Fsa::LogSemiring-&gt;max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Naive computation of Bayes posterior risk assuming the Levenshtein loss function. </p>
<p>If the present risk exceeds the pruning threshold the computation will be stopped immidiately and the maximum possible value for the weight type will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trueSentence</td><td>the sentence for which the risk shall be computed. </td></tr>
    <tr><td class="paramname">hypotheses</td><td>vector with concurrent hypotheses </td></tr>
    <tr><td class="paramname">pruningThreshold</td><td>pruning threshold</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Bayes risk of the true sentence as <a class="el" href="classFsa_1_1Weight.html">Fsa::Weight</a>. </dd></dl>

<p>Definition at line <a class="el" href="MinimumBayesRiskNBestListSearch_8cc_source.html#l00199">199</a> of file <a class="el" href="MinimumBayesRiskNBestListSearch_8cc_source.html">MinimumBayesRiskNBestListSearch.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="abe773e0cdeef25896e6e92c593c7a761"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const f32 Search::defaultBeamPruning = 12.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pruning (NOTE: pruning values are relative to the lm-scale, if not noted otherwise): </p>

<p>Definition at line <a class="el" href="AdvancedTreeSearch_2SearchSpace_8cc_source.html#l00043">43</a> of file <a class="el" href="AdvancedTreeSearch_2SearchSpace_8cc_source.html">AdvancedTreeSearch/SearchSpace.cc</a>.</p>

<p>Referenced by <a class="el" href="AdvancedTreeSearch_2SearchSpace_8cc_source.html#l00881">Search::SearchSpace::setAllowHmmSkips()</a>.</p>

</div>
</div>
<a class="anchor" id="aaf94240d77ec07d15534b2a7d2d33174"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a> Search::invalidTreeNodeIndex = (<a class="el" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a>)-1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000066">Todo:</a></b></dt><dd>Maybe this should be zero! </dd></dl>

<p>Definition at line <a class="el" href="TreeStructure_8hh_source.html#l00052">52</a> of file <a class="el" href="TreeStructure_8hh_source.html">TreeStructure.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a0d8d04ed6b489d53f4741772f345c904"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a> Search::paramBuildMinimizedTreeFromScratch(&quot;build-minimized-network-from-scratch&quot;,&quot;&quot;, true)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal parameters (with good default-values) </p>

</div>
</div>
<a class="anchor" id="ac956744b1a856ecb29936cadf7b6d3d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a> Search::paramEncodeStateInTrace(&quot;encode-state-in-trace&quot;,&quot;encode the network state in the boundary transition-information of lattices. this is only useful in auto-correcting search, and only actually used if lattice-generation is explicitly disabled in the recognition-context.&quot;, true)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special parameters for auto-correcting search: </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
