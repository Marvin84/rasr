<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Sprint: Flf::BinaryPriorityQueue&lt; T, WeakOrder &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sprint
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceFlf.html">Flf</a></li><li class="navelem"><a class="el" href="classFlf_1_1BinaryPriorityQueue.html">BinaryPriorityQueue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFlf_1_1BinaryPriorityQueue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Flf::BinaryPriorityQueue&lt; T, WeakOrder &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Collection of fast hash functions taken from <a href="http://www.concentric.net/~Ttwang/tech/inthash.htm">http://www.concentric.net/~Ttwang/tech/inthash.htm</a>.  
 <a href="classFlf_1_1BinaryPriorityQueue.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa3c235b963ca3cfdb04585a1726ee5c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3c235b963ca3cfdb04585a1726ee5c1"></a>
typedef std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Heap</b></td></tr>
<tr class="separator:aa3c235b963ca3cfdb04585a1726ee5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adf982298a9941e7946023d938efbc1f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf982298a9941e7946023d938efbc1f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BinaryPriorityQueue</b> (const WeakOrder &amp;lessThan=WeakOrder())</td></tr>
<tr class="separator:adf982298a9941e7946023d938efbc1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3c33102187c04782bf7a8b211993fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e3c33102187c04782bf7a8b211993fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BinaryPriorityQueue</b> (const Heap &amp;heap, const WeakOrder &amp;lessThan=WeakOrder())</td></tr>
<tr class="separator:a0e3c33102187c04782bf7a8b211993fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8d9f06d4d37715a7900bd4d81dd8d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e8d9f06d4d37715a7900bd4d81dd8d4"></a>
Heap &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>heap</b> ()</td></tr>
<tr class="separator:a9e8d9f06d4d37715a7900bd4d81dd8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53bb025ddf8f91c3a78372ca7e77a64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae53bb025ddf8f91c3a78372ca7e77a64"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const </td></tr>
<tr class="separator:ae53bb025ddf8f91c3a78372ca7e77a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65960613888ccbbd8ce45317fa30595"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad65960613888ccbbd8ce45317fa30595"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const </td></tr>
<tr class="separator:ad65960613888ccbbd8ce45317fa30595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082e0074c9cdb150577b046d9d20eaad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a082e0074c9cdb150577b046d9d20eaad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a082e0074c9cdb150577b046d9d20eaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603ddba002913008c26ddc96092bf134"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a603ddba002913008c26ddc96092bf134"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>invariant</b> () const </td></tr>
<tr class="separator:a603ddba002913008c26ddc96092bf134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fc5bbd0740b411a172dc843c1ec725"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7fc5bbd0740b411a172dc843c1ec725"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>top</b> ()</td></tr>
<tr class="separator:aa7fc5bbd0740b411a172dc843c1ec725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36fee618aa07ef6bfa09ee9565ecd14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad36fee618aa07ef6bfa09ee9565ecd14"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop</b> ()</td></tr>
<tr class="separator:ad36fee618aa07ef6bfa09ee9565ecd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1f32b84de96221c88d46eb87d471b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f1f32b84de96221c88d46eb87d471b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>changeTop</b> (const T &amp;element)</td></tr>
<tr class="separator:a9f1f32b84de96221c88d46eb87d471b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3e1367989e4de546f95e5659055e01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca3e1367989e4de546f95e5659055e01"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (const T &amp;element)</td></tr>
<tr class="separator:aca3e1367989e4de546f95e5659055e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1d541aa75f7d1e1ae0c010e3c0d750"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d1d541aa75f7d1e1ae0c010e3c0d750"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>downHeap</b> (u32 i)</td></tr>
<tr class="separator:a7d1d541aa75f7d1e1ae0c010e3c0d750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cf0df7e58a03c89ccce236261c5adf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9cf0df7e58a03c89ccce236261c5adf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>upHeap</b> (u32 i)</td></tr>
<tr class="separator:ae9cf0df7e58a03c89ccce236261c5adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a223c7f75a6134de133b953f74ba48f7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a223c7f75a6134de133b953f74ba48f7e"></a>
WeakOrder&#160;</td><td class="memItemRight" valign="bottom"><b>lessThan_</b></td></tr>
<tr class="separator:a223c7f75a6134de133b953f74ba48f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa46035dfb4bb42f621a22beb2721e13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa46035dfb4bb42f621a22beb2721e13"></a>
Heap&#160;</td><td class="memItemRight" valign="bottom"><b>heap_</b></td></tr>
<tr class="separator:afa46035dfb4bb42f621a22beb2721e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class WeakOrder&gt;<br />
class Flf::BinaryPriorityQueue&lt; T, WeakOrder &gt;</h3>

<p>Collection of fast hash functions taken from <a href="http://www.concentric.net/~Ttwang/tech/inthash.htm">http://www.concentric.net/~Ttwang/tech/inthash.htm</a>. </p>
<p>32 bit Mix Functions</p>
<p>Based on an original suggestion on Robert Jenkin's part in 1997, I have done some research for a version of the integer hash function. This is my latest version as of January 2007. The specific value of the bit shifts are obtained from running the accompanied search program.</p>
<p>public int hash32shift(int key) { key = ~key + (key &lt;&lt; 15); // key = (key &lt;&lt; 15) - key - 1; key = key ^ (key &gt;&gt;&gt; 12); key = key + (key &lt;&lt; 2); key = key ^ (key &gt;&gt;&gt; 4); key = key * 2057; // key = (key + (key &lt;&lt; 3)) + (key &lt;&lt; 11); key = key ^ (key &gt;&gt;&gt; 16); return key; }</p>
<p>(~x) + y is equivalent to y - x - 1 in two's complement representation.</p>
<p>By taking advantages of the native instructions such as 'add complement', and 'shift &amp; add', the above hash function runs in 11 machine cycles on HP 9000 workstations.</p>
<p>Having more rounds will strengthen the hash function by making the result more random looking, but performance will be slowed down accordingly. Simulation seems to prefer small shift amounts for inner rounds, and large shift amounts for outer rounds. Robert Jenkins' 32 bit integer hash function</p>
<p>uint32_t hash( uint32_t a) { a = (a+0x7ed55d16) + (a&lt;&lt;12); a = (a^0xc761c23c) ^ (a&gt;&gt;19); a = (a+0x165667b1) + (a&lt;&lt;5); a = (a+0xd3a2646c) ^ (a&lt;&lt;9); a = (a+0xfd7046c5) + (a&lt;&lt;3); a = (a^0xb55a4f09) ^ (a&gt;&gt;16); return a; }</p>
<p>This version of integer hash function uses operations with integer constants to help producing a hash value. I suspect the actual values of the magic constants are not very important. Even using 16 bit constants may still work pretty well.</p>
<p>These magic constants open up the construction of perfect integer hash functions. A test program can vary the magic constants until a set of perfect hashes are found. Using Multiplication for Hashing</p>
<p>Using multiplication requires a mechanism to transport changes from high bit positions to low bit positions. Bit reversal is best, but is slow to implement. A viable alternative is left shifts.</p>
<p>Using multiplication presents some sort of dilemma. Certain machine platforms supports integer multiplication in hardware, and an integer multiplication can be completed in 4 or less cycles. But on some other platforms an integer multiplication could take 8 or more cycles to complete. On the other hand, integer hash functions implemented with bit shifts perform equally well on all platforms.</p>
<p>A compromise is to multiply the key with a 'sparse' bit pattern, where on machines without fast integer multiplier they can be replaced with a 'shift &amp; add' sequence. An example is to multiply the key with (4096 + 8 + 1), with an equivalent expression of (key + (key &lt;&lt; 3)) + (key &lt;&lt; 12).</p>
<p>On most machines a bit shift of 3 bits or less, following by an addition can be performed in one cycle. For example, Pentium's 'lea' instruction can be used to good effect to compute a 'shift &amp; add' in one cycle.</p>
<p>Function hash32shiftmult() uses a combination of bit shifts and integer multiplication to hash the input key.</p>
<p>public int hash32shiftmult(int key) { int c2=0x27d4eb2d; // a prime or an odd constant key = (key ^ 61) ^ (key &gt;&gt;&gt; 16); key = key + (key &lt;&lt; 3); key = key ^ (key &gt;&gt;&gt; 4); key = key * c2; key = key ^ (key &gt;&gt;&gt; 15); return key; }</p>
<p>64 bit Mix Functions</p>
<p>public long hash64shift(long key) { key = (~key) + (key &lt;&lt; 21); // key = (key &lt;&lt; 21) - key - 1; key = key ^ (key &gt;&gt;&gt; 24); key = (key + (key &lt;&lt; 3)) + (key &lt;&lt; 8); // key * 265 key = key ^ (key &gt;&gt;&gt; 14); key = (key + (key &lt;&lt; 2)) + (key &lt;&lt; 4); // key * 21 key = key ^ (key &gt;&gt;&gt; 28); key = key + (key &lt;&lt; 31); return key; }</p>
<p>The longer width of 64 bits require more mixing than the 32 bit version. 64 bit to 32 bit Hash Functions</p>
<p>One such use for this kind of hash function is to hash a 64 bit virtual address to a hash table index. Because the output of the hash function is narrower than the input, the result is no longer one-to-one.</p>
<p>Another usage is to hash two 32 bit integers into one hash value.</p>
<p>public int hash6432shift(long key) { key = (~key) + (key &lt;&lt; 18); // key = (key &lt;&lt; 18) - key - 1; key = key ^ (key &gt;&gt;&gt; 31); key = key * 21; // key = (key + (key &lt;&lt; 2)) + (key &lt;&lt; 4); key = key ^ (key &gt;&gt;&gt; 11); key = key + (key &lt;&lt; 6); key = key ^ (key &gt;&gt;&gt; 22); return (int) key; Taken from <a class="el" href="classCore_1_1PriorityQueue.html" title="Simple heap-based priority queue template. ">Core::PriorityQueue</a>, modified:</p><ul>
<li>allow some insito manipulation of the heap</li>
</ul>
<p>ToTry: Replace Binary heaps by Fibonacci Heaps, see Cormen pp. 476 </p>

<p>Definition at line <a class="el" href="NBest_8cc_source.html#l00152">152</a> of file <a class="el" href="NBest_8cc_source.html">NBest.cc</a>.</p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="NBest_8cc_source.html">NBest.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
