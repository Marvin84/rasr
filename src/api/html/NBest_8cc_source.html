<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Sprint: NBest.cc Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sprint
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_ebd59b59c38e88150332bc2f8c92fb06.html">Flf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">NBest.cc</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/** Copyright 2020 RWTH Aachen University. All rights reserved.</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"> *  Licensed under the RWTH ASR License (the &quot;License&quot;);</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"> *  you may not use this file except in compliance with the License.</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"> *  You may obtain a copy of the License at</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment"> *      http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment"> *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment"> *  See the License for the specific language governing permissions and</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment"> *  limitations under the License.</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="preprocessor">#include &lt;Core/Application.hh&gt;</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#include &lt;Core/Choice.hh&gt;</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor">#include &lt;Core/Parameter.hh&gt;</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="preprocessor">#include &lt;Core/ReferenceCounting.hh&gt;</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;Core/Utility.hh&gt;</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &lt;Core/XmlStream.hh&gt;</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;Best.hh&quot;</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#include &quot;Cache.hh&quot;</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &quot;Compose.hh&quot;</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="preprocessor">#include &quot;Copy.hh&quot;</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="preprocessor">#include &quot;Determinize.hh&quot;</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#include &quot;EpsilonRemoval.hh&quot;</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="preprocessor">#include &quot;FlfCore/Basic.hh&quot;</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="preprocessor">#include &quot;FlfCore/Ftl.hh&quot;</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="preprocessor">#include &quot;Lexicon.hh&quot;</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="preprocessor">#include &quot;Map.hh&quot;</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="preprocessor">#include &quot;NBest.hh&quot;</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceFlf.html">Flf</a> {</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="keywordtype">void</span> dumpNBest(ConstLatticeRef l, std::ostream&amp; os) {</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <span class="keywordflow">if</span> (!l)</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="keywordflow">return</span>;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <span class="keywordflow">for</span> (u32 i = 1, n = l-&gt;getState(l-&gt;initialStateId())-&gt;nArcs(); i &lt;= n; ++n) {</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        os &lt;&lt; <a class="code" href="namespaceCore.html#a5bbc07edba36ef5b3d10aaa159c7cb25">Core::form</a>(<span class="stringliteral">&quot;%5d. &quot;</span>, i);</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        dumpBest(<a class="code" href="namespaceFlf.html#a66a2b49849e3db63d618b432da7bcce6">partial</a>(l, i), os);</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    }</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;}</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment"> * Collection of fast hash functions taken from http://www.concentric.net/~Ttwang/tech/inthash.htm.</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment"> 32 bit Mix Functions</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment"> Based on an original suggestion on Robert Jenkin&#39;s part in 1997, I have done some research for a version of the integer hash function. This is my latest version as of January 2007. The specific value of the bit shifts are obtained from running the accompanied search program.</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment"> public int hash32shift(int key)</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment"> {</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment"> key = ~key + (key &lt;&lt; 15); // key = (key &lt;&lt; 15) - key - 1;</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment"> key = key ^ (key &gt;&gt;&gt; 12);</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment"> key = key + (key &lt;&lt; 2);</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment"> key = key ^ (key &gt;&gt;&gt; 4);</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment"> key = key * 2057; // key = (key + (key &lt;&lt; 3)) + (key &lt;&lt; 11);</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment"> key = key ^ (key &gt;&gt;&gt; 16);</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment"> return key;</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment"> }</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment"> (~x) + y is equivalent to y - x - 1 in two&#39;s complement representation.</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment"> By taking advantages of the native instructions such as &#39;add complement&#39;, and &#39;shift &amp; add&#39;, the above hash function runs in 11 machine cycles on HP 9000 workstations.</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment"> Having more rounds will strengthen the hash function by making the result more random looking, but performance will be slowed down accordingly. Simulation seems to prefer small shift amounts for inner rounds, and large shift amounts for outer rounds.</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="comment"> Robert Jenkins&#39; 32 bit integer hash function</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="comment"> uint32_t hash( uint32_t a)</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment"> {</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment"> a = (a+0x7ed55d16) + (a&lt;&lt;12);</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment"> a = (a^0xc761c23c) ^ (a&gt;&gt;19);</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment"> a = (a+0x165667b1) + (a&lt;&lt;5);</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment"> a = (a+0xd3a2646c) ^ (a&lt;&lt;9);</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="comment"> a = (a+0xfd7046c5) + (a&lt;&lt;3);</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment"> a = (a^0xb55a4f09) ^ (a&gt;&gt;16);</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="comment"> return a;</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="comment"> }</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment"> This version of integer hash function uses operations with integer constants to help producing a hash value. I suspect the actual values of the magic constants are not very important. Even using 16 bit constants may still work pretty well.</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="comment"> These magic constants open up the construction of perfect integer hash functions. A test program can vary the magic constants until a set of perfect hashes are found.</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="comment"> Using Multiplication for Hashing</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment"> Using multiplication requires a mechanism to transport changes from high bit positions to low bit positions. Bit reversal is best, but is slow to implement. A viable alternative is left shifts.</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment"> Using multiplication presents some sort of dilemma. Certain machine platforms supports integer multiplication in hardware, and an integer multiplication can be completed in 4 or less cycles. But on some other platforms an integer multiplication could take 8 or more cycles to complete. On the other hand, integer hash functions implemented with bit shifts perform equally well on all platforms.</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment"> A compromise is to multiply the key with a &#39;sparse&#39; bit pattern, where on machines without fast integer multiplier they can be replaced with a &#39;shift &amp; add&#39; sequence. An example is to multiply the key with (4096 + 8 + 1), with an equivalent expression of (key + (key &lt;&lt; 3)) + (key &lt;&lt; 12).</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="comment"> On most machines a bit shift of 3 bits or less, following by an addition can be performed in one cycle. For example, Pentium&#39;s &#39;lea&#39; instruction can be used to good effect to compute a &#39;shift &amp; add&#39; in one cycle.</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment"> Function hash32shiftmult() uses a combination of bit shifts and integer multiplication to hash the input key.</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="comment"> public int hash32shiftmult(int key)</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="comment"> {</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="comment"> int c2=0x27d4eb2d; // a prime or an odd constant</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="comment"> key = (key ^ 61) ^ (key &gt;&gt;&gt; 16);</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="comment"> key = key + (key &lt;&lt; 3);</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="comment"> key = key ^ (key &gt;&gt;&gt; 4);</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment"> key = key * c2;</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="comment"> key = key ^ (key &gt;&gt;&gt; 15);</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment"> return key;</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment"> }</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment"> 64 bit Mix Functions</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment"> public long hash64shift(long key)</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment"> {</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment"> key = (~key) + (key &lt;&lt; 21); // key = (key &lt;&lt; 21) - key - 1;</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment"> key = key ^ (key &gt;&gt;&gt; 24);</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment"> key = (key + (key &lt;&lt; 3)) + (key &lt;&lt; 8); // key * 265</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment"> key = key ^ (key &gt;&gt;&gt; 14);</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment"> key = (key + (key &lt;&lt; 2)) + (key &lt;&lt; 4); // key * 21</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment"> key = key ^ (key &gt;&gt;&gt; 28);</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment"> key = key + (key &lt;&lt; 31);</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment"> return key;</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment"> }</span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment"> The longer width of 64 bits require more mixing than the 32 bit version.</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment"> 64 bit to 32 bit Hash Functions</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment"> One such use for this kind of hash function is to hash a 64 bit virtual address to a hash table index. Because the output of the hash function is narrower than the input, the result is no longer one-to-one.</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment"> Another usage is to hash two 32 bit integers into one hash value.</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="comment"> public int hash6432shift(long key)</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment"> {</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment"> key = (~key) + (key &lt;&lt; 18); // key = (key &lt;&lt; 18) - key - 1;</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="comment"> key = key ^ (key &gt;&gt;&gt; 31);</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment"> key = key * 21; // key = (key + (key &lt;&lt; 2)) + (key &lt;&lt; 4);</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment"> key = key ^ (key &gt;&gt;&gt; 11);</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment"> key = key + (key &lt;&lt; 6);</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="comment"> key = key ^ (key &gt;&gt;&gt; 22);</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="comment"> return (int) key;</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="comment">*/</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span><span class="comment"></span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="comment"> * Taken from Core::PriorityQueue, modified:</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="comment"> * - allow some insito manipulation of the heap</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="comment"> * ToTry: Replace Binary heaps by Fibonacci Heaps, see Cormen pp. 476</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment"> **/</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> WeakOrder&gt;</div><div class="line"><a name="l00152"></a><span class="lineno"><a class="line" href="classFlf_1_1BinaryPriorityQueue.html">  152</a></span>&#160;<span class="keyword">class </span><a class="code" href="classFlf_1_1BinaryPriorityQueue.html">BinaryPriorityQueue</a> {</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;T&gt; Heap;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    WeakOrder lessThan_;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    Heap      heap_;  <span class="comment">// for the sake of simple index arithmetic the first element in the heap must never be used (aka pseudo sentinel), i.e. heap_[0] == T()</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <a class="code" href="classFlf_1_1BinaryPriorityQueue.html">BinaryPriorityQueue</a>(<span class="keyword">const</span> WeakOrder&amp; lessThan = WeakOrder())</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            : lessThan_(lessThan), heap_(1, T()) {}</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <a class="code" href="classFlf_1_1BinaryPriorityQueue.html">BinaryPriorityQueue</a>(<span class="keyword">const</span> Heap&amp; heap, <span class="keyword">const</span> WeakOrder&amp; lessThan = WeakOrder())</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            : lessThan_(lessThan), heap_(heap) {}</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    Heap&amp; heap() {</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        <span class="keywordflow">return</span> heap_;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    }</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordflow">return</span> heap_.size() == 1;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    }</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    u32 size()<span class="keyword"> const </span>{</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <span class="keywordflow">return</span> heap_.size() - 1;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    }</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    <span class="keywordtype">void</span> clear() {</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        heap_.resize(1);</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    }</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="keywordtype">bool</span> invariant()<span class="keyword"> const </span>{</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        <span class="keywordflow">for</span> (u32 i = 2; i &lt; size(); ++i)</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            <span class="keywordflow">if</span> (lessThan_(heap_[i], heap_[i / 2]))</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    }</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    T&amp; top() {</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        <a class="code" href="Assertions_8hh.html#ae925d7587e34145cd52f674b2012539a">require</a>(!empty());</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        verify_(invariant());</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        <span class="keywordflow">return</span> heap_[1];</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    }</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="keywordtype">void</span> pop() {</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <a class="code" href="Assertions_8hh.html#ae925d7587e34145cd52f674b2012539a">require</a>(!empty());</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        heap_[1] = heap_.back();</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        heap_.pop_back();</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        <span class="keywordflow">if</span> (!empty())</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            downHeap(1);</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    }</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    <span class="keywordtype">void</span> changeTop(<span class="keyword">const</span> T&amp; element) {</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        <a class="code" href="Assertions_8hh.html#ae925d7587e34145cd52f674b2012539a">require</a>(!empty());</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        heap_[1] = element;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        downHeap(1);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    }</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="keywordtype">void</span> append(<span class="keyword">const</span> T&amp; element) {</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        heap_.push_back(element);</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        upHeap(heap_.size() - 1);</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    }</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    <span class="keywordtype">void</span> downHeap(u32 i) {</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <a class="code" href="Assertions_8hh.html#ae925d7587e34145cd52f674b2012539a">require</a>((1 &lt;= i) &amp;&amp; (i &lt; heap_.size()));</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        <span class="keyword">const</span> T element = heap_[i];</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        u32     j;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        <span class="keywordflow">while</span> (i &lt;= size() / 2) {</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            j = 2 * i;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            <span class="keywordflow">if</span> ((j &lt; size()) &amp;&amp; lessThan_(heap_[j + 1], heap_[j]))</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                j = j + 1;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            <span class="keywordflow">if</span> (!lessThan_(heap_[j], element))</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            heap_[i] = heap_[j];</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;            i        = j;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        }</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        heap_[i] = element;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        verify_(invariant());</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    }</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="keywordtype">void</span> upHeap(u32 i) {</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <a class="code" href="Assertions_8hh.html#ae925d7587e34145cd52f674b2012539a">require</a>((1 &lt;= i) &amp;&amp; (i &lt; heap_.size()));</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <span class="keyword">const</span> T element = heap_[i];</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordflow">while</span> ((i &gt; 1) &amp;&amp; !lessThan_(heap_[i / 2], element)) {</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;            heap_[i] = heap_[i / 2];</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            i /= 2;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        }</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        heap_[i] = element;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        verify_(invariant());</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    }</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;};</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span></div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span><span class="comment"></span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment"> * A reduced binary map (like std::map):</span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment"> * - fixed size, all elements specified on construction</span></div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="comment"> * ToTry:</span></div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment"> * - Replace binary look ups by hash maps (in PrefixTree::Node::arcs, PrefixTree::Node::suffixes, Detour::forks)</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="comment"> **/</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> Data&gt;</div><div class="line"><a name="l00254"></a><span class="lineno"><a class="line" href="classFlf_1_1BinaryLookUp.html">  254</a></span>&#160;<span class="keyword">class </span><a class="code" href="classFlf_1_1BinaryLookUp.html">BinaryLookUp</a> : <span class="keyword">protected</span> std::vector&lt;std::pair&lt;Key, Data&gt;&gt; {</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;std::pair&lt;Key, Data&gt;&gt; Precursor;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    <span class="keyword">typedef</span> std::pair&lt;Key, Data&gt; Value;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;Value&gt;   ValueList;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="keyword">protected</span>:</div><div class="line"><a name="l00262"></a><span class="lineno"><a class="line" href="structFlf_1_1BinaryLookUp_1_1ValueWeakOrder.html">  262</a></span>&#160;    <span class="keyword">struct </span><a class="code" href="structFlf_1_1BinaryLookUp_1_1ValueWeakOrder.html">ValueWeakOrder</a> {</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> Value&amp; v1, <span class="keyword">const</span> Value&amp; v2)<span class="keyword"> const </span>{</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            <span class="keywordflow">return</span> v1.first &lt; v2.first;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        }</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    };</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    <a class="code" href="classFlf_1_1BinaryLookUp.html">BinaryLookUp</a>(<span class="keyword">const</span> ValueList&amp; values)</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;            : Precursor(values) {</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        std::sort(Precursor::begin(), Precursor::end(), <a class="code" href="structFlf_1_1BinaryLookUp_1_1ValueWeakOrder.html">ValueWeakOrder</a>());</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    }</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    <span class="keyword">const</span> Data&amp; <span class="keyword">get</span>(<span class="keyword">const</span> Key&amp; key, <span class="keyword">const</span> Data&amp; def = Data()) <span class="keyword">const</span> {</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        <span class="keywordflow">if</span> (Precursor::size() &lt;= 8) {</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;            <span class="keyword">typename</span> Precursor::const_iterator it = Precursor::begin(), it_end = Precursor::end();</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;            <span class="keywordflow">for</span> (; (it != it_end) &amp;&amp; (it-&gt;first &lt; key); ++it)</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                ;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;            <span class="keywordflow">return</span> ((it == it_end) || (it-&gt;first != key)) ? def : it-&gt;second;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        }</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        <span class="keywordflow">else</span> {</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;            s32 l = 0, r = Precursor::end() - Precursor::begin() - 1, m;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;            <span class="keywordflow">while</span> (l &lt;= r) {</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                m = (s32)((u32)(l + r) &gt;&gt; 1);  <span class="comment">// = (l + r) / 2;</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                verify_((l &lt;= r) &amp;&amp; (0 &lt;= m) &amp;&amp; (m &lt; s32(Precursor::size())));</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                <span class="keyword">const</span> Key&amp; tmp = (Precursor::begin() + m)-&gt;first;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                <span class="keywordflow">if</span> (key &gt; tmp)</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                    l = m + 1;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (key &lt; tmp)</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                    r = m - 1;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                <span class="keywordflow">else</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                    <span class="keywordflow">return</span> (Precursor::begin() + m)-&gt;second;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;            }</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;            <span class="keywordflow">return</span> def;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        }</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    }</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;};</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span></div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span></div><div class="line"><a name="l00300"></a><span class="lineno"><a class="line" href="classFlf_1_1NBestBuilder.html">  300</a></span>&#160;<span class="keyword">class </span><a class="code" href="classFlf_1_1NBestBuilder.html">NBestBuilder</a> {</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00302"></a><span class="lineno"><a class="line" href="classFlf_1_1NBestBuilder_1_1PrefixTree.html">  302</a></span>&#160;    <span class="keyword">class </span><a class="code" href="classFlf_1_1NBestBuilder_1_1PrefixTree.html">PrefixTree</a> {</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    <span class="keyword">public</span>:</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        <span class="keyword">struct </span><a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">Node</a>;</div><div class="line"><a name="l00305"></a><span class="lineno"><a class="line" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Arc.html">  305</a></span>&#160;        <span class="keyword">struct </span><a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Arc.html">Arc</a> {</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">Node</a>*        to;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;            <a class="code" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> label;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;            <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Arc.html">Arc</a>(<a class="code" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> label)</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                    : to(0), label(label) {}</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Arc.html">Arc</a>(<a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">Node</a>* to, <a class="code" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> label)</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                    : to(to), label(label) {}</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Arc.html">Arc</a>&amp; a)<span class="keyword"> const </span>{</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                <span class="keywordflow">return</span> label &lt; a.label;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            }</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        };</div><div class="line"><a name="l00316"></a><span class="lineno"><a class="line" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">  316</a></span>&#160;        <span class="keyword">struct </span><a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">Node</a> {</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;            <span class="keyword">typedef</span> std::vector&lt;Arc&gt; ArcList;</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;            ArcList                  arcs;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;            <a class="code" href="classCore_1_1Vector.html">StateIdList</a>              suffixes;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;            std::pair&lt;Node*, bool&gt;   add(<a class="code" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> label) {</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                <span class="keywordflow">if</span> (label == Fsa::Epsilon)</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                    <span class="keywordflow">return</span> std::make_pair(<span class="keyword">this</span>, <span class="keyword">false</span>);</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                ArcList::iterator itArc = std::lower_bound(arcs.begin(), arcs.end(), <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Arc.html">Arc</a>(label));</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                <span class="keywordflow">if</span> ((itArc == arcs.end()) || (itArc-&gt;label != label)) {</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;                    <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">Node</a>* to = <span class="keyword">new</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">Node</a>;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;                    arcs.insert(itArc, <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Arc.html">Arc</a>(to, label));</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                    <span class="keywordflow">return</span> std::make_pair(to, <span class="keyword">true</span>);</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                }</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                <span class="keywordflow">else</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                    <span class="keywordflow">return</span> std::make_pair(itArc-&gt;to, <span class="keyword">false</span>);</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;            }</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;            <span class="keywordtype">bool</span> addSuffix(<a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> suffixSid) {</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                StateIdList::iterator itSuffix = std::lower_bound(suffixes.begin(), suffixes.end(), suffixSid);</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                <span class="keywordflow">if</span> ((itSuffix == suffixes.end()) || (*itSuffix != suffixSid)) {</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                    suffixes.insert(itSuffix, suffixSid);</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                }</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                <span class="keywordflow">else</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;            }</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        };</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="keyword">private</span>:</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">Node</a>* root_;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    <span class="keyword">public</span>:</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <a class="code" href="classFlf_1_1NBestBuilder_1_1PrefixTree.html">PrefixTree</a>()</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                : root_(<span class="keyword">new</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">Node</a>) {}</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        ~<a class="code" href="classFlf_1_1NBestBuilder_1_1PrefixTree.html">PrefixTree</a>() {</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;            std::vector&lt;Node*&gt; S(1, root_);</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;            <span class="keywordflow">while</span> (!S.empty()) {</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">Node</a>* node = S.back();</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                S.pop_back();</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                <span class="keywordflow">for</span> (Node::ArcList::iterator a = node-&gt;arcs.begin(), a_end = node-&gt;arcs.end(); a != a_end; ++a)</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                    S.push_back(a-&gt;to);</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                <span class="keyword">delete</span> node;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;            }</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;            root_ = 0;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;        }</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;        <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">Node</a>* root() {</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;            <span class="keywordflow">return</span> root_;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        }</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    };</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    <span class="keyword">class </span><a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Arc.html">Arc</a>;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    <span class="keyword">class </span><a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">Node</a>;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    <span class="keyword">class </span><a class="code" href="classFlf_1_1NBestBuilder_1_1Path.html">Path</a>;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    <span class="keyword">class </span><a class="code" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">DissenterList</a>;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    <span class="keyword">class </span><a class="code" href="classFlf_1_1NBestBuilder_1_1Detour.html">Detour</a>;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;</div><div class="line"><a name="l00371"></a><span class="lineno"><a class="line" href="structFlf_1_1NBestBuilder_1_1Arc.html">  371</a></span>&#160;    <span class="keyword">struct </span><a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a> {</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        u32          id;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        Score        score, dissScore;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        <a class="code" href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a> label;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        <a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> from, to;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    };</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>*               <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">ConstArcPtr</a>;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;ConstArcPtr&gt; ConstArcPtrList;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno"><a class="line" href="structFlf_1_1NBestBuilder_1_1Node.html">  380</a></span>&#160;    <span class="keyword">struct </span><a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a> {</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a> *          begin, *end;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        Score          fwdScore, bwdScore;</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        <a class="code" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">DissenterList</a>* dissenters;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>()</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;                : begin(0), end(0), fwdScore(<a class="code" href="structCore_1_1Type.html">Core::Type&lt;Score&gt;::max</a>), bwdScore(<a class="code" href="structCore_1_1Type.html">Core::Type&lt;Score&gt;::max</a>), dissenters(0) {}</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        ~<a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>() {</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;            <span class="keyword">delete</span> dissenters;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        }</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;        <span class="keywordtype">bool</span> hasArcs()<span class="keyword"> const </span>{</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;            <span class="keywordflow">return</span> begin != end;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        }</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;        u32 nArcs()<span class="keyword"> const </span>{</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;            <span class="keywordflow">return</span> end - begin;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;        }</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    };</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;</div><div class="line"><a name="l00397"></a><span class="lineno"><a class="line" href="classFlf_1_1NBestBuilder_1_1Path.html">  397</a></span>&#160;    <span class="keyword">class </span><a class="code" href="classFlf_1_1NBestBuilder_1_1Path.html">Path</a> {</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    <span class="keyword">public</span>:</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;        <span class="keyword">typedef</span> u32         Number;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;        <span class="keyword">static</span> <span class="keyword">const</span> Number InvalidNumber;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="keyword">public</span>:</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        Number     n;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        u32        fatherId;</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        Score      detourScore;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>* dissenter;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        <a class="code" href="classFlf_1_1NBestBuilder_1_1Path.html">Path</a>()</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;                : n(0), fatherId(0), detourScore(0.0), dissenter(0) {}</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;        <a class="code" href="classFlf_1_1NBestBuilder_1_1Path.html">Path</a>(Number n, u32 fatherId, Score detourScore, <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>* dissenter, <span class="keywordtype">bool</span> isDuplicate)</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                : n(n), fatherId(fatherId), detourScore(detourScore), dissenter(dissenter) {}</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    };</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;Path&gt; PathList;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <span class="keyword">typedef</span> std::vector&lt;u32&gt;  PathIdList;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;</div><div class="line"><a name="l00415"></a><span class="lineno"><a class="line" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">  415</a></span>&#160;    <span class="keyword">class </span><a class="code" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">DissenterList</a> {</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    <span class="keyword">public</span>:</div><div class="line"><a name="l00417"></a><span class="lineno"><a class="line" href="structFlf_1_1NBestBuilder_1_1DissenterList_1_1WeakOrder.html">  417</a></span>&#160;        <span class="keyword">struct </span><a class="code" href="structFlf_1_1NBestBuilder_1_1DissenterList_1_1WeakOrder.html">WeakOrder</a> {</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;            <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>&amp; a1, <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>&amp; a2)<span class="keyword"> const </span>{</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;                <span class="keywordflow">return</span> a1.dissScore &lt; a2.dissScore;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;            }</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        };</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <span class="keyword">private</span>:</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;        <span class="keyword">typedef</span> std::pair&lt;const Arc*, const Arc*&gt; Range;</div><div class="line"><a name="l00425"></a><span class="lineno"><a class="line" href="structFlf_1_1NBestBuilder_1_1DissenterList_1_1RangeWeakOrder.html">  425</a></span>&#160;        <span class="keyword">struct </span><a class="code" href="structFlf_1_1NBestBuilder_1_1DissenterList_1_1RangeWeakOrder.html">RangeWeakOrder</a> {</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;            <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> Range&amp; r1, <span class="keyword">const</span> Range&amp; r2)<span class="keyword"> const </span>{</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;                <span class="keywordflow">return</span> r1.first-&gt;dissScore &lt; r2.first-&gt;dissScore;</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;            }</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;        };</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    <span class="keyword">private</span>:</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        <span class="keyword">typedef</span> <a class="code" href="classFlf_1_1BinaryPriorityQueue.html">BinaryPriorityQueue&lt;Range, RangeWeakOrder&gt;</a> <a class="code" href="classFlf_1_1BinaryPriorityQueue.html">PriorityQueue</a>;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        <span class="keyword">mutable</span> PriorityQueue                              Q_;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;        <span class="keyword">mutable</span> ConstArcPtrList                            list_;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;        PriorityQueue::Heap                                initialHeap_;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    <span class="keyword">public</span>:</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;        <a class="code" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">DissenterList</a>()</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                : Q_() {</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;            initialHeap_ = Q_.heap();</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;        }</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        <a class="code" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">DissenterList</a>(<span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>&amp; node, <span class="keyword">const</span> <a class="code" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">DissenterList</a>&amp; next)</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;                : Q_(next.initialHeap_) {</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;            <a class="code" href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a>(node.begin != node.end);</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            <span class="keywordflow">if</span> (node.begin + 1 != node.end)</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                Q_.append(std::make_pair(node.begin + 1, node.end));</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;            initialHeap_ = Q_.heap();</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;        }</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;        <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>* operator[](u32 i)<span class="keyword"> const </span>{</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;            <span class="keywordflow">while</span> (i &gt;= list_.size()) {</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;                <span class="keywordflow">if</span> (!Q_.empty()) {</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;                    Range&amp; r = Q_.top();</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                    list_.push_back(r.first);</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                    <span class="keywordflow">if</span> (++r.first == r.second)</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;                        Q_.pop();</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;                    <span class="keywordflow">else</span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;                        Q_.downHeap(1);</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                }</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;                <span class="keywordflow">else</span></div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                    list_.push_back(0);</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;            }</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;            <span class="keywordflow">return</span> list_[i];</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;        }</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    };</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;</div><div class="line"><a name="l00466"></a><span class="lineno"><a class="line" href="classFlf_1_1NBestBuilder_1_1Detour.html">  466</a></span>&#160;    <span class="keyword">class </span><a class="code" href="classFlf_1_1NBestBuilder_1_1Detour.html">Detour</a> {</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    <span class="keyword">public</span>:</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        <span class="keyword">typedef</span> <a class="code" href="classFlf_1_1BinaryLookUp.html">BinaryLookUp&lt;Fsa::StateId, PrefixTree::Node*&gt;</a> <a class="code" href="classFlf_1_1BinaryLookUp.html">ForkLookUp</a>;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        <span class="keyword">typedef</span> ForkLookUp::Value                             Fork;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        <span class="keyword">typedef</span> ForkLookUp::ValueList                         ForkList;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    <span class="keyword">private</span>:</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a>         initialNid_;</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">PrefixTree::Node</a>* <span class="keyword">const</span>    initialPrefix_;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;        <span class="keyword">const</span> u32                  pathId_;</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;        <span class="keyword">const</span> Score                pathScore_;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;        <span class="keyword">const</span> <a class="code" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">DissenterList</a>* <span class="keyword">const</span> dissenters_;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        <span class="keyword">const</span> ForkLookUp           forks_;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        u32               i_;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;        Score             score_;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">PrefixTree::Node</a>* prefix_;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>*        dissenter_;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    <span class="keyword">protected</span>:</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;        <span class="keywordtype">void</span> update() {</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;            <span class="keywordflow">for</span> (dissenter_ = (*dissenters_)[i_]; dissenter_ != 0; dissenter_ = (*dissenters_)[++i_]) {</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;                prefix_ = forks_.get(dissenter_-&gt;from, 0);</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;                <span class="keywordflow">if</span> (prefix_) {</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;                    score_ = pathScore_ + dissenter_-&gt;dissScore;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;                }</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;            }</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;        }</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    <span class="keyword">public</span>:</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        <a class="code" href="classFlf_1_1NBestBuilder_1_1Detour.html">Detour</a>(<a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> initialNid, <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">PrefixTree::Node</a>* initialPrefix, u32 pathId, Score pathScore, <span class="keyword">const</span> <a class="code" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">DissenterList</a>* dissenters, <span class="keyword">const</span> ForkList&amp; forks)</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;                : initialNid_(initialNid), initialPrefix_(initialPrefix), pathId_(pathId), pathScore_(pathScore), dissenters_(dissenters), forks_(forks), i_(0) {</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            update();</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        }</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;        <span class="comment">// const member access</span></div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;        <a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> initialNid()<span class="keyword"> const </span>{</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;            <span class="keywordflow">return</span> initialNid_;</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        }</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">PrefixTree::Node</a>* initialPrefix()<span class="keyword"> const </span>{</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;            <span class="keywordflow">return</span> initialPrefix_;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        }</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        u32 pathId()<span class="keyword"> const </span>{</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;            <span class="keywordflow">return</span> pathId_;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        }</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;        Score pathScore()<span class="keyword"> const </span>{</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;            <span class="keywordflow">return</span> pathScore_;</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        }</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;        <span class="comment">// dynamic, next &quot;detour&quot;</span></div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;            <span class="keywordflow">return</span> dissenter_ == 0;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;        }</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>* dissenter()<span class="keyword"> const </span>{</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;            <span class="keywordflow">return</span> dissenter_;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;        }</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;        Score score()<span class="keyword"> const </span>{</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;            <span class="keywordflow">return</span> score_;</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;        }</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;        <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">PrefixTree::Node</a>* prefix()<span class="keyword"> const </span>{</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;            <span class="keywordflow">return</span> prefix_;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;        }</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;        <span class="keywordtype">bool</span> next() {</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;            <a class="code" href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a>(!empty());</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;            ++i_;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;            update();</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;            <span class="keywordflow">return</span> !empty();</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;        }</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;    };</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;    <span class="keyword">typedef</span> <a class="code" href="classFlf_1_1NBestBuilder_1_1Detour.html">Detour</a>* <a class="code" href="classFlf_1_1NBestBuilder_1_1Detour.html">DetourPtr</a>;</div><div class="line"><a name="l00535"></a><span class="lineno"><a class="line" href="structFlf_1_1NBestBuilder_1_1DetourPtrWeakOrder.html">  535</a></span>&#160;    <span class="keyword">struct </span><a class="code" href="structFlf_1_1NBestBuilder_1_1DetourPtrWeakOrder.html">DetourPtrWeakOrder</a> {</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;        <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> DetourPtr d1, <span class="keyword">const</span> DetourPtr d2)<span class="keyword"> const </span>{</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            <span class="keywordflow">return</span> d1-&gt;score() &lt; d2-&gt;score();</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;        }</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    };</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    <span class="keyword">typedef</span> <a class="code" href="classFlf_1_1BinaryPriorityQueue.html">BinaryPriorityQueue&lt;DetourPtr, DetourPtrWeakOrder&gt;</a> <a class="code" href="classFlf_1_1BinaryPriorityQueue.html">DetourPtrQueue</a>;</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    <a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a> l_;</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    <span class="keywordtype">bool</span>            removeDuplicates_;</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    u32             nUniquePaths_;</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    PathList        paths_;</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    PathIdList      validPathIds_;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>*       arcs_;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;    <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>*      nodes_;</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;    u32        nodesSize_;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;    Score      bestScore_;</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    <a class="code" href="classFlf_1_1NBestBuilder_1_1PrefixTree.html">PrefixTree</a> prefixTree_;</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;    <span class="keywordtype">void</span> initialize(<span class="keywordtype">bool</span> ignoreNonWords);</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;    <span class="keywordtype">void</span> find(u32 n);</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;    <a class="code" href="classFlf_1_1NBestBuilder.html">NBestBuilder</a>(<a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a> l, u32 n, <span class="keywordtype">bool</span> removeDuplicates = <span class="keyword">true</span>, <span class="keywordtype">bool</span> ignoreNonWords = <span class="keyword">true</span>)</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;            : l_(), removeDuplicates_(removeDuplicates), nUniquePaths_(0) {</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;        <a class="code" href="Assertions_8hh.html#a0a6432d768e4a040089ea8b3c8b6b4f0">ensure</a>(l);</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;        l_         = <a class="code" href="namespaceFlf.html#a185934049655b0511faff255f5211585">persistent</a>(l);</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        nodes_     = 0;</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;        arcs_      = 0;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;        nodesSize_ = 0;</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;        bestScore_ = <a class="code" href="structCore_1_1Type.html">Core::Type&lt;Score&gt;::max</a>;</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        initialize(ignoreNonWords);</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;        find(n);</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;    }</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;    ~<a class="code" href="classFlf_1_1NBestBuilder.html">NBestBuilder</a>() {</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;        <span class="keyword">delete</span>[] arcs_;</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;        <span class="keyword">delete</span>[] nodes_;</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;    }</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;    <span class="keywordtype">void</span>             dumpStatistics(<a class="code" href="classCore_1_1XmlWriter.html">Core::XmlWriter</a>&amp; xml);</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;    <a class="code" href="classCore_1_1Ref.html">StaticLatticeRef</a> lattice(ScoreId scoreId = Semiring::InvalidId);</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;};</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="keyword">const</span> NBestBuilder::Path::Number NBestBuilder::Path::InvalidNumber = <a class="code" href="structCore_1_1Type.html">Core::Type&lt;Number&gt;::max</a>;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="comment"> * Calculate</span></div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="comment"> * - state fwd./bwd. scores</span></div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="comment"> * - arc dissenter score: additional cost of using arc instead of (locally) best path</span></div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="comment"> **/</span></div><div class="line"><a name="l00585"></a><span class="lineno"><a class="line" href="classFlf_1_1NBestBuilder.html#a854ece1f67ab26062d837917c68574d5">  585</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classFlf_1_1NBestBuilder.html#a854ece1f67ab26062d837917c68574d5">NBestBuilder::initialize</a>(<span class="keywordtype">bool</span> ignoreNonWords) {</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespaceLattice.html">Lattice</a>&amp;   l             = *l_;</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;    <span class="keyword">const</span> <a class="code" href="classCore_1_1Vector.html">ScoreList</a>&amp; scales        = l.semiring()-&gt;scales();</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    <a class="code" href="classCore_1_1Ref.html">LabelMapRef</a>      nonWordMapRef = ignoreNonWords ? LabelMap::createNonWordToEpsilonMap(Lexicon::us()-&gt;alphabetId(l.getInputAlphabet())) : <a class="code" href="classCore_1_1Ref.html">LabelMapRef</a>();</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    <a class="code" href="classCore_1_1Ref.html">ConstStateMapRef</a> topSort       = <a class="code" href="namespaceFlf.html#a0a26e6c3ee1ec080f86fd731346e5370">sortTopologically</a>(l_);</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    nodesSize_                     = topSort-&gt;maxSid + 1;</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;    <span class="comment">// count arcs</span></div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    u32 nArcs = 0;</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;    <span class="keywordflow">for</span> (StateMap::const_iterator itSid = topSort-&gt;begin(), endSid = topSort-&gt;end(); itSid != endSid; ++itSid)</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;        nArcs += l.getState(*itSid)-&gt;nArcs();</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    <span class="comment">// arc scores and labels, fwd. scores</span></div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    nodes_          = <span class="keyword">new</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>[nodesSize_];</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>* nextArcPtr = arcs_           = <span class="keyword">new</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>[nArcs];</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    nodes_[topSort-&gt;front()].fwdScore = 0.0;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <span class="keywordflow">for</span> (StateMap::const_iterator itSid = topSort-&gt;begin(), endSid = topSort-&gt;end(); itSid != endSid; ++itSid) {</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;        <a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a>  sid  = *itSid;</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;        <a class="code" href="classCore_1_1Ref.html">ConstStateRef</a> sr   = l.getState(sid);</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;        <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>&amp;         node = nodes_[sid];</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;        node.begin = node.end = nextArcPtr;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        nextArcPtr += sr-&gt;nArcs();</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;        <span class="keywordflow">if</span> (sr-&gt;isFinal()) {</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;            Score score = sr-&gt;weight()-&gt;project(scales);</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;            node.fwdScore += score;</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;            node.bwdScore = score;</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;            <span class="keywordflow">if</span> (node.fwdScore &lt; bestScore_)</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                bestScore_ = node.fwdScore;</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;        }</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!sr-&gt;hasArcs())</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;            <a class="code" href="classCore_1_1Application.html#a790e82fbb0979b78ff1dcba7a43e924e">Core::Application::us</a>()-&gt;<a class="code" href="classCore_1_1Component.html#a9b917f1da1be1a009af6fec706003bee">criticalError</a>(</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;                    <span class="stringliteral">&quot;N-best: lattice \&quot;%s\&quot; is not trim&quot;</span>, l.describe().c_str());</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;        u32 arcId = 0;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;        <span class="keywordflow">for</span> (State::const_iterator a = sr-&gt;begin(), a_end = sr-&gt;end(); a != a_end; ++a, ++node.end, ++arcId) {</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;            <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>&amp; arc         = *node.end;</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;            arc.id           = arcId;</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;            arc.from         = sid;</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;            arc.to           = a-&gt;target();</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;            arc.label        = nonWordMapRef ? ((*nonWordMapRef)[a-&gt;input()].empty() ? a-&gt;input() : Fsa::Epsilon) : a-&gt;input();</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;            arc.score        = a-&gt;weight()-&gt;project(scales);</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;            Score fwdScore   = node.fwdScore + arc.score;</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;            <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>&amp; targetNode = nodes_[arc.to];</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;            <span class="keywordflow">if</span> (fwdScore &lt; targetNode.fwdScore)</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                targetNode.fwdScore = fwdScore;</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;        }</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;        <a class="code" href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a>(node.end == nextArcPtr);</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;    }</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;    <a class="code" href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a>(u32(nextArcPtr - arcs_) == nArcs);</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;    <span class="comment">// bwd. scores and arc diss. scores</span></div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;    <span class="keywordflow">for</span> (StateMap::const_reverse_iterator itSid = topSort-&gt;rbegin(), endSid = topSort-&gt;rend(); itSid != endSid; ++itSid) {</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;        <a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> sid  = *itSid;</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>&amp;        node = nodes_[sid];</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>* a = node.begin; a != node.end; ++a) {</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;            <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>&amp;  arc      = *a;</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;            Score bwdScore = arc.dissScore = arc.score + nodes_[arc.to].bwdScore;</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;            <span class="keywordflow">if</span> (bwdScore &lt; node.bwdScore)</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;                node.bwdScore = bwdScore;</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;        }</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>* a = node.begin; a != node.end; ++a)</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;            a-&gt;dissScore -= node.bwdScore;</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;    }</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;    <a class="code" href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a>(<a class="code" href="namespaceCore.html#a100585c516d2491add7c5826237f4cef">Core::isAlmostEqualUlp</a>(f32(bestScore_), f32(nodes_[topSort-&gt;front()].bwdScore), 100));</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;}</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;<span class="keywordtype">void</span> NBestBuilder::find(u32 n) {</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;    <a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> initialSid = l_-&gt;initialStateId();</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;    <span class="keywordflow">if</span> ((initialSid == Fsa::InvalidStateId) || (!nodes_[initialSid].hasArcs()))</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;        <span class="keywordflow">return</span>;</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;    <span class="comment">//u32 maxPaths = std::max(u32(n * 100), u32(10000));</span></div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;    u32 maxPaths = 1000000;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;    <a class="code" href="classCore_1_1Vector.html">StateIdList</a>      S;</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;    Detour::ForkList F;</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;    <a class="code" href="classFlf_1_1BinaryPriorityQueue.html">DetourPtrQueue</a>   Q;</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;    paths_.reserve(n);</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;    validPathIds_.reserve(n);</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;    <span class="comment">// add first best, i.e. initialize</span></div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;    {</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;        paths_.push_back(<a class="code" href="classFlf_1_1NBestBuilder_1_1Path.html">Path</a>(1, <a class="code" href="structCore_1_1Type.html">Core::Type&lt;u32&gt;::max</a>, 0.0, 0, <span class="keyword">false</span>));</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;        validPathIds_.push_back(0);</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        nUniquePaths_ = 1;</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;        S.push_back(initialSid);</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;        <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">PrefixTree::Node</a> *prefix = prefixTree_.root(), *initialPrefix = prefixTree_.root();</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;        <a class="code" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">DissenterList</a>*    dissenters = 0;</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;        <span class="keywordflow">for</span> (;;) {</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;            <a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> nid  = S.back();</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;            <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>&amp;        node = nodes_[nid];</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;            <span class="keywordflow">if</span> (!node.hasArcs()) {</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;                dissenters = node.dissenters = <span class="keyword">new</span> <a class="code" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">DissenterList</a>;</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;            }</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;            prefix-&gt;addSuffix(nid);</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;            F.push_back(Detour::Fork(nid, prefix));</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;            std::sort(node.begin, node.end, <a class="code" href="structFlf_1_1NBestBuilder_1_1DissenterList_1_1WeakOrder.html">DissenterList::WeakOrder</a>());</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;            <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>&amp; arc = *node.begin;</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;            <a class="code" href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a>(arc.dissScore == 0.0);</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;            S.push_back(arc.to);</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;            prefix = prefix-&gt;add(arc.label).first;</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;        }</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;        <span class="keywordflow">for</span> (StateIdList::const_reverse_iterator itNid = S.rbegin() + 1, endNid = S.rend(); itNid != endNid; ++itNid) {</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;            <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>&amp; node = nodes_[*itNid];</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;            dissenters = node.dissenters = <span class="keyword">new</span> <a class="code" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">DissenterList</a>(node, *dissenters);</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;        }</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;        <a class="code" href="classFlf_1_1NBestBuilder_1_1Detour.html">Detour</a>* detour = <span class="keyword">new</span> <a class="code" href="classFlf_1_1NBestBuilder_1_1Detour.html">Detour</a>(initialSid, initialPrefix, 0, 0.0, dissenters, F);</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;        S.clear();</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;        F.clear();</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;        <span class="keywordflow">if</span> (!detour-&gt;empty())</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;            Q.append(detour);</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;            <span class="keyword">delete</span> detour;</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;    }</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;    <span class="comment">// add remaining n-1 best</span></div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;    Score lastPathScore = 0.0;</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;    <span class="keywordflow">while</span> ((validPathIds_.size() &lt; n) &amp;&amp; !Q.empty() &amp;&amp; (paths_.size() &lt; maxPaths)) {</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;        <a class="code" href="classFlf_1_1NBestBuilder_1_1Detour.html">Detour</a>* detour = Q.top();</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;        <a class="code" href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a>(!detour-&gt;empty());</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;        <span class="keyword">const</span> Score                        pathScore = detour-&gt;score();</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;        <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>*                         dissenter = detour-&gt;dissenter();</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;        std::pair&lt;PrefixTree::Node*, bool&gt; prefix    = std::make_pair(detour-&gt;prefix(), <span class="keyword">false</span>);</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;        <span class="keywordtype">bool</span>                               isUnique = <span class="keyword">false</span>, sharesSuffix = <span class="keyword">false</span>;</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;        <span class="comment">// leave father path</span></div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;        prefix = prefix.first-&gt;add(dissenter-&gt;label);</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;        <span class="keywordflow">if</span> (prefix.second)</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;            isUnique = <span class="keyword">true</span>;</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;        <span class="comment">// add rest of new path, i.e. best path starting from dissenter</span></div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;        <a class="code" href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">PrefixTree::Node</a>* newPrefix     = prefix.first;</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;        <a class="code" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">DissenterList</a>*    newDissenters = 0;</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;        S.push_back(dissenter-&gt;to);</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;        <span class="keywordflow">for</span> (;;) {</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;            <a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> nid  = S.back();</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;            <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>&amp;        node = nodes_[nid];</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;            <span class="keywordflow">if</span> (node.dissenters) {</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;                newDissenters = node.dissenters;</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;            }</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;            <span class="keywordflow">if</span> (!node.hasArcs()) {</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;                newDissenters = node.dissenters = <span class="keyword">new</span> <a class="code" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">DissenterList</a>;</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;            }</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;            <span class="keywordflow">if</span> (!sharesSuffix)</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;                sharesSuffix = !prefix.first-&gt;addSuffix(nid);</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;                verify_(!isUnique);</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;            <span class="keywordflow">if</span> (!sharesSuffix || !removeDuplicates_)</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;                F.push_back(Detour::Fork(nid, prefix.first));</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;            std::sort(node.begin, node.end, <a class="code" href="structFlf_1_1NBestBuilder_1_1DissenterList_1_1WeakOrder.html">DissenterList::WeakOrder</a>());</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;            <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>&amp; arc = *node.begin;</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;            <a class="code" href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a>(arc.dissScore == 0.0);</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;            S.push_back(arc.to);</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;            prefix = prefix.first-&gt;add(arc.label);</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;            <span class="keywordflow">if</span> (prefix.second)</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;                isUnique = <span class="keyword">true</span>;</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;        }</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;        <span class="keywordflow">for</span> (StateIdList::const_reverse_iterator itNid = S.rbegin() + 1, endNid = S.rend(); itNid != endNid; ++itNid) {</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;            <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>&amp; node    = nodes_[*itNid];</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;            newDissenters = node.dissenters = <span class="keyword">new</span> <a class="code" href="classFlf_1_1NBestBuilder_1_1DissenterList.html">DissenterList</a>(node, *newDissenters);</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;        }</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;        <span class="keywordflow">if</span> (!sharesSuffix || !removeDuplicates_) {</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> nid = S.back();;) {</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;                <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>&amp; node = nodes_[nid];</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;                <span class="keywordflow">if</span> (!node.hasArcs())</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;                <span class="keywordflow">if</span> (!prefix.first-&gt;addSuffix(nid)) {</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;                    <a class="code" href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a>(!isUnique);</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;                    sharesSuffix = <span class="keyword">true</span>;</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;                    <span class="keywordflow">if</span> (removeDuplicates_)</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;                        <span class="keywordflow">break</span>;</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;                }</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;                F.push_back(Detour::Fork(nid, prefix.first));</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;                <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>&amp; arc = *node.begin;</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;                <a class="code" href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a>(arc.dissScore == 0.0);</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;                prefix = prefix.first-&gt;add(arc.label);</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;                <span class="keywordflow">if</span> (prefix.second)</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;                    isUnique = <span class="keyword">true</span>;</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;                nid = arc.to;</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;            }</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;        }</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;            verify_(!isUnique);</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;        <span class="comment">// determine path number and uniqueness; update counts</span></div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;        Path::Number n      = Path::InvalidNumber;</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;        u32          pathId = paths_.size();</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;        <span class="keywordflow">if</span> (isUnique || !removeDuplicates_) {</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;            validPathIds_.push_back(pathId);</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;            n = validPathIds_.size();</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;            <span class="keywordflow">if</span> (isUnique)</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;                ++nUniquePaths_;</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;        }</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;            verify_(!isUnique);</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;        paths_.push_back(<a class="code" href="classFlf_1_1NBestBuilder_1_1Path.html">Path</a>(n, detour-&gt;pathId(), pathScore, dissenter, !isUnique));</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;        <a class="code" href="classFlf_1_1NBestBuilder_1_1Detour.html">Detour</a>* newDetour = <span class="keyword">new</span> <a class="code" href="classFlf_1_1NBestBuilder_1_1Detour.html">Detour</a>(dissenter-&gt;to, newPrefix, pathId, pathScore, newDissenters, F);</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;        S.clear();</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;        F.clear();</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;        detour-&gt;next();</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;        <span class="keywordflow">if</span> (!detour-&gt;empty() &amp;&amp; !newDetour-&gt;empty()) {</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;            Q.downHeap(1);</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;            Q.append(newDetour);</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;        }</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!detour-&gt;empty()) {</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;            Q.downHeap(1);</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;            <span class="keyword">delete</span> newDetour;</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;        }</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!newDetour-&gt;empty()) {</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;            Q.changeTop(newDetour);</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;            <span class="keyword">delete</span> detour;</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;        }</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;        <span class="keywordflow">else</span> {</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;            Q.pop();</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;            <span class="keyword">delete</span> detour;</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;            <span class="keyword">delete</span> newDetour;</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;        }</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;        <a class="code" href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a>(lastPathScore &lt;= pathScore);</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;        lastPathScore = pathScore;</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;    }</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;    <span class="keywordflow">if</span> (paths_.size() == maxPaths)</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;        <a class="code" href="classCore_1_1Application.html#a790e82fbb0979b78ff1dcba7a43e924e">Core::Application::us</a>()-&gt;<a class="code" href="classCore_1_1Component.html#ac0806de1942b78cd299ea032c895db7a">warning</a>(</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;                <span class="stringliteral">&quot;Did not find %d valid paths after searching %d paths; give up.&quot;</span>, n, maxPaths);</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;    <span class="keywordflow">for</span> (DetourPtrQueue::Heap::iterator itDetourPtr = Q.heap().begin() + 1, endDetourPtr = Q.heap().end(); itDetourPtr != endDetourPtr; ++itDetourPtr)</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;        <span class="keyword">delete</span> *itDetourPtr;</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;    Q.clear();</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;}</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;<a class="code" href="classCore_1_1Ref.html">StaticLatticeRef</a> NBestBuilder::lattice(ScoreId scoreId) {</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;    u32               n        = validPathIds_.size();</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespaceLattice.html">Lattice</a>&amp;    l        = *l_;</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;    <span class="keyword">const</span> <a class="code" href="classFlf_1_1Semiring.html">Semiring</a>&amp;   semiring = *l_-&gt;semiring();</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;    <span class="keyword">const</span> <a class="code" href="classFlf_1_1Boundaries.html">Boundaries</a>&amp; b        = *l_-&gt;getBoundaries();</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;    <a class="code" href="classFtl_1_1StaticAutomaton.html">StaticLattice</a>*    s        = <span class="keyword">new</span> <a class="code" href="classFtl_1_1StaticAutomaton.html">StaticLattice</a>;</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;    s-&gt;setDescription(<a class="code" href="namespaceCore.html#a5bbc07edba36ef5b3d10aaa159c7cb25">Core::form</a>(<span class="stringliteral">&quot;nbest(%s,%d)&quot;</span>, l.describe().c_str(), n));</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;    s-&gt;setType(l.type());</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;    s-&gt;addProperties(Fsa::PropertyAcyclic | Fsa::TypeTransducer);</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;    s-&gt;setInputAlphabet(l.getInputAlphabet());</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;    <span class="keywordflow">if</span> (l.type() != Fsa::TypeAcceptor)</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;        s-&gt;setOutputAlphabet(l.getOutputAlphabet());</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;    s-&gt;setSemiring(l.semiring());</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;    <a class="code" href="classFlf_1_1StaticBoundaries.html">StaticBoundaries</a>* sb = 0;</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;    <span class="keywordflow">if</span> (b.<a class="code" href="classFlf_1_1Boundaries.html#a8483f33968c278b0f1e9e886fd98b297">valid</a>()) {</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;        sb = <span class="keyword">new</span> <a class="code" href="classFlf_1_1StaticBoundaries.html">StaticBoundaries</a>;</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;        s-&gt;setBoundaries(<a class="code" href="classCore_1_1Ref.html">ConstBoundariesRef</a>(sb));</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;    }</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;    <a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> internalInitialSid = l.initialStateId();</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;    <a class="code" href="classFtl_1_1State.html">State</a>*       root               = <span class="keyword">new</span> <a class="code" href="namespaceFlf.html#a0d12349ba0b409cec1041b923ae4e9c4">State</a>(0);</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;    s-&gt;setState(root);</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;    s-&gt;setInitialStateId(0);</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;    <span class="keywordflow">if</span> (sb)</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;        sb-&gt;<a class="code" href="classFlf_1_1StaticBoundaries.html#a50737c9ea7a9425388a78bd881c172ee">set</a>(0, <a class="code" href="classFlf_1_1Boundary.html">Boundary</a>(0));</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;    <span class="comment">// empty</span></div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;    <span class="keywordflow">if</span> (n == 0) {</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;        root-&gt;setFinal(semiring.one());</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classCore_1_1Ref.html">StaticLatticeRef</a>(s);</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;    }</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;    <a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a>                                    nextSid = n + 1;</div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;    std::vector&lt;Fsa::StateId&gt;                       lattice2internal(n + 1, Fsa::InvalidStateId);</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;    std::vector&lt;std::pair&lt;Fsa::StateId, ScoresRef&gt;&gt; suffix2lattice(nodesSize_, std::make_pair(Fsa::InvalidStateId, <a class="code" href="classFlf_1_1ScoresRef.html">ScoresRef</a>()));</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;    <span class="comment">// add best; prepare suffix representation</span></div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;    {</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;        <a class="code" href="classFtl_1_1State.html">State</a>* sp           = <span class="keyword">new</span> <a class="code" href="namespaceFlf.html#a0d12349ba0b409cec1041b923ae4e9c4">State</a>(1);</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;        lattice2internal[1] = internalInitialSid;</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;        s-&gt;setState(sp);</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;        <span class="keywordflow">if</span> (sb)</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;            sb-&gt;<a class="code" href="classFlf_1_1StaticBoundaries.html#a50737c9ea7a9425388a78bd881c172ee">set</a>(sp-&gt;id(), b.<a class="code" href="classFlf_1_1Boundaries.html#aa7e718e87f552ed1e7e6fbfb19d9f9f5">get</a>(internalInitialSid));</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;        <a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> firstSuffixSid = nextSid;</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;        <a class="code" href="classFlf_1_1ScoresRef.html">ScoresRef</a>    suffixSum;</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> internalSid = internalInitialSid, internalTargetSid;; internalSid = internalTargetSid) {</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;            <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>&amp; node  = nodes_[internalSid];</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;            internalTargetSid = node.begin-&gt;to;</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;            <a class="code" href="classCore_1_1Ref.html">ConstStateRef</a> sr  = l.getState(internalSid);</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;            verify_(lattice2internal[sp-&gt;id()] == sr-&gt;id());</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;            <span class="keyword">const</span> <a class="code" href="structFlf_1_1Arc.html">Flf::Arc</a>&amp; a = *(sr-&gt;begin() + node.begin-&gt;id);</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;            <a class="code" href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a>(a.target() == internalTargetSid);</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;            suffix2lattice[sr-&gt;id()] = std::make_pair(sp-&gt;id(), a.weight());</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;            sp-&gt;<a class="code" href="classFtl_1_1State.html#a94f0dd3c716d407c331aca8bf7c6faa0">newArc</a>(nextSid, a.weight(), a.input(), a.output());</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;            sp = <span class="keyword">new</span> <a class="code" href="namespaceFlf.html#a0d12349ba0b409cec1041b923ae4e9c4">State</a>(nextSid++);</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;            s-&gt;setState(sp);</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;            <span class="keywordflow">if</span> (sb)</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;                sb-&gt;<a class="code" href="classFlf_1_1StaticBoundaries.html#a50737c9ea7a9425388a78bd881c172ee">set</a>(sp-&gt;id(), b.<a class="code" href="classFlf_1_1Boundaries.html#aa7e718e87f552ed1e7e6fbfb19d9f9f5">get</a>(internalTargetSid));</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;            lattice2internal.push_back(internalTargetSid);</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;            <span class="keywordflow">if</span> (!nodes_[internalTargetSid].hasArcs()) {</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;                <a class="code" href="classCore_1_1Ref.html">ConstStateRef</a> sr = l.getState(internalTargetSid);</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;                verify_(lattice2internal[sp-&gt;id()] == sr-&gt;id());</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;                sp-&gt;setFinal(sr-&gt;weight());</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;                suffix2lattice[sr-&gt;id()] = std::make_pair(sp-&gt;id(), sr-&gt;weight());</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;                suffixSum                = sr-&gt;weight();</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;            }</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;        }</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;        <span class="keywordflow">for</span> (u32 suffixSid = nextSid - 2; suffixSid &gt;= firstSuffixSid; --suffixSid) {</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;            std::pair&lt;Fsa::StateId, ScoresRef&gt;&amp; suffix2latticeElement = suffix2lattice[lattice2internal[suffixSid]];</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;            suffixSum = suffix2latticeElement.second = semiring.<a class="code" href="classFlf_1_1Semiring.html#aa6226c8754c459b39344fee172d56dfa">extend</a>(suffix2latticeElement.second, suffixSum);</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;        }</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;        std::pair&lt;Fsa::StateId, ScoresRef&gt;&amp; suffix2latticeElement = suffix2lattice[lattice2internal[1]];</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;        suffixSum = suffix2latticeElement.second = semiring.<a class="code" href="classFlf_1_1Semiring.html#aa6226c8754c459b39344fee172d56dfa">extend</a>(suffix2latticeElement.second, suffixSum);</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;        <span class="keywordflow">if</span> (scoreId != Semiring::InvalidId) {</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;            suffixSum = semiring.clone(suffixSum);</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;            suffixSum-&gt;set(scoreId, bestScore_);</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;        }</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;        root-&gt;<a class="code" href="classFtl_1_1State.html#a94f0dd3c716d407c331aca8bf7c6faa0">newArc</a>(1, suffixSum, Fsa::Epsilon, Fsa::Epsilon);</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;    }</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;    <span class="comment">// add the n-1 &quot;detours&quot;</span></div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;    <span class="comment">// copy father prefix, add all disssenters, suffix - join asap</span></div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;    ConstArcPtrList dissenters;</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;    <span class="keywordflow">for</span> (PathIdList::const_iterator itPathId = validPathIds_.begin() + 1; itPathId != validPathIds_.end(); ++itPathId) {</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;        <span class="keyword">const</span> <a class="code" href="classFlf_1_1NBestBuilder_1_1Path.html">Path</a>&amp; path = paths_[*itPathId];</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;        <a class="code" href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a>(path.n != Path::InvalidNumber);</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;        dissenters.push_back(path.dissenter);</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;        u32 fatherPathId = path.fatherId;</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;        <span class="keywordflow">for</span> (;;) {</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;            <span class="keyword">const</span> <a class="code" href="classFlf_1_1NBestBuilder_1_1Path.html">Path</a>&amp; fatherPath = paths_[fatherPathId];</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;            <span class="keywordflow">if</span> (fatherPath.n == Path::InvalidNumber) {</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;                dissenters.push_back(fatherPath.dissenter);</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;                fatherPathId = fatherPath.fatherId;</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;            }</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;        }</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;        <span class="comment">// copy common prefix: father*</span></div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;        <a class="code" href="classFlf_1_1ScoresRef.html">ScoresRef</a>    sum               = semiring.one();</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;        <span class="keyword">const</span> <a class="code" href="classFtl_1_1State.html">State</a>* fatherSp          = s-&gt;fastState(paths_[fatherPathId].n);</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;        <a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> fatherInternalSid = lattice2internal[fatherSp-&gt;id()];</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;        <a class="code" href="classFtl_1_1State.html">State</a>*       sp                = <span class="keyword">new</span> <a class="code" href="namespaceFlf.html#a0d12349ba0b409cec1041b923ae4e9c4">State</a>(path.n);</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;        s-&gt;setState(sp);</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;        <span class="keywordflow">if</span> (sb) {</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;            <a class="code" href="classFlf_1_1Boundary.html">Boundary</a> boundary = sb-&gt;<a class="code" href="classFlf_1_1StaticBoundaries.html#adf1f88e4713b2a4a2d6209038e669359">get</a>(fatherSp-&gt;id());</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;            sb-&gt;<a class="code" href="classFlf_1_1StaticBoundaries.html#a50737c9ea7a9425388a78bd881c172ee">set</a>(sp-&gt;id(), boundary);</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;        }</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;        lattice2internal[path.n]  = fatherInternalSid;</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;        <a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> prefixEndSid = dissenters.back()-&gt;from;</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;        <span class="keywordflow">while</span> (fatherInternalSid != prefixEndSid) {</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;            <span class="keyword">const</span> <a class="code" href="structFlf_1_1Arc.html">Flf::Arc</a>&amp; a = *fatherSp-&gt;begin();</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;            sp-&gt;<a class="code" href="classFtl_1_1State.html#a94f0dd3c716d407c331aca8bf7c6faa0">newArc</a>(nextSid, a.weight(), a.input(), a.output());</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;            sum               = semiring.<a class="code" href="classFlf_1_1Semiring.html#aa6226c8754c459b39344fee172d56dfa">extend</a>(sum, a.weight());</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;            fatherSp          = s-&gt;fastState(a.target());</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;            fatherInternalSid = lattice2internal[fatherSp-&gt;id()];</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;            sp                = <span class="keyword">new</span> <a class="code" href="namespaceFlf.html#a0d12349ba0b409cec1041b923ae4e9c4">State</a>(nextSid++);</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;            s-&gt;setState(sp);</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;            <span class="keywordflow">if</span> (sb) {</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;                <a class="code" href="classFlf_1_1Boundary.html">Boundary</a> boundary = sb-&gt;<a class="code" href="classFlf_1_1StaticBoundaries.html#adf1f88e4713b2a4a2d6209038e669359">get</a>(fatherSp-&gt;id());</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;                sb-&gt;<a class="code" href="classFlf_1_1StaticBoundaries.html#a50737c9ea7a9425388a78bd881c172ee">set</a>(sp-&gt;id(), boundary);</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;            }</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;            lattice2internal.push_back(fatherInternalSid);</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;            verify_(lattice2internal[sp-&gt;id()] == fatherInternalSid);</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;        }</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;        <span class="comment">// add middle part: dissenter, (best*, dissenter)*</span></div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;        verify_(lattice2internal[sp-&gt;id()] == dissenters.back()-&gt;from);</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;        <span class="keywordflow">for</span> (ConstArcPtrList::const_reverse_iterator itDissenter = dissenters.rbegin(), endDissenter = dissenters.rend();;) {</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;            <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Arc.html">Arc</a>&amp; dissenter = **itDissenter;</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;            ++itDissenter;</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;            <a class="code" href="classCore_1_1Ref.html">ConstStateRef</a>   sr = l.getState(dissenter.from);</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;            <span class="keyword">const</span> <a class="code" href="structFlf_1_1Arc.html">Flf::Arc</a>&amp; a  = *(sr-&gt;begin() + dissenter.id);</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;            verify_(a.target() == dissenter.to);</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;            <span class="keywordflow">if</span> ((itDissenter == endDissenter) &amp;&amp; (suffix2lattice[dissenter.to].first != Fsa::InvalidStateId)) {</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;                std::pair&lt;Fsa::StateId, ScoresRef&gt;&amp; suffix2latticeElement = suffix2lattice[dissenter.to];</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;                sp-&gt;<a class="code" href="classFtl_1_1State.html#a94f0dd3c716d407c331aca8bf7c6faa0">newArc</a>(suffix2latticeElement.first, a.weight(), a.input(), a.output());</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;                sum = semiring.<a class="code" href="classFlf_1_1Semiring.html#aa6226c8754c459b39344fee172d56dfa">extend</a>(semiring.<a class="code" href="classFlf_1_1Semiring.html#aa6226c8754c459b39344fee172d56dfa">extend</a>(sum, a.weight()), suffix2latticeElement.second);</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;                sp  = 0;</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;            }</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;            sp-&gt;<a class="code" href="classFtl_1_1State.html#a94f0dd3c716d407c331aca8bf7c6faa0">newArc</a>(nextSid, a.weight(), a.input(), a.output());</div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;            sum = semiring.<a class="code" href="classFlf_1_1Semiring.html#aa6226c8754c459b39344fee172d56dfa">extend</a>(sum, a.weight());</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;            sp  = <span class="keyword">new</span> <a class="code" href="namespaceFlf.html#a0d12349ba0b409cec1041b923ae4e9c4">State</a>(nextSid++);</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;            s-&gt;setState(sp);</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;            <span class="keywordflow">if</span> (sb)</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;                sb-&gt;<a class="code" href="classFlf_1_1StaticBoundaries.html#a50737c9ea7a9425388a78bd881c172ee">set</a>(sp-&gt;id(), b.<a class="code" href="classFlf_1_1Boundaries.html#aa7e718e87f552ed1e7e6fbfb19d9f9f5">get</a>(dissenter.to));</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;            lattice2internal.push_back(dissenter.to);</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;            verify_(lattice2internal[sp-&gt;id()] == dissenter.to);</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;            <span class="keywordflow">if</span> (itDissenter == endDissenter)</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> internalSid = dissenter.to, internalTargetSid, endSid = (*itDissenter)-&gt;from;</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;                 internalSid != endSid; internalSid = internalTargetSid) {</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;                <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>&amp; node  = nodes_[internalSid];</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;                internalTargetSid = node.begin-&gt;to;</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;                <a class="code" href="classCore_1_1Ref.html">ConstStateRef</a> sr  = l.getState(internalSid);</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;                verify_(lattice2internal[sp-&gt;id()] == sr-&gt;id());</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;                <span class="keyword">const</span> <a class="code" href="structFlf_1_1Arc.html">Flf::Arc</a>&amp; a = *(sr-&gt;begin() + node.begin-&gt;id);</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;                verify_(a.target() == internalTargetSid);</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;                sp-&gt;<a class="code" href="classFtl_1_1State.html#a94f0dd3c716d407c331aca8bf7c6faa0">newArc</a>(nextSid, a.weight(), a.input(), a.output());</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;                sum = semiring.<a class="code" href="classFlf_1_1Semiring.html#aa6226c8754c459b39344fee172d56dfa">extend</a>(sum, a.weight());</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;                sp  = <span class="keyword">new</span> <a class="code" href="namespaceFlf.html#a0d12349ba0b409cec1041b923ae4e9c4">State</a>(nextSid++);</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;                s-&gt;setState(sp);</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;                <span class="keywordflow">if</span> (sb)</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;                    sb-&gt;<a class="code" href="classFlf_1_1StaticBoundaries.html#a50737c9ea7a9425388a78bd881c172ee">set</a>(sp-&gt;id(), b.<a class="code" href="classFlf_1_1Boundaries.html#aa7e718e87f552ed1e7e6fbfb19d9f9f5">get</a>(internalTargetSid));</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;                lattice2internal.push_back(internalTargetSid);</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;                verify_(lattice2internal[sp-&gt;id()] == internalTargetSid);</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;            }</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;        }</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;        <span class="comment">// add suffix part/ join suffix: best+</span></div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;        <span class="keywordflow">if</span> (sp) {</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;            verify_(lattice2internal[sp-&gt;id()] == dissenters.front()-&gt;to);</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;            <a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> firstSuffixSid = sp-&gt;id(), lastSuffixSid = 0;</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;            <a class="code" href="classFlf_1_1ScoresRef.html">ScoresRef</a>    suffixSum;</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a> internalSid = dissenters.front()-&gt;to, internalTargetSid;; internalSid = internalTargetSid) {</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;                <span class="keyword">const</span> <a class="code" href="structFlf_1_1NBestBuilder_1_1Node.html">Node</a>&amp; node  = nodes_[internalSid];</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;                internalTargetSid = node.begin-&gt;to;</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;                <a class="code" href="classCore_1_1Ref.html">ConstStateRef</a> sr  = l.getState(internalSid);</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;                verify_(lattice2internal[sp-&gt;id()] == sr-&gt;id());</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;                <span class="keyword">const</span> <a class="code" href="structFlf_1_1Arc.html">Flf::Arc</a>&amp; a = *(sr-&gt;begin() + node.begin-&gt;id);</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;                verify_(a.target() == internalTargetSid);</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;                suffix2lattice[internalSid]                              = std::make_pair(sp-&gt;id(), a.weight());</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;                std::pair&lt;Fsa::StateId, ScoresRef&gt;&amp; suffix2latticeTarget = suffix2lattice[internalTargetSid];</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;                <span class="keywordflow">if</span> (suffix2latticeTarget.first != Fsa::InvalidStateId) {</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;                    sp-&gt;<a class="code" href="classFtl_1_1State.html#a94f0dd3c716d407c331aca8bf7c6faa0">newArc</a>(suffix2latticeTarget.first, a.weight(), a.input(), a.output());</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;                    suffixSum     = suffix2latticeTarget.second;</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;                    lastSuffixSid = nextSid - 1;</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;                }</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;                sp-&gt;<a class="code" href="classFtl_1_1State.html#a94f0dd3c716d407c331aca8bf7c6faa0">newArc</a>(nextSid, a.weight(), a.input(), a.output());</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;                sp = <span class="keyword">new</span> <a class="code" href="namespaceFlf.html#a0d12349ba0b409cec1041b923ae4e9c4">State</a>(nextSid++);</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;                s-&gt;setState(sp);</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;                <span class="keywordflow">if</span> (sb)</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;                    sb-&gt;<a class="code" href="classFlf_1_1StaticBoundaries.html#a50737c9ea7a9425388a78bd881c172ee">set</a>(sp-&gt;id(), b.<a class="code" href="classFlf_1_1Boundaries.html#aa7e718e87f552ed1e7e6fbfb19d9f9f5">get</a>(internalTargetSid));</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;                lattice2internal.push_back(internalTargetSid);</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;                verify_(lattice2internal[sp-&gt;id()] == internalTargetSid);</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;                <span class="keywordflow">if</span> (!nodes_[internalTargetSid].hasArcs()) {</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;                    <a class="code" href="classCore_1_1Ref.html">ConstStateRef</a> sr = l.getState(internalTargetSid);</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;                    sp-&gt;setFinal(sr-&gt;weight());</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;                    suffix2lattice[internalTargetSid] = std::make_pair(sp-&gt;id(), sr-&gt;weight());</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;                    suffixSum                         = sr-&gt;weight();</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;                    lastSuffixSid                     = nextSid - 2;</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;                }</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;            }</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;            <span class="keywordflow">for</span> (u32 suffixSid = lastSuffixSid; suffixSid &gt;= firstSuffixSid; --suffixSid) {</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;                std::pair&lt;Fsa::StateId, ScoresRef&gt;&amp; suffix2latticeElement = suffix2lattice[lattice2internal[suffixSid]];</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;                suffixSum = suffix2latticeElement.second = semiring.<a class="code" href="classFlf_1_1Semiring.html#aa6226c8754c459b39344fee172d56dfa">extend</a>(suffix2latticeElement.second, suffixSum);</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;            }</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;            sum = semiring.<a class="code" href="classFlf_1_1Semiring.html#aa6226c8754c459b39344fee172d56dfa">extend</a>(sum, suffixSum);</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;        }</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;        <span class="keywordflow">if</span> (scoreId != Semiring::InvalidId) {</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;            sum = semiring.clone(sum);</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;            sum-&gt;set(scoreId, bestScore_ + path.detourScore);</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;        }</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;        root-&gt;<a class="code" href="classFtl_1_1State.html#a94f0dd3c716d407c331aca8bf7c6faa0">newArc</a>(path.n, sum, Fsa::Epsilon, Fsa::Epsilon);</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;        <span class="comment">// clean up</span></div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;        dissenters.clear();</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;    }</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classCore_1_1Ref.html">StaticLatticeRef</a>(s);</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;}</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;<span class="keywordtype">void</span> NBestBuilder::dumpStatistics(<a class="code" href="classCore_1_1XmlWriter.html">Core::XmlWriter</a>&amp; xml) {</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;    xml &lt;&lt; <a class="code" href="classCore_1_1XmlFull.html">Core::XmlFull</a>(<span class="stringliteral">&quot;best-paths&quot;</span>, validPathIds_.size())</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;        &lt;&lt; <a class="code" href="classCore_1_1XmlFull.html">Core::XmlFull</a>(<span class="stringliteral">&quot;searched-paths&quot;</span>, paths_.size())</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;        &lt;&lt; <a class="code" href="classCore_1_1XmlFull.html">Core::XmlFull</a>(<span class="stringliteral">&quot;unique-paths&quot;</span>, nUniquePaths_)</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;        &lt;&lt; <a class="code" href="classCore_1_1XmlFull.html">Core::XmlFull</a>(<span class="stringliteral">&quot;ratio&quot;</span>, f32(paths_.size()) / f32(nUniquePaths_));</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;}</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span></div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span></div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;<a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a> nbest(<a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a> l, u32 n, <span class="keywordtype">bool</span> removeDuplicates, NBestAlgorithm algo) {</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;    <span class="keywordtype">bool</span> ignoreNonWords = <span class="keyword">false</span>;</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;    <span class="keywordflow">if</span> (removeDuplicates)</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;        <span class="keywordflow">switch</span> (Lexicon::us()-&gt;alphabetId(l-&gt;getInputAlphabet())) {</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;            <span class="keywordflow">case</span> Lexicon::LemmaAlphabetId:</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;            <span class="keywordflow">case</span> Lexicon::LemmaPronunciationAlphabetId:</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;                ignoreNonWords = <span class="keyword">true</span>;</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;            <span class="keywordflow">default</span>:;</div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;        }</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;    <span class="keywordflow">switch</span> (algo) {</div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;        <span class="keywordflow">case</span> Eppstein: {</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;            <a class="code" href="classFlf_1_1NBestBuilder.html">NBestBuilder</a> builder(l, n, removeDuplicates, ignoreNonWords);</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;            <span class="keywordflow">return</span> builder.lattice();</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;        }</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;        <span class="keywordflow">case</span> Mori: {</div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;            <span class="keywordflow">if</span> (removeDuplicates) {</div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;                <span class="keywordflow">if</span> (ignoreNonWords)</div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;                    l = applyOneToOneLabelMap(</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;                            l, LabelMap::createNonWordToEpsilonMap(</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;                                       Lexicon::us()-&gt;alphabetId(l-&gt;getInputAlphabet())));</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;                l = fastRemoveEpsilons(projectOutput(l));</div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;                l = cache(l, 75000);</div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;                l = <a class="code" href="namespaceFlf.html#ab1d56435eed73227b380c303d12bb9a9">determinize</a>(l);</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;                l = cache(l, 75000);</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;            }</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;            <span class="keywordflow">return</span> Flf::nbest(l, n);</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;        }</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;            <a class="code" href="Assertions_8hh.html#a53abbe0948aa9d052aecd95684b68190">defect</a>();</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a>();</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;    }</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;}</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span></div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span></div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;<span class="keyword">namespace </span>{</div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;<span class="keyword">const</span> <a class="code" href="classCore_1_1Choice.html">Core::Choice</a> choiceNBestAlgorithm(</div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;        <span class="stringliteral">&quot;eppstein&quot;</span>, Eppstein,</div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;        <span class="stringliteral">&quot;more&quot;</span>, Mori,</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;        Core::Choice::endMark());</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;<span class="keyword">const</span> <a class="code" href="classCore_1_1ParameterString.html">Core::ParameterString</a> paramNBestAlgorithm(</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;        <span class="stringliteral">&quot;algorithm&quot;</span>,</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;        <span class="stringliteral">&quot;n-best algorithm&quot;</span>,</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;        <span class="stringliteral">&quot;eppstein&quot;</span>);</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;NBestAlgorithm getNBestAlgorithm(<span class="keyword">const</span> <a class="code" href="classCore_1_1Configuration.html">Core::Configuration</a>&amp; config) {</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;    Core::Choice::Value nBestChoice = choiceNBestAlgorithm[paramNBestAlgorithm(config)];</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;    <span class="keywordflow">if</span> (nBestChoice == Core::Choice::IllegalValue)</div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;        <a class="code" href="classCore_1_1Application.html#a790e82fbb0979b78ff1dcba7a43e924e">Core::Application::us</a>()-&gt;<a class="code" href="classCore_1_1Component.html#a9b917f1da1be1a009af6fec706003bee">criticalError</a>(</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;                <span class="stringliteral">&quot;NBestAlgorithm: Unknown algorithm \&quot;%s\&quot;&quot;</span>,</div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;                paramNBestAlgorithm(config).c_str());</div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;    <span class="keywordflow">return</span> NBestAlgorithm(nBestChoice);</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;}</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;}  <span class="comment">// namespace</span></div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;</div><div class="line"><a name="l01086"></a><span class="lineno"><a class="line" href="classFlf_1_1NBestNode.html"> 1086</a></span>&#160;<span class="keyword">class </span><a class="code" href="classFlf_1_1NBestNode.html">NBestNode</a> : <span class="keyword">public</span> <a class="code" href="classFlf_1_1FilterNode.html">FilterNode</a> {</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;    <span class="keyword">typedef</span> <a class="code" href="classFlf_1_1FilterNode.html">FilterNode</a> <a class="code" href="classCore_1_1Configurable.html">Precursor</a>;</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a>    paramN;</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>   paramRemoveDuplicates;</div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a>   paramIgnoreNonWords;</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classCore_1_1ParameterString.html">Core::ParameterString</a> paramScoreKey;</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;    <a class="code" href="classCore_1_1XmlChannel.html">Core::XmlChannel</a> statisticsChannel_;</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;    u32              n_;</div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;    <span class="keywordtype">bool</span>             removeDuplicates_;</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;    <span class="keywordtype">bool</span>             ignoreNonWords_;</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;    Key              scoreKey_;</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;    <a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a> nBestL_;</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;    <span class="keywordtype">bool</span>            isValid_;</div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;<span class="keyword">protected</span>:</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;    <span class="keyword">virtual</span> <a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a> filter(<a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a> l) {</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;        <span class="keywordflow">if</span> (!isValid_) {</div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;            ScoreId scoreId = Semiring::InvalidId;</div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;            <span class="keywordflow">if</span> (!scoreKey_.empty()) {</div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;                scoreId = l-&gt;semiring()-&gt;id(scoreKey_);</div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;                <span class="keywordflow">if</span> (scoreId == Semiring::InvalidId)</div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;                    criticalError(</div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;                            <span class="stringliteral">&quot;Semiring \&quot;%s\&quot; has no dimension \&quot;%s\&quot;.&quot;</span>,</div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;                            l-&gt;semiring()-&gt;name().c_str(), scoreKey_.c_str());</div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;            }</div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;            <a class="code" href="classFlf_1_1NBestBuilder.html">NBestBuilder</a> builder(l, n_, removeDuplicates_, ignoreNonWords_);</div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;            nBestL_ = builder.lattice(scoreId);</div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;            statisticsChannel_ &lt;&lt; <a class="code" href="classCore_1_1XmlOpen.html">Core::XmlOpen</a>(<span class="stringliteral">&quot;statistics&quot;</span>) + <a class="code" href="classCore_1_1XmlAttribute.html">Core::XmlAttribute</a>(<span class="stringliteral">&quot;component&quot;</span>, name);</div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;            builder.dumpStatistics(statisticsChannel_);</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;            statisticsChannel_ &lt;&lt; <a class="code" href="classCore_1_1XmlClose.html">Core::XmlClose</a>(<span class="stringliteral">&quot;statistics&quot;</span>);</div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;            isValid_ = <span class="keyword">true</span>;</div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;        }</div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;        <span class="keywordflow">return</span> nBestL_;</div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;    }</div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;</div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;    <a class="code" href="classFlf_1_1NBestNode.html">NBestNode</a>(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <a class="code" href="classCore_1_1Configuration.html">Core::Configuration</a>&amp; config)</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;            : Precursor(name, config), statisticsChannel_(config, <span class="stringliteral">&quot;statistics&quot;</span>) {}</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;    <span class="keyword">virtual</span> ~<a class="code" href="classFlf_1_1NBestNode.html">NBestNode</a>() {}</div><div class="line"><a name="l01130"></a><span class="lineno"><a class="line" href="classFlf_1_1NBestNode.html#a97ed89ba4b1bfe84fb9181b2803e23de"> 1130</a></span>&#160;    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFlf_1_1NBestNode.html#a97ed89ba4b1bfe84fb9181b2803e23de">init</a>(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; arguments) {</div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;        n_ = paramN(config);</div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;        <a class="code" href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a>(n_ &gt;= 1);</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;        <span class="keywordflow">if</span> (n_ == 1)</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;            warning(<span class="stringliteral">&quot;N-Best list generation is called with n=1; did you forget to specify n?&quot;</span>);</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;        removeDuplicates_            = paramRemoveDuplicates(config);</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;        ignoreNonWords_              = paramIgnoreNonWords(config);</div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;        scoreKey_                    = paramScoreKey(config);</div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;        <a class="code" href="classCore_1_1Component_1_1Message.html">Core::Component::Message</a> msg = <a class="code" href="namespaceFlf.html#ab50c9673c0ec46e337c4f4a1ff450091">log</a>();</div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;        msg &lt;&lt; <span class="stringliteral">&quot;NBest configuration:\n&quot;</span></div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;            &lt;&lt; <span class="stringliteral">&quot;- n=&quot;</span> &lt;&lt; n_ &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;        <span class="keywordflow">if</span> (removeDuplicates_)</div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;            msg &lt;&lt; <span class="stringliteral">&quot;- Remove duplicates from n-best list.\n&quot;</span>;</div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;        <span class="keywordflow">if</span> (ignoreNonWords_)</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;            msg &lt;&lt; <span class="stringliteral">&quot;- Ignore non words, i.e. treat two hypothesis as duplicates, if they only differ in non words.\n&quot;</span>;</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;        <span class="keywordflow">if</span> (!scoreKey_.empty())</div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;            msg &lt;&lt; <span class="stringliteral">&quot;- Store hypotheses score in dimension \&quot;&quot;</span> &lt;&lt; scoreKey_ &lt;&lt; <span class="stringliteral">&quot;\&quot;.\n&quot;</span>;</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;        isValid_ = <span class="keyword">false</span>;</div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;    }</div><div class="line"><a name="l01149"></a><span class="lineno"><a class="line" href="classFlf_1_1NBestNode.html#a62ad563ef8bc25e6b2ff04fb40092e58"> 1149</a></span>&#160;    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFlf_1_1NBestNode.html#a62ad563ef8bc25e6b2ff04fb40092e58">sync</a>() {</div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;        nBestL_.<a class="code" href="classCore_1_1Ref.html#abd19893817c14e95b73ea0c0471b7e74">reset</a>();</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;        isValid_ = <span class="keyword">false</span>;</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;    }</div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;};</div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;<span class="keyword">const</span> <a class="code" href="classCore_1_1ParameterInt.html">Core::ParameterInt</a> NBestNode::paramN(</div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;        <span class="stringliteral">&quot;n&quot;</span>,</div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;        <span class="stringliteral">&quot;(up to) n best hypothesis&quot;</span>,</div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;        1);</div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;<span class="keyword">const</span> <a class="code" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a> NBestNode::paramRemoveDuplicates(</div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;        <span class="stringliteral">&quot;remove-duplicates&quot;</span>,</div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;        <span class="stringliteral">&quot;remove duplicate pathes from the n-best list&quot;</span>,</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;        <span class="keyword">true</span>);</div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;<span class="keyword">const</span> <a class="code" href="classCore_1_1ParameterBool.html">Core::ParameterBool</a> NBestNode::paramIgnoreNonWords(</div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;        <span class="stringliteral">&quot;ignore-non-words&quot;</span>,</div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;        <span class="stringliteral">&quot;ignore non words, i.e. treat two pathes as duplicates, if they only differ in non words&quot;</span>,</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;        <span class="keyword">true</span>);</div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;<span class="keyword">const</span> <a class="code" href="classCore_1_1ParameterString.html">Core::ParameterString</a> NBestNode::paramScoreKey(</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;        <span class="stringliteral">&quot;score-key&quot;</span>,</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;        <span class="stringliteral">&quot;store path score in this dimension&quot;</span>,</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;        <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;</div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;<a class="code" href="classCore_1_1Ref.html">NodeRef</a> createNBestNode(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <a class="code" href="classCore_1_1Configuration.html">Core::Configuration</a>&amp; config) {</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classCore_1_1Ref.html">NodeRef</a>(<span class="keyword">new</span> <a class="code" href="classFlf_1_1NBestNode.html">NBestNode</a>(name, config));</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;}</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span></div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span></div><div class="line"><a name="l01177"></a><span class="lineno"><a class="line" href="classFlf_1_1SelectNBestNode.html"> 1177</a></span>&#160;<span class="keyword">class </span><a class="code" href="classFlf_1_1SelectNBestNode.html">SelectNBestNode</a> : <span class="keyword">public</span> <a class="code" href="classFlf_1_1Node.html">Node</a> {</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;    <a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a> nBest_;</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;    <a class="code" href="classCore_1_1Ref.html">ConstStateRef</a>   initial_;</div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;    u32             n_;</div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;    <a class="code" href="classFlf_1_1SelectNBestNode.html">SelectNBestNode</a>(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <a class="code" href="classCore_1_1Configuration.html">Core::Configuration</a>&amp; config)</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;            : <a class="code" href="classFlf_1_1Node.html">Node</a>(name, config) {}</div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;    <span class="keyword">virtual</span> ~<a class="code" href="classFlf_1_1SelectNBestNode.html">SelectNBestNode</a>() {}</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;</div><div class="line"><a name="l01188"></a><span class="lineno"><a class="line" href="classFlf_1_1SelectNBestNode.html#a46cfbd20d67afb84ce7d40157c4cb472"> 1188</a></span>&#160;    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFlf_1_1SelectNBestNode.html#a46cfbd20d67afb84ce7d40157c4cb472">init</a>(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; arguments) {</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;        <span class="keywordflow">if</span> (!connected(0))</div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;            criticalError(<span class="stringliteral">&quot;N-best lattice at port 0 required.&quot;</span>);</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;        n_ = 0;</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;    }</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;</div><div class="line"><a name="l01194"></a><span class="lineno"><a class="line" href="classFlf_1_1SelectNBestNode.html#a710f247ec1a8ee62b742cb635b2397cb"> 1194</a></span>&#160;    <span class="keyword">virtual</span> <a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a> <a class="code" href="classFlf_1_1SelectNBestNode.html#a710f247ec1a8ee62b742cb635b2397cb">sendLattice</a>(Port to) {</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;        <span class="keywordflow">if</span> (!nBest_) {</div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;            nBest_ = requestLattice(0);</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;            <span class="keywordflow">if</span> (nBest_) {</div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;                initial_ = nBest_-&gt;getState(nBest_-&gt;initialStateId());</div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;                n_       = initial_-&gt;nArcs();</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;            }</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;                n_ = 0;</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;        }</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;        <span class="keywordflow">if</span> (to &lt; n_) {</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;            <a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a> l = <a class="code" href="namespaceFlf.html#a66a2b49849e3db63d618b432da7bcce6">partial</a>(nBest_, (initial_-&gt;begin() + to)-&gt;target());</div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;            l-&gt;addProperties(Fsa::PropertyAcyclic | Fsa::PropertyLinear);</div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;            <span class="keywordflow">return</span> l;</div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;        }</div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a>();</div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;    }</div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;</div><div class="line"><a name="l01213"></a><span class="lineno"><a class="line" href="classFlf_1_1SelectNBestNode.html#ad06f8011299ce57d1ff3749d55fef638"> 1213</a></span>&#160;    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFlf_1_1SelectNBestNode.html#ad06f8011299ce57d1ff3749d55fef638">sync</a>() {</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;        nBest_.<a class="code" href="classCore_1_1Ref.html#abd19893817c14e95b73ea0c0471b7e74">reset</a>();</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;        initial_.<a class="code" href="classCore_1_1Ref.html#abd19893817c14e95b73ea0c0471b7e74">reset</a>();</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;        n_ = 0;</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;    }</div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;};</div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;<a class="code" href="classCore_1_1Ref.html">NodeRef</a> createSelectNBestNode(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <a class="code" href="classCore_1_1Configuration.html">Core::Configuration</a>&amp; config) {</div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classCore_1_1Ref.html">NodeRef</a>(<span class="keyword">new</span> <a class="code" href="classFlf_1_1SelectNBestNode.html">SelectNBestNode</a>(name, config));</div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;}</div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span></div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;</div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span></div><div class="line"><a name="l01225"></a><span class="lineno"><a class="line" href="classFlf_1_1DumpNBestNode.html"> 1225</a></span>&#160;<span class="keyword">class </span><a class="code" href="classFlf_1_1DumpNBestNode.html">DumpNBestNode</a> : <span class="keyword">public</span> <a class="code" href="classFlf_1_1FilterNode.html">FilterNode</a> {</div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;    <span class="keyword">typedef</span> <a class="code" href="classFlf_1_1FilterNode.html">FilterNode</a> <a class="code" href="classCore_1_1Configurable.html">Precursor</a>;</div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;</div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classCore_1_1ParameterStringVector.html">Core::ParameterStringVector</a> paramScoreKeys;</div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;</div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;    <a class="code" href="classCore_1_1Channel.html">Core::Channel</a> dump_;</div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;    KeyList       scoreKeys_;</div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;</div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;<span class="keyword">protected</span>:</div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;    <span class="keywordtype">void</span> dumpNBest(<a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a> l, std::ostream&amp; os) {</div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;        printSegmentHeader(os, connected(1) ? requestSegment(1) : <a class="code" href="classCore_1_1Ref.html">ConstSegmentRef</a>(), <span class="stringliteral">&quot;# &quot;</span>);</div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;        <span class="keywordflow">if</span> (!l || (l-&gt;initialStateId() == Fsa::InvalidStateId)) {</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;# n=0&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;            <span class="keywordflow">return</span>;</div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;        }</div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;        <a class="code" href="classCore_1_1Ref.html">Fsa::ConstAlphabetRef</a> alphabet = l-&gt;getInputAlphabet();</div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;        <a class="code" href="classCore_1_1Ref.html">ConstSemiringRef</a>      semiring = l-&gt;semiring();</div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;        <a class="code" href="classCore_1_1Vector.html">ScoreIdList</a>           scoreIds;</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;        <span class="keywordflow">if</span> (scoreKeys_.empty()) {</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;            scoreIds.resize(semiring-&gt;size());</div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;            <span class="keywordflow">for</span> (ScoreId scoreId = 0; scoreId &lt; semiring-&gt;size(); ++scoreId)</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;                scoreIds[scoreId] = scoreId;</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;        }</div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;        <span class="keywordflow">else</span> {</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;            <span class="keywordflow">for</span> (KeyList::const_iterator itKey = scoreKeys_.begin(); itKey != scoreKeys_.end(); ++itKey) {</div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;                scoreIds.push_back(semiring-&gt;id(*itKey));</div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;                <span class="keywordflow">if</span> (scoreIds.back() == Semiring::InvalidId)</div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;                    criticalError(<span class="stringliteral">&quot;DumpTracebackNode: Dimension \&quot;%s\&quot; does not exist.&quot;</span>,</div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;                                  itKey-&gt;c_str());</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;            }</div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;        }</div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;        <a class="code" href="classCore_1_1Ref.html">ConstStateRef</a> begin = l-&gt;getState(l-&gt;initialStateId());</div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;        os &lt;&lt; <span class="stringliteral">&quot;# n=&quot;</span> &lt;&lt; begin-&gt;nArcs() &lt;&lt; std::endl;</div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;        os &lt;&lt; <span class="stringliteral">&quot;# &quot;</span>;</div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;        <span class="keywordflow">for</span> (ScoreIdList::const_iterator itId = scoreIds.begin(); itId != scoreIds.end(); ++itId)</div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;            os &lt;&lt; semiring-&gt;key(*itId) &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; semiring-&gt;scale(*itId) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;</div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;        os &lt;&lt; <span class="stringliteral">&quot;N&quot;</span>;</div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;        os &lt;&lt; std::endl;</div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;        std::vector&lt;Fsa::LabelId&gt; labels;</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;        <span class="keywordflow">for</span> (State::const_iterator a = begin-&gt;begin(), a_end = begin-&gt;end(); a != a_end; ++a) {</div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;            <a class="code" href="classFlf_1_1ScoresRef.html">ScoresRef</a>             scores = a-&gt;weight();</div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;            State::const_iterator arc    = a;</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;            <span class="keywordflow">for</span> (;;) {</div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;                <span class="keywordflow">if</span> (arc-&gt;input() != Fsa::Epsilon)</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;                    labels.push_back(arc-&gt;input());</div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;                <a class="code" href="classCore_1_1Ref.html">ConstStateRef</a> sr = l-&gt;getState(arc-&gt;target());</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;                <span class="keywordflow">if</span> (sr-&gt;hasArcs()) {</div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;                    <span class="keywordflow">if</span> (sr-&gt;nArcs() &gt; 1)</div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;                        criticalError(<span class="stringliteral">&quot;DumpNBestNode: \&quot;%s\&quot; is not an n-best-list&quot;</span>,</div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;                                      l-&gt;describe().c_str());</div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;                    arc = sr-&gt;begin();</div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;                }</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;                <span class="keywordflow">else</span></div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;            }</div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;            <span class="keywordflow">for</span> (ScoreIdList::const_iterator itId = scoreIds.begin(); itId != scoreIds.end(); ++itId)</div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;                os &lt;&lt; <a class="code" href="namespaceCore.html#a5bbc07edba36ef5b3d10aaa159c7cb25">Core::form</a>(<span class="stringliteral">&quot; %.4f&quot;</span>, -scores-&gt;get(*itId)) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;</div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;            os &lt;&lt; labels.size() &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;</div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;&lt;s&gt;&quot;</span>;</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;            <span class="keywordflow">for</span> (std::vector&lt;Fsa::LabelId&gt;::const_iterator it = labels.begin(), it_end = labels.end(); it != it_end; ++it)</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;                os &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; alphabet-&gt;symbol(*it);</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot; &lt;/s&gt;&quot;</span>;</div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;            os &lt;&lt; std::endl;</div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;            labels.clear();</div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;        }</div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;        os &lt;&lt; std::endl;</div><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;    }</div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;    <span class="keyword">virtual</span> <a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a> filter(<a class="code" href="classCore_1_1Ref.html">ConstLatticeRef</a> l) {</div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;        <span class="keywordflow">if</span> (dump_.<a class="code" href="classCore_1_1Channel.html#abd7e750d378796adf133a025b9c2a510">isOpen</a>())</div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;            dumpNBest(l, dump_);</div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;            dumpNBest(l, clog());</div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;        <span class="keywordflow">return</span> l;</div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;    }</div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;</div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;    <a class="code" href="classFlf_1_1DumpNBestNode.html">DumpNBestNode</a>(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <a class="code" href="classCore_1_1Configuration.html">Core::Configuration</a>&amp; config)</div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;            : Precursor(name, config), dump_(config, <span class="stringliteral">&quot;dump&quot;</span>) {}</div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;    <span class="keyword">virtual</span> ~<a class="code" href="classFlf_1_1DumpNBestNode.html">DumpNBestNode</a>() {}</div><div class="line"><a name="l01306"></a><span class="lineno"><a class="line" href="classFlf_1_1DumpNBestNode.html#aba9d2c5ac22bc7aca561fefc8115568e"> 1306</a></span>&#160;    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFlf_1_1DumpNBestNode.html#aba9d2c5ac22bc7aca561fefc8115568e">init</a>(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; arguments) {</div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;        scoreKeys_ = paramScoreKeys(config);</div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;    }</div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;};</div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;<span class="keyword">const</span> <a class="code" href="classCore_1_1ParameterStringVector.html">Core::ParameterStringVector</a> DumpNBestNode::paramScoreKeys(</div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;        <span class="stringliteral">&quot;scores&quot;</span>,</div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;        <span class="stringliteral">&quot;dimension of scores to be dumped; default is all scores&quot;</span>,</div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;        <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;<a class="code" href="classCore_1_1Ref.html">NodeRef</a> createDumpNBestNode(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <a class="code" href="classCore_1_1Configuration.html">Core::Configuration</a>&amp; config) {</div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classCore_1_1Ref.html">NodeRef</a>(<span class="keyword">new</span> <a class="code" href="classFlf_1_1DumpNBestNode.html">DumpNBestNode</a>(name, config));</div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;}</div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;<span class="comment">// -------------------------------------------------------------------------</span></div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;</div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;}  <span class="comment">// namespace Flf</span></div><div class="ttc" id="classCore_1_1ParameterInt_html"><div class="ttname"><a href="classCore_1_1ParameterInt.html">Core::ParameterInt</a></div><div class="ttdoc">Declaration class for integer valued parameters. </div><div class="ttdef"><b>Definition:</b> <a href="Parameter_8hh_source.html#l00229">Parameter.hh:229</a></div></div>
<div class="ttc" id="classFtl_1_1StaticAutomaton_html"><div class="ttname"><a href="classFtl_1_1StaticAutomaton.html">Ftl::StaticAutomaton</a></div><div class="ttdef"><b>Definition:</b> <a href="tStatic_8hh_source.html#l00024">tStatic.hh:24</a></div></div>
<div class="ttc" id="namespaceFsa_html_ae313d991029d7ed22a89b8a66395fdcf"><div class="ttname"><a href="namespaceFsa.html#ae313d991029d7ed22a89b8a66395fdcf">Fsa::StateId</a></div><div class="ttdeci">u32 StateId</div><div class="ttdoc">state indices and tags </div><div class="ttdef"><b>Definition:</b> <a href="Fsa_2Types_8hh_source.html#l00026">Fsa/Types.hh:26</a></div></div>
<div class="ttc" id="namespaceLattice_html"><div class="ttname"><a href="namespaceLattice.html">Lattice</a></div><div class="ttdoc">Copyright 2020 RWTH Aachen University. </div><div class="ttdef"><b>Definition:</b> <a href="Accumulator_8hh_source.html#l00025">Accumulator.hh:25</a></div></div>
<div class="ttc" id="classFlf_1_1StaticBoundaries_html"><div class="ttname"><a href="classFlf_1_1StaticBoundaries.html">Flf::StaticBoundaries</a></div><div class="ttdef"><b>Definition:</b> <a href="Boundaries_8hh_source.html#l00183">Boundaries.hh:183</a></div></div>
<div class="ttc" id="structFlf_1_1Arc_html"><div class="ttname"><a href="structFlf_1_1Arc.html">Flf::Arc</a></div><div class="ttdoc">Lattice arc. </div><div class="ttdef"><b>Definition:</b> <a href="Flf_2FlfCore_2Lattice_8hh_source.html#l00034">Flf/FlfCore/Lattice.hh:34</a></div></div>
<div class="ttc" id="classCore_1_1XmlChannel_html"><div class="ttname"><a href="classCore_1_1XmlChannel.html">Core::XmlChannel</a></div><div class="ttdoc">Configurable XML output stream. </div><div class="ttdef"><b>Definition:</b> <a href="Channel_8hh_source.html#l00137">Channel.hh:137</a></div></div>
<div class="ttc" id="namespaceFlf_html"><div class="ttname"><a href="namespaceFlf.html">Flf</a></div><div class="ttdoc">Copyright 2020 RWTH Aachen University. </div><div class="ttdef"><b>Definition:</b> <a href="Flf_2Archive_8cc_source.html#l00058">Flf/Archive.cc:58</a></div></div>
<div class="ttc" id="namespaceFlf_html_a0d12349ba0b409cec1041b923ae4e9c4"><div class="ttname"><a href="namespaceFlf.html#a0d12349ba0b409cec1041b923ae4e9c4">Flf::State</a></div><div class="ttdeci">Ftl::State&lt; Arc &gt; State</div><div class="ttdoc">Lattice state. </div><div class="ttdef"><b>Definition:</b> <a href="Flf_2FlfCore_2Lattice_8hh_source.html#l00083">Flf/FlfCore/Lattice.hh:83</a></div></div>
<div class="ttc" id="classCore_1_1Choice_html"><div class="ttname"><a href="classCore_1_1Choice.html">Core::Choice</a></div><div class="ttdoc">Choice class. </div><div class="ttdef"><b>Definition:</b> <a href="Choice_8hh_source.html#l00033">Choice.hh:33</a></div></div>
<div class="ttc" id="classFlf_1_1NBestNode_html_a97ed89ba4b1bfe84fb9181b2803e23de"><div class="ttname"><a href="classFlf_1_1NBestNode.html#a97ed89ba4b1bfe84fb9181b2803e23de">Flf::NBestNode::init</a></div><div class="ttdeci">virtual void init(const std::vector&lt; std::string &gt; &amp;arguments)</div><div class="ttdoc">init, good, pull, and finalize are making up the used network protocol. </div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l01130">NBest.cc:1130</a></div></div>
<div class="ttc" id="classCore_1_1Application_html_a790e82fbb0979b78ff1dcba7a43e924e"><div class="ttname"><a href="classCore_1_1Application.html#a790e82fbb0979b78ff1dcba7a43e924e">Core::Application::us</a></div><div class="ttdeci">static Application * us()</div><div class="ttdoc">Get the global instance of the application (Singleton) </div><div class="ttdef"><b>Definition:</b> <a href="Application_8hh_source.html#l00127">Application.hh:127</a></div></div>
<div class="ttc" id="classFlf_1_1NBestBuilder_html"><div class="ttname"><a href="classFlf_1_1NBestBuilder.html">Flf::NBestBuilder</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00300">NBest.cc:300</a></div></div>
<div class="ttc" id="classFlf_1_1Boundaries_html_a8483f33968c278b0f1e9e886fd98b297"><div class="ttname"><a href="classFlf_1_1Boundaries.html#a8483f33968c278b0f1e9e886fd98b297">Flf::Boundaries::valid</a></div><div class="ttdeci">virtual bool valid() const =0</div><div class="ttdoc">false, if the lattice provides no boundaries </div></div>
<div class="ttc" id="classFlf_1_1SelectNBestNode_html_a46cfbd20d67afb84ce7d40157c4cb472"><div class="ttname"><a href="classFlf_1_1SelectNBestNode.html#a46cfbd20d67afb84ce7d40157c4cb472">Flf::SelectNBestNode::init</a></div><div class="ttdeci">virtual void init(const std::vector&lt; std::string &gt; &amp;arguments)</div><div class="ttdoc">init, good, pull, and finalize are making up the used network protocol. </div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l01188">NBest.cc:1188</a></div></div>
<div class="ttc" id="classCore_1_1Configuration_html"><div class="ttname"><a href="classCore_1_1Configuration.html">Core::Configuration</a></div><div class="ttdoc">Central configuration class. </div><div class="ttdef"><b>Definition:</b> <a href="Configuration_8hh_source.html#l00087">Configuration.hh:87</a></div></div>
<div class="ttc" id="classCore_1_1XmlFull_html"><div class="ttname"><a href="classCore_1_1XmlFull.html">Core::XmlFull</a></div><div class="ttdef"><b>Definition:</b> <a href="XmlStream_8hh_source.html#l00107">XmlStream.hh:107</a></div></div>
<div class="ttc" id="classFlf_1_1NBestBuilder_1_1Detour_html"><div class="ttname"><a href="classFlf_1_1NBestBuilder_1_1Detour.html">Flf::NBestBuilder::Detour</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00466">NBest.cc:466</a></div></div>
<div class="ttc" id="classCore_1_1XmlAttribute_html"><div class="ttname"><a href="classCore_1_1XmlAttribute.html">Core::XmlAttribute</a></div><div class="ttdoc">Streaming objects for XML output. </div><div class="ttdef"><b>Definition:</b> <a href="XmlStream_8hh_source.html#l00041">XmlStream.hh:41</a></div></div>
<div class="ttc" id="structFlf_1_1NBestBuilder_1_1DissenterList_1_1WeakOrder_html"><div class="ttname"><a href="structFlf_1_1NBestBuilder_1_1DissenterList_1_1WeakOrder.html">Flf::NBestBuilder::DissenterList::WeakOrder</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00417">NBest.cc:417</a></div></div>
<div class="ttc" id="classFlf_1_1Boundary_html"><div class="ttname"><a href="classFlf_1_1Boundary.html">Flf::Boundary</a></div><div class="ttdoc">State Boundary. </div><div class="ttdef"><b>Definition:</b> <a href="Boundaries_8hh_source.html#l00036">Boundaries.hh:36</a></div></div>
<div class="ttc" id="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node_html"><div class="ttname"><a href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Node.html">Flf::NBestBuilder::PrefixTree::Node</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00316">NBest.cc:316</a></div></div>
<div class="ttc" id="classCore_1_1Component_html_ac0806de1942b78cd299ea032c895db7a"><div class="ttname"><a href="classCore_1_1Component.html#ac0806de1942b78cd299ea032c895db7a">Core::Component::warning</a></div><div class="ttdeci">Message warning(const char *msg=0,...) const __attribute__((format(printf</div><div class="ttdoc">Print a warning message. </div><div class="ttdef"><b>Definition:</b> <a href="Core_2Component_8cc_source.html#l00225">Core/Component.cc:225</a></div></div>
<div class="ttc" id="namespaceFlf_html_ab50c9673c0ec46e337c4f4a1ff450091"><div class="ttname"><a href="namespaceFlf.html#ab50c9673c0ec46e337c4f4a1ff450091">Flf::log</a></div><div class="ttdeci">ConstLatticeRef log(ConstLatticeRef l, ScoreId id, Score c, RescoreMode rescoreMode)</div><div class="ttdoc">f(x,c) = c * log(x) </div><div class="ttdef"><b>Definition:</b> <a href="Rescore_8cc_source.html#l00301">Rescore.cc:301</a></div></div>
<div class="ttc" id="classFlf_1_1NBestNode_html"><div class="ttname"><a href="classFlf_1_1NBestNode.html">Flf::NBestNode</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l01086">NBest.cc:1086</a></div></div>
<div class="ttc" id="classFlf_1_1NBestBuilder_1_1DissenterList_html"><div class="ttname"><a href="classFlf_1_1NBestBuilder_1_1DissenterList.html">Flf::NBestBuilder::DissenterList</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00415">NBest.cc:415</a></div></div>
<div class="ttc" id="Assertions_8hh_html_aecaddce56c58fa07fb91249ea5de89ae"><div class="ttname"><a href="Assertions_8hh.html#aecaddce56c58fa07fb91249ea5de89ae">verify</a></div><div class="ttdeci">#define verify(expr)</div><div class="ttdoc">Check assertion. </div><div class="ttdef"><b>Definition:</b> <a href="WeightedAccumulator_8hh_source.html#l00310">WeightedAccumulator.hh:310</a></div></div>
<div class="ttc" id="classFlf_1_1StaticBoundaries_html_adf1f88e4713b2a4a2d6209038e669359"><div class="ttname"><a href="classFlf_1_1StaticBoundaries.html#adf1f88e4713b2a4a2d6209038e669359">Flf::StaticBoundaries::get</a></div><div class="ttdeci">virtual const Boundary &amp; get(Fsa::StateId sid) const </div><div class="ttdoc">return a specific boundary; for every sid a boundary is returned !valid(sid) =&gt; !get(sid).valid() </div><div class="ttdef"><b>Definition:</b> <a href="Boundaries_8hh_source.html#l00204">Boundaries.hh:204</a></div></div>
<div class="ttc" id="classFlf_1_1NBestNode_html_a62ad563ef8bc25e6b2ff04fb40092e58"><div class="ttname"><a href="classFlf_1_1NBestNode.html#a62ad563ef8bc25e6b2ff04fb40092e58">Flf::NBestNode::sync</a></div><div class="ttdeci">virtual void sync()</div><div class="ttdoc">Is called at every node before pull is called at the final nodes (see below); all nodes are initializ...</div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l01149">NBest.cc:1149</a></div></div>
<div class="ttc" id="structFlf_1_1BinaryLookUp_1_1ValueWeakOrder_html"><div class="ttname"><a href="structFlf_1_1BinaryLookUp_1_1ValueWeakOrder.html">Flf::BinaryLookUp::ValueWeakOrder</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00262">NBest.cc:262</a></div></div>
<div class="ttc" id="classFlf_1_1NBestBuilder_html_a854ece1f67ab26062d837917c68574d5"><div class="ttname"><a href="classFlf_1_1NBestBuilder.html#a854ece1f67ab26062d837917c68574d5">Flf::NBestBuilder::initialize</a></div><div class="ttdeci">void initialize(bool ignoreNonWords)</div><div class="ttdoc">Calculate. </div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00585">NBest.cc:585</a></div></div>
<div class="ttc" id="classCore_1_1Component_1_1Message_html"><div class="ttname"><a href="classCore_1_1Component_1_1Message.html">Core::Component::Message</a></div><div class="ttdoc">Helper class for generating error messages. </div><div class="ttdef"><b>Definition:</b> <a href="Core_2Component_8hh_source.html#l00178">Core/Component.hh:178</a></div></div>
<div class="ttc" id="classCore_1_1XmlOpen_html"><div class="ttname"><a href="classCore_1_1XmlOpen.html">Core::XmlOpen</a></div><div class="ttdef"><b>Definition:</b> <a href="XmlStream_8hh_source.html#l00057">XmlStream.hh:57</a></div></div>
<div class="ttc" id="classCore_1_1Ref_html"><div class="ttname"><a href="classCore_1_1Ref.html">Core::Ref</a></div><div class="ttdoc">Class template for smart pointers using intrusive reference-counting. </div><div class="ttdef"><b>Definition:</b> <a href="ReferenceCounting_8hh_source.html#l00029">ReferenceCounting.hh:29</a></div></div>
<div class="ttc" id="classCore_1_1Channel_html"><div class="ttname"><a href="classCore_1_1Channel.html">Core::Channel</a></div><div class="ttdoc">Configurable text output stream. </div><div class="ttdef"><b>Definition:</b> <a href="Channel_8hh_source.html#l00107">Channel.hh:107</a></div></div>
<div class="ttc" id="namespaceFlf_html_a66a2b49849e3db63d618b432da7bcce6"><div class="ttname"><a href="namespaceFlf.html#a66a2b49849e3db63d618b432da7bcce6">Flf::partial</a></div><div class="ttdeci">ConstLatticeRef partial(ConstLatticeRef l, Fsa::StateId initial)</div><div class="ttdoc">Miscellaneous functions. </div><div class="ttdef"><b>Definition:</b> <a href="Flf_2FlfCore_2Basic_8cc_source.html#l00497">Flf/FlfCore/Basic.cc:497</a></div></div>
<div class="ttc" id="classFlf_1_1ScoresRef_html"><div class="ttname"><a href="classFlf_1_1ScoresRef.html">Flf::ScoresRef</a></div><div class="ttdef"><b>Definition:</b> <a href="Flf_2FlfCore_2Weight_8hh_source.html#l00131">Flf/FlfCore/Weight.hh:131</a></div></div>
<div class="ttc" id="classFlf_1_1NBestBuilder_1_1PrefixTree_html"><div class="ttname"><a href="classFlf_1_1NBestBuilder_1_1PrefixTree.html">Flf::NBestBuilder::PrefixTree</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00302">NBest.cc:302</a></div></div>
<div class="ttc" id="classFlf_1_1Semiring_html_aa6226c8754c459b39344fee172d56dfa"><div class="ttname"><a href="classFlf_1_1Semiring.html#aa6226c8754c459b39344fee172d56dfa">Flf::Semiring::extend</a></div><div class="ttdeci">virtual ScoresRef extend(const ScoresRef &amp;a, const ScoresRef &amp;b) const </div><div class="ttdoc">extend, collect, invert, project, and compare </div><div class="ttdef"><b>Definition:</b> <a href="Flf_2FlfCore_2Semiring_8cc_source.html#l00182">Flf/FlfCore/Semiring.cc:182</a></div></div>
<div class="ttc" id="classFlf_1_1BinaryPriorityQueue_html"><div class="ttname"><a href="classFlf_1_1BinaryPriorityQueue.html">Flf::BinaryPriorityQueue</a></div><div class="ttdoc">Collection of fast hash functions taken from http://www.concentric.net/~Ttwang/tech/inthash.htm. </div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00152">NBest.cc:152</a></div></div>
<div class="ttc" id="classCore_1_1Configurable_html"><div class="ttname"><a href="classCore_1_1Configurable.html">Core::Configurable</a></div><div class="ttdoc">Abstract base class for run-time configurable classes. </div><div class="ttdef"><b>Definition:</b> <a href="Configurable_8hh_source.html#l00032">Configurable.hh:32</a></div></div>
<div class="ttc" id="classFlf_1_1SelectNBestNode_html_ad06f8011299ce57d1ff3749d55fef638"><div class="ttname"><a href="classFlf_1_1SelectNBestNode.html#ad06f8011299ce57d1ff3749d55fef638">Flf::SelectNBestNode::sync</a></div><div class="ttdeci">virtual void sync()</div><div class="ttdoc">Is called at every node before pull is called at the final nodes (see below); all nodes are initializ...</div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l01213">NBest.cc:1213</a></div></div>
<div class="ttc" id="classCore_1_1Component_html_a9b917f1da1be1a009af6fec706003bee"><div class="ttname"><a href="classCore_1_1Component.html#a9b917f1da1be1a009af6fec706003bee">Core::Component::criticalError</a></div><div class="ttdeci">Message criticalError(const char *msg=0,...) const __attribute__((format(printf</div><div class="ttdoc">Print a critical error message. </div><div class="ttdef"><b>Definition:</b> <a href="Core_2Component_8cc_source.html#l00255">Core/Component.cc:255</a></div></div>
<div class="ttc" id="classCore_1_1ParameterBool_html"><div class="ttname"><a href="classCore_1_1ParameterBool.html">Core::ParameterBool</a></div><div class="ttdoc">Declaration class for boolean valued parameters. </div><div class="ttdef"><b>Definition:</b> <a href="Parameter_8hh_source.html#l00215">Parameter.hh:215</a></div></div>
<div class="ttc" id="classFlf_1_1Node_html"><div class="ttname"><a href="classFlf_1_1Node.html">Flf::Node</a></div><div class="ttdef"><b>Definition:</b> <a href="Flf_2Network_8hh_source.html#l00055">Flf/Network.hh:55</a></div></div>
<div class="ttc" id="structFlf_1_1NBestBuilder_1_1DetourPtrWeakOrder_html"><div class="ttname"><a href="structFlf_1_1NBestBuilder_1_1DetourPtrWeakOrder.html">Flf::NBestBuilder::DetourPtrWeakOrder</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00535">NBest.cc:535</a></div></div>
<div class="ttc" id="classFlf_1_1NBestBuilder_1_1Path_html"><div class="ttname"><a href="classFlf_1_1NBestBuilder_1_1Path.html">Flf::NBestBuilder::Path</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00397">NBest.cc:397</a></div></div>
<div class="ttc" id="classFlf_1_1Boundaries_html"><div class="ttname"><a href="classFlf_1_1Boundaries.html">Flf::Boundaries</a></div><div class="ttdoc">State Boundaries; collection of state boundary. </div><div class="ttdef"><b>Definition:</b> <a href="Boundaries_8hh_source.html#l00117">Boundaries.hh:117</a></div></div>
<div class="ttc" id="classFlf_1_1Boundaries_html_aa7e718e87f552ed1e7e6fbfb19d9f9f5"><div class="ttname"><a href="classFlf_1_1Boundaries.html#aa7e718e87f552ed1e7e6fbfb19d9f9f5">Flf::Boundaries::get</a></div><div class="ttdeci">virtual const Boundary &amp; get(Fsa::StateId sid) const =0</div><div class="ttdoc">return a specific boundary; for every sid a boundary is returned !valid(sid) =&gt; !get(sid).valid() </div></div>
<div class="ttc" id="namespaceCore_html_a5bbc07edba36ef5b3d10aaa159c7cb25"><div class="ttname"><a href="namespaceCore.html#a5bbc07edba36ef5b3d10aaa159c7cb25">Core::form</a></div><div class="ttdeci">std::string form(const char *format,...) __attribute__((format(printf</div><div class="ttdoc">Formatted output conversion. </div><div class="ttdef"><b>Definition:</b> <a href="StringUtilities_8cc_source.html#l00106">StringUtilities.cc:106</a></div></div>
<div class="ttc" id="classCore_1_1ParameterString_html"><div class="ttname"><a href="classCore_1_1ParameterString.html">Core::ParameterString</a></div><div class="ttdoc">Declaration class for string parameters. </div><div class="ttdef"><b>Definition:</b> <a href="Parameter_8hh_source.html#l00277">Parameter.hh:277</a></div></div>
<div class="ttc" id="classCore_1_1ParameterStringVector_html"><div class="ttname"><a href="classCore_1_1ParameterStringVector.html">Core::ParameterStringVector</a></div><div class="ttdoc">Declaration class for string vector parameters. </div><div class="ttdef"><b>Definition:</b> <a href="Parameter_8hh_source.html#l00377">Parameter.hh:377</a></div></div>
<div class="ttc" id="classFtl_1_1State_html"><div class="ttname"><a href="classFtl_1_1State.html">Ftl::State</a></div><div class="ttdoc">The basic state class. </div><div class="ttdef"><b>Definition:</b> <a href="tAutomaton_8hh_source.html#l00198">tAutomaton.hh:198</a></div></div>
<div class="ttc" id="classFlf_1_1BinaryLookUp_html"><div class="ttname"><a href="classFlf_1_1BinaryLookUp.html">Flf::BinaryLookUp</a></div><div class="ttdoc">A reduced binary map (like std::map): </div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00254">NBest.cc:254</a></div></div>
<div class="ttc" id="Assertions_8hh_html_a53abbe0948aa9d052aecd95684b68190"><div class="ttname"><a href="Assertions_8hh.html#a53abbe0948aa9d052aecd95684b68190">defect</a></div><div class="ttdeci">#define defect()</div><div class="ttdoc">Program has a defect. </div><div class="ttdef"><b>Definition:</b> <a href="WeightedAccumulator_8hh_source.html#l00355">WeightedAccumulator.hh:355</a></div></div>
<div class="ttc" id="namespaceFsa_html_a726ff0749f3feaa2de2bbf61a526ef53"><div class="ttname"><a href="namespaceFsa.html#a726ff0749f3feaa2de2bbf61a526ef53">Fsa::LabelId</a></div><div class="ttdeci">s32 LabelId</div><div class="ttdoc">label indices and special symbols </div><div class="ttdef"><b>Definition:</b> <a href="Fsa_2Types_8hh_source.html#l00043">Fsa/Types.hh:43</a></div></div>
<div class="ttc" id="structFlf_1_1NBestBuilder_1_1Arc_html"><div class="ttname"><a href="structFlf_1_1NBestBuilder_1_1Arc.html">Flf::NBestBuilder::Arc</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00371">NBest.cc:371</a></div></div>
<div class="ttc" id="namespaceFlf_html_ab1d56435eed73227b380c303d12bb9a9"><div class="ttname"><a href="namespaceFlf.html#ab1d56435eed73227b380c303d12bb9a9">Flf::determinize</a></div><div class="ttdeci">ConstLatticeRef determinize(ConstLatticeRef l)</div><div class="ttdoc">determinization </div><div class="ttdef"><b>Definition:</b> <a href="Flf_2Determinize_8cc_source.html#l00024">Flf/Determinize.cc:24</a></div></div>
<div class="ttc" id="namespaceFlf_html_a0a26e6c3ee1ec080f86fd731346e5370"><div class="ttname"><a href="namespaceFlf.html#a0a26e6c3ee1ec080f86fd731346e5370">Flf::sortTopologically</a></div><div class="ttdeci">ConstStateMapRef sortTopologically(ConstLatticeRef l)</div><div class="ttdoc">Topological/Chronological Order. </div><div class="ttdef"><b>Definition:</b> <a href="Flf_2FlfCore_2Basic_8cc_source.html#l00331">Flf/FlfCore/Basic.cc:331</a></div></div>
<div class="ttc" id="classFtl_1_1State_html_a94f0dd3c716d407c331aca8bf7c6faa0"><div class="ttname"><a href="classFtl_1_1State.html#a94f0dd3c716d407c331aca8bf7c6faa0">Ftl::State::newArc</a></div><div class="ttdeci">Arc * newArc()</div><div class="ttdoc">Warning: the returned pointer can become invalid after a new call of newArc() </div><div class="ttdef"><b>Definition:</b> <a href="tAutomaton_8cc_source.html#l00020">tAutomaton.cc:20</a></div></div>
<div class="ttc" id="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Arc_html"><div class="ttname"><a href="structFlf_1_1NBestBuilder_1_1PrefixTree_1_1Arc.html">Flf::NBestBuilder::PrefixTree::Arc</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00305">NBest.cc:305</a></div></div>
<div class="ttc" id="Assertions_8hh_html_ae925d7587e34145cd52f674b2012539a"><div class="ttname"><a href="Assertions_8hh.html#ae925d7587e34145cd52f674b2012539a">require</a></div><div class="ttdeci">#define require(expr)</div><div class="ttdoc">Check precondition. </div><div class="ttdef"><b>Definition:</b> <a href="WeightedAccumulator_8hh_source.html#l00210">WeightedAccumulator.hh:210</a></div></div>
<div class="ttc" id="classCore_1_1XmlClose_html"><div class="ttname"><a href="classCore_1_1XmlClose.html">Core::XmlClose</a></div><div class="ttdef"><b>Definition:</b> <a href="XmlStream_8hh_source.html#l00077">XmlStream.hh:77</a></div></div>
<div class="ttc" id="structFlf_1_1NBestBuilder_1_1Node_html"><div class="ttname"><a href="structFlf_1_1NBestBuilder_1_1Node.html">Flf::NBestBuilder::Node</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00380">NBest.cc:380</a></div></div>
<div class="ttc" id="classFlf_1_1Semiring_html"><div class="ttname"><a href="classFlf_1_1Semiring.html">Flf::Semiring</a></div><div class="ttdef"><b>Definition:</b> <a href="Flf_2FlfCore_2Semiring_8hh_source.html#l00037">Flf/FlfCore/Semiring.hh:37</a></div></div>
<div class="ttc" id="classFlf_1_1DumpNBestNode_html_aba9d2c5ac22bc7aca561fefc8115568e"><div class="ttname"><a href="classFlf_1_1DumpNBestNode.html#aba9d2c5ac22bc7aca561fefc8115568e">Flf::DumpNBestNode::init</a></div><div class="ttdeci">virtual void init(const std::vector&lt; std::string &gt; &amp;arguments)</div><div class="ttdoc">init, good, pull, and finalize are making up the used network protocol. </div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l01306">NBest.cc:1306</a></div></div>
<div class="ttc" id="classCore_1_1XmlWriter_html"><div class="ttname"><a href="classCore_1_1XmlWriter.html">Core::XmlWriter</a></div><div class="ttdoc">Stream adaptor for producing XML output. </div><div class="ttdef"><b>Definition:</b> <a href="XmlStream_8hh_source.html#l00149">XmlStream.hh:149</a></div></div>
<div class="ttc" id="classCore_1_1Channel_html_abd7e750d378796adf133a025b9c2a510"><div class="ttname"><a href="classCore_1_1Channel.html#abd7e750d378796adf133a025b9c2a510">Core::Channel::isOpen</a></div><div class="ttdeci">bool isOpen() const </div><div class="ttdoc">Test whether channel output is actually used. </div><div class="ttdef"><b>Definition:</b> <a href="Channel_8hh_source.html#l00127">Channel.hh:127</a></div></div>
<div class="ttc" id="structCore_1_1Type_html"><div class="ttname"><a href="structCore_1_1Type.html">Core::Type</a></div><div class="ttdoc">Static information about elementary types. </div><div class="ttdef"><b>Definition:</b> <a href="Core_2Types_8hh_source.html#l00040">Core/Types.hh:40</a></div></div>
<div class="ttc" id="classFlf_1_1SelectNBestNode_html"><div class="ttname"><a href="classFlf_1_1SelectNBestNode.html">Flf::SelectNBestNode</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l01177">NBest.cc:1177</a></div></div>
<div class="ttc" id="structFlf_1_1NBestBuilder_1_1DissenterList_1_1RangeWeakOrder_html"><div class="ttname"><a href="structFlf_1_1NBestBuilder_1_1DissenterList_1_1RangeWeakOrder.html">Flf::NBestBuilder::DissenterList::RangeWeakOrder</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l00425">NBest.cc:425</a></div></div>
<div class="ttc" id="classFlf_1_1SelectNBestNode_html_a710f247ec1a8ee62b742cb635b2397cb"><div class="ttname"><a href="classFlf_1_1SelectNBestNode.html#a710f247ec1a8ee62b742cb635b2397cb">Flf::SelectNBestNode::sendLattice</a></div><div class="ttdeci">virtual ConstLatticeRef sendLattice(Port to)</div><div class="ttdoc">This section defines send handler for some common data types. </div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l01194">NBest.cc:1194</a></div></div>
<div class="ttc" id="classFlf_1_1DumpNBestNode_html"><div class="ttname"><a href="classFlf_1_1DumpNBestNode.html">Flf::DumpNBestNode</a></div><div class="ttdef"><b>Definition:</b> <a href="NBest_8cc_source.html#l01225">NBest.cc:1225</a></div></div>
<div class="ttc" id="namespaceFlf_html_a185934049655b0511faff255f5211585"><div class="ttname"><a href="namespaceFlf.html#a185934049655b0511faff255f5211585">Flf::persistent</a></div><div class="ttdeci">std::pair&lt; bool, bool &gt; persistent(ConstLatticeRef l, StaticLattice *staticLattice, StaticBoundaries *staticBoundaries)</div><div class="ttdoc">Behaviour of copy and deepCopy: </div><div class="ttdef"><b>Definition:</b> <a href="Copy_8cc_source.html#l00140">Copy.cc:140</a></div></div>
<div class="ttc" id="classCore_1_1Vector_html"><div class="ttname"><a href="classCore_1_1Vector.html">Core::Vector&lt; Fsa::StateId &gt;</a></div></div>
<div class="ttc" id="namespaceCore_html_a100585c516d2491add7c5826237f4cef"><div class="ttname"><a href="namespaceCore.html#a100585c516d2491add7c5826237f4cef">Core::isAlmostEqualUlp</a></div><div class="ttdeci">bool isAlmostEqualUlp(f32 a, f32 b, s32 tolerance)</div><div class="ttdoc">Test for near-equality of floating point numbers with tolerance given in unit of least precision...</div><div class="ttdef"><b>Definition:</b> <a href="Core_2Utility_8hh_source.html#l00384">Core/Utility.hh:384</a></div></div>
<div class="ttc" id="Assertions_8hh_html_a0a6432d768e4a040089ea8b3c8b6b4f0"><div class="ttname"><a href="Assertions_8hh.html#a0a6432d768e4a040089ea8b3c8b6b4f0">ensure</a></div><div class="ttdeci">#define ensure(expr)</div><div class="ttdoc">Check postcondition. </div><div class="ttdef"><b>Definition:</b> <a href="WeightedAccumulator_8hh_source.html#l00272">WeightedAccumulator.hh:272</a></div></div>
<div class="ttc" id="classFlf_1_1StaticBoundaries_html_a50737c9ea7a9425388a78bd881c172ee"><div class="ttname"><a href="classFlf_1_1StaticBoundaries.html#a50737c9ea7a9425388a78bd881c172ee">Flf::StaticBoundaries::set</a></div><div class="ttdeci">bool set(Fsa::StateId sid, const Boundary &amp;boundary)</div><div class="ttdoc">set and return true, if precondition !valid(sid) </div><div class="ttdef"><b>Definition:</b> <a href="Boundaries_8cc_source.html#l00069">Boundaries.cc:69</a></div></div>
<div class="ttc" id="classFlf_1_1FilterNode_html"><div class="ttname"><a href="classFlf_1_1FilterNode.html">Flf::FilterNode</a></div><div class="ttdef"><b>Definition:</b> <a href="Flf_2Network_8hh_source.html#l00209">Flf/Network.hh:209</a></div></div>
<div class="ttc" id="classCore_1_1Ref_html_abd19893817c14e95b73ea0c0471b7e74"><div class="ttname"><a href="classCore_1_1Ref.html#abd19893817c14e95b73ea0c0471b7e74">Core::Ref::reset</a></div><div class="ttdeci">void reset()</div><div class="ttdoc">Reset to void. </div><div class="ttdef"><b>Definition:</b> <a href="ReferenceCounting_8hh_source.html#l00230">ReferenceCounting.hh:230</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
