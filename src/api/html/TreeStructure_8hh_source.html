<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Sprint: TreeStructure.hh Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sprint
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_fe8f841f54dd3adfd2b4b47cca6320a3.html">Search</a></li><li class="navelem"><a class="el" href="dir_a9e12e49b8699e5af6e47e138a706fce.html">AdvancedTreeSearch</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">TreeStructure.hh</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/** Copyright 2020 RWTH Aachen University. All rights reserved.</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"> *  Licensed under the RWTH ASR License (the &quot;License&quot;);</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"> *  you may not use this file except in compliance with the License.</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"> *  You may obtain a copy of the License at</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment"> *      http://www.hltpr.rwth-aachen.de/rwth-asr/rwth-asr-license.html</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment"> *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment"> *  See the License for the specific language governing permissions and</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment"> *  limitations under the License.</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="preprocessor">#ifndef SEARCH_TREESTRUCTURE_HH</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#define SEARCH_TREESTRUCTURE_HH</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="preprocessor">#include &lt;Core/MappedArchive.hh&gt;</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;Search/StateTree.hh&gt;</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;BatchManager.hh&quot;</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#define inline_ __attribute__((always_inline)) inline</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment"> * This file contains a storable, efficient and dynamic structure that allows representing the state-network</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"> * in speech recognition flexibly. The structure can dynamically be changed by creating new states and successor-links,</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment"> * and a &quot;cleanup&quot; operation can be used to optimize the structure after significant changes.</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">///@todo Enable batch-merging (mergeBatches_), and make sure the structure is optimal.</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">///@todo Allow &quot;freezing&quot; all batches: No follower-gap in the middle (should save 1/3 of space for the batches)</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceSearch.html">Search</a> {<span class="comment"></span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">/// This index represents an arbitrary list of successor-states and labels</span></div><div class="line"><a name="l00036"></a><span class="lineno"><a class="line" href="namespaceSearch.html#a0f0cff107c7f9e71d4f2d77efb631ffa">   36</a></span>&#160;<span class="comment"></span><span class="keyword">typedef</span> u32 <a class="code" href="namespaceSearch.html#a0f0cff107c7f9e71d4f2d77efb631ffa">SuccessorBatchId</a>;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="keyword">enum</span> {<span class="comment"></span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">    /// When this bitmask set on an SuccessorBatchId, the id represents only one successor (or label),</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">    /// and the index can be extracted through &quot;id &amp; (~SingleSuccessorBatchMask)&quot;</span></div><div class="line"><a name="l00041"></a><span class="lineno"><a class="line" href="namespaceSearch.html#aa02a40bad1cbff39ab5efd9bcfd80e9fad646ab382f6afce3c2703c5c0663984c">   41</a></span>&#160;<span class="comment"></span>    <a class="code" href="namespaceSearch.html#aa02a40bad1cbff39ab5efd9bcfd80e9fad646ab382f6afce3c2703c5c0663984c">SingleSuccessorBatchMask</a> = 1 &lt;&lt; 30,</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    LabelMask                = 1 &lt;&lt; 27</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;};</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment">///Global index of a tree or subtree</span></div><div class="line"><a name="l00046"></a><span class="lineno"><a class="line" href="namespaceSearch.html#a9b4630d7f0a64cb3317190d22f0bc2e4">   46</a></span>&#160;<span class="comment"></span><span class="keyword">typedef</span> u32 <a class="code" href="namespaceSearch.html#a9b4630d7f0a64cb3317190d22f0bc2e4">TreeIndex</a>;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">///Index of a state or label (see IS_LABEL, ID_FROM_LABEL, and LABEL_FROM_ID)</span></div><div class="line"><a name="l00049"></a><span class="lineno"><a class="line" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">   49</a></span>&#160;<span class="comment"></span><span class="keyword">typedef</span> u32 <a class="code" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a>;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">///@todo Maybe this should be zero!</span></div><div class="line"><a name="l00052"></a><span class="lineno"><a class="line" href="namespaceSearch.html#aaf94240d77ec07d15534b2a7d2d33174">   52</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keyword">const</span> StateId <a class="code" href="namespaceSearch.html#aaf94240d77ec07d15534b2a7d2d33174">invalidTreeNodeIndex</a> = (<a class="code" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">StateId</a>)-1;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">/// Index representing the batch of all nodes that are contained by one tree</span></div><div class="line"><a name="l00055"></a><span class="lineno"><a class="line" href="namespaceSearch.html#a6db22ea3065285134fef597f8933b87f">   55</a></span>&#160;<span class="comment"></span><span class="keyword">typedef</span> u32 <a class="code" href="namespaceSearch.html#a6db22ea3065285134fef597f8933b87f">SubTreeListId</a>;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">/// Returns whether the given edge-successor index represents a label rather than a state</span></div><div class="line"><a name="l00058"></a><span class="lineno"><a class="line" href="namespaceSearch.html#a7bfe0531312411cd2000804311868bc5">   58</a></span>&#160;<span class="comment"></span>inline_ <span class="keywordtype">bool</span> <a class="code" href="namespaceSearch.html#a7bfe0531312411cd2000804311868bc5">IS_LABEL</a>(<span class="keyword">const</span> StateId x) {</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="keywordflow">return</span> x &amp; LabelMask;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;}</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">/// Returns the representation index of this label as an edge-successor</span></div><div class="line"><a name="l00063"></a><span class="lineno"><a class="line" href="namespaceSearch.html#af9c583ae675f86488e953acc7bbf7d29">   63</a></span>&#160;<span class="comment"></span>inline_ StateId <a class="code" href="namespaceSearch.html#af9c583ae675f86488e953acc7bbf7d29">ID_FROM_LABEL</a>(<span class="keyword">const</span> u32 x) {</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="keywordflow">return</span> x | LabelMask;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;}</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">/// Encodes the given index as an edge-successor so that it represents a label</span></div><div class="line"><a name="l00068"></a><span class="lineno"><a class="line" href="namespaceSearch.html#ac3db4fa1c38a3c0e7e9a3979f50f0fc5">   68</a></span>&#160;<span class="comment"></span>inline_ u32 <a class="code" href="namespaceSearch.html#ac3db4fa1c38a3c0e7e9a3979f50f0fc5">LABEL_FROM_ID</a>(StateId x) {</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="keywordflow">return</span> x &amp; (~LabelMask);</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;}</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="keyword">enum</span> {</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    InvalidBatchId = 0</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;};</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment">/// The standard network state, representing a state and its successor-links</span></div><div class="line"><a name="l00077"></a><span class="lineno"><a class="line" href="structSearch_1_1HMMState.html">   77</a></span>&#160;<span class="comment"></span><span class="keyword">struct </span><a class="code" href="structSearch_1_1HMMState.html">HMMState</a> {</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    inline_ <a class="code" href="structSearch_1_1HMMState.html">HMMState</a>()</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;            : <a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a>(InvalidBatchId) {</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    }</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    inline_ HMMState&amp; operator=(<span class="keyword">const</span> HMMState&amp; rhs) {</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        <a class="code" href="structSearch_1_1HMMState.html#a4b2e1bde03da6576335841b6a3928db1">stateDesc</a>  = rhs.<a class="code" href="structSearch_1_1HMMState.html#a4b2e1bde03da6576335841b6a3928db1">stateDesc</a>;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a> = rhs.<a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a>;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    }</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="comment">    ///This must be initialized explicitly after creating the state</span></div><div class="line"><a name="l00089"></a><span class="lineno"><a class="line" href="structSearch_1_1HMMState.html#a4b2e1bde03da6576335841b6a3928db1">   89</a></span>&#160;<span class="comment"></span>    <a class="code" href="structSearch_1_1StateTree_1_1StateDesc.html">StateTree::StateDesc</a> <a class="code" href="structSearch_1_1HMMState.html#a4b2e1bde03da6576335841b6a3928db1">stateDesc</a>;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment">    ///Batch of successor states, managed through a batch-manager in TreeStructure</span></div><div class="line"><a name="l00092"></a><span class="lineno"><a class="line" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">   92</a></span>&#160;<span class="comment"></span>    SuccessorBatchId <a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a>;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment">    /// Returns true if the label-edges batch represents only one single successor, which can be handled more efficiently</span></div><div class="line"><a name="l00095"></a><span class="lineno"><a class="line" href="structSearch_1_1HMMState.html#a50e4a83f844ff0802f21c33b76d7cc97">   95</a></span>&#160;<span class="comment"></span>    inline_ <span class="keywordtype">bool</span> <a class="code" href="structSearch_1_1HMMState.html#a50e4a83f844ff0802f21c33b76d7cc97">hasSingleSuccessor</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        <span class="keywordflow">return</span> (successors &amp; <a class="code" href="namespaceSearch.html#aa02a40bad1cbff39ab5efd9bcfd80e9fad646ab382f6afce3c2703c5c0663984c">SingleSuccessorBatchMask</a>) == <a class="code" href="namespaceSearch.html#aa02a40bad1cbff39ab5efd9bcfd80e9fad646ab382f6afce3c2703c5c0663984c">SingleSuccessorBatchMask</a>;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    }</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="comment">    /// If hasSingleSuccessor returned true, then this can be used to retrieve the single successor</span></div><div class="line"><a name="l00100"></a><span class="lineno"><a class="line" href="structSearch_1_1HMMState.html#a1d0229123f9e7df05b4dbd7218b7a3ea">  100</a></span>&#160;<span class="comment"></span>    inline_ StateId <a class="code" href="structSearch_1_1HMMState.html#a1d0229123f9e7df05b4dbd7218b7a3ea">singleSuccessor</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="keywordflow">return</span> successors &amp; (~<a class="code" href="namespaceSearch.html#aa02a40bad1cbff39ab5efd9bcfd80e9fad646ab382f6afce3c2703c5c0663984c">SingleSuccessorBatchMask</a>);</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    }</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;};</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno"><a class="line" href="structSearch_1_1Tree.html">  105</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structSearch_1_1Tree.html">Tree</a> {</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <a class="code" href="structSearch_1_1Tree.html">Tree</a>()</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;            : nodes(InvalidBatchId) {</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    }<span class="comment"></span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment">    ///All nodes contained by this tree. Managed as a batch by TreeStructure</span></div><div class="line"><a name="l00110"></a><span class="lineno"><a class="line" href="structSearch_1_1Tree.html#a925197c56a955fc70b035b060c3201fa">  110</a></span>&#160;<span class="comment"></span>    SubTreeListId <a class="code" href="structSearch_1_1Tree.html#a925197c56a955fc70b035b060c3201fa">nodes</a>;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;};</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork.html">  113</a></span>&#160;<span class="keyword">class </span><a class="code" href="classSearch_1_1HMMStateNetwork.html">HMMStateNetwork</a> {</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    <span class="keyword">enum</span> {</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="comment">//Index of the empty network</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        <span class="comment">//The empty network has no node, and exactly one label that is to be activated directly</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        EmptyTreeIndex = 0</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    };</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="keyword">enum</span> {</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        DiskFormatVersion = 1</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    };</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="keyword">typedef</span> <a class="code" href="classTools_1_1BatchIndexIterator.html">Tools::BatchIndexIterator&lt;SubTreeListId, StateId, InvalidBatchId, 0&gt;</a> <a class="code" href="classTools_1_1BatchIndexIterator.html">SubTreeIterator</a>;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno"><a class="line" href="structSearch_1_1HMMStateNetwork_1_1SuccessorIterator.html">  127</a></span>&#160;    <span class="keyword">struct </span><a class="code" href="structSearch_1_1HMMStateNetwork_1_1SuccessorIterator.html">SuccessorIterator</a> : <span class="keyword">public</span> <a class="code" href="classTools_1_1BatchIndexIterator.html">Tools::BatchIndexIterator</a>&lt;SuccessorBatchId, StateId, InvalidBatchId, SingleSuccessorBatchMask&gt; {</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <a class="code" href="structSearch_1_1HMMStateNetwork_1_1SuccessorIterator.html">SuccessorIterator</a>(SuccessorBatchId batchId, <span class="keyword">const</span> std::vector&lt;StateId&gt;&amp; batches)</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                : <a class="code" href="classTools_1_1BatchIndexIterator.html">Tools::BatchIndexIterator&lt;SuccessorBatchId, StateId, InvalidBatchId, SingleSuccessorBatchMask&gt;</a>(batchId, batches) {</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        }</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">bool</span> isLabel()<span class="keyword"> const </span>{</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespaceSearch.html#a7bfe0531312411cd2000804311868bc5">IS_LABEL</a>(**<span class="keyword">this</span>);</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        }</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        <span class="keyword">inline</span> u32 label()<span class="keyword"> const </span>{</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespaceSearch.html#ac3db4fa1c38a3c0e7e9a3979f50f0fc5">LABEL_FROM_ID</a>(**<span class="keyword">this</span>);</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        }</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    };</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork_1_1EfficientSingleTargetIterator.html">  139</a></span>&#160;    <span class="keyword">class </span><a class="code" href="classSearch_1_1HMMStateNetwork_1_1EfficientSingleTargetIterator.html">EfficientSingleTargetIterator</a> {</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="keyword">public</span>:</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        <span class="keyword">inline</span> <a class="code" href="classSearch_1_1HMMStateNetwork_1_1EfficientSingleTargetIterator.html">EfficientSingleTargetIterator</a>(StateId target)</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                : target_(target) {</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        }</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">void</span> operator++() {</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;            target_ = <a class="code" href="namespaceSearch.html#aaf94240d77ec07d15534b2a7d2d33174">invalidTreeNodeIndex</a>;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        }</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        <span class="keyword">inline</span> <span class="keyword">operator</span> bool()<span class="keyword"> const </span>{</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            <span class="keywordflow">return</span> target_ != <a class="code" href="namespaceSearch.html#aaf94240d77ec07d15534b2a7d2d33174">invalidTreeNodeIndex</a>;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        }</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        <span class="keyword">inline</span> StateId operator*()<span class="keyword"> const </span>{</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            <span class="keywordflow">return</span> target_;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        }</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">bool</span> isOutput()<span class="keyword"> const </span>{</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespaceSearch.html#a7bfe0531312411cd2000804311868bc5">IS_LABEL</a>(**<span class="keyword">this</span>);</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        }</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        <span class="keyword">inline</span> u32 label()<span class="keyword"> const </span>{</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespaceSearch.html#ac3db4fa1c38a3c0e7e9a3979f50f0fc5">LABEL_FROM_ID</a>(**<span class="keyword">this</span>);</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        }</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    <span class="keyword">private</span>:</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        StateId target_;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    };</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork_1_1EfficientBatchTargetIterator.html">  169</a></span>&#160;    <span class="keyword">class </span><a class="code" href="classSearch_1_1HMMStateNetwork_1_1EfficientBatchTargetIterator.html">EfficientBatchTargetIterator</a> {</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="keyword">public</span>:</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keyword">inline</span> <a class="code" href="classSearch_1_1HMMStateNetwork_1_1EfficientBatchTargetIterator.html">EfficientBatchTargetIterator</a>(std::pair&lt;StateId, StateId&gt; targets)</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                : targets_(targets) {</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        }</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <span class="keyword">inline</span> <span class="keyword">operator</span> bool()<span class="keyword"> const </span>{</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            <span class="keywordflow">return</span> targets_.first != targets_.second;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        }</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        <span class="keyword">inline</span> <a class="code" href="classSearch_1_1HMMStateNetwork_1_1EfficientBatchTargetIterator.html">EfficientBatchTargetIterator</a>&amp; operator++() {</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;            targets_.first += 1;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        }</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <span class="keyword">inline</span> StateId operator*()<span class="keyword"> const </span>{</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;            <span class="keywordflow">return</span> targets_.first;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        }</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        <span class="keyword">inline</span> <span class="keywordtype">bool</span> isOutput()<span class="keyword"> const </span>{</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespaceSearch.html#a7bfe0531312411cd2000804311868bc5">IS_LABEL</a>(**<span class="keyword">this</span>);</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        }</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        <span class="keyword">inline</span> u32 label()<span class="keyword"> const </span>{</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespaceSearch.html#ac3db4fa1c38a3c0e7e9a3979f50f0fc5">LABEL_FROM_ID</a>(**<span class="keyword">this</span>);</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        }</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <span class="keyword">private</span>:</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        std::pair&lt;StateId, StateId&gt; targets_;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    };</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <a class="code" href="classSearch_1_1HMMStateNetwork.html">HMMStateNetwork</a>();</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="comment">    ///****** STATE MANAGEMENT ******************************************************************************************</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment"></span><span class="comment"></span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment">    ///Do not keep pointers/references to the returned tree, the address may change</span></div><div class="line"><a name="l00205"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork.html#ab154efb1f5084f3dee331a5e415a161a">  205</a></span>&#160;<span class="comment"></span>    <span class="keyword">inline</span> <a class="code" href="structSearch_1_1Tree.html">Tree</a>&amp; <a class="code" href="classSearch_1_1HMMStateNetwork.html#ab154efb1f5084f3dee331a5e415a161a">tree</a>(TreeIndex index) {</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        verify_(index &gt; 0 &amp;&amp; index &lt; trees_.size());</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        <span class="keywordflow">return</span> trees_[index];</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    }</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment">    ///Do not keep pointers to the returned state, the address may change when the network is manipulated</span></div><div class="line"><a name="l00211"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork.html#a71f0ad7ab5348bdf64fe33d29741f7e7">  211</a></span>&#160;<span class="comment"></span>    inline_ <a class="code" href="structSearch_1_1HMMState.html">HMMState</a>&amp; <a class="code" href="classSearch_1_1HMMStateNetwork.html#a71f0ad7ab5348bdf64fe33d29741f7e7">state</a>(StateId state) {</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        verify_(state &gt; 0 &amp;&amp; state &lt; (<span class="keywordtype">int</span>)states_.size());</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        <span class="keywordflow">return</span> states_[state];</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    }</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment">    ///Do not keep pointers to the returned state, the address may change when the network is manipulated</span></div><div class="line"><a name="l00217"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork.html#ad1d3b2f076795eb9002ba61f46ff487b">  217</a></span>&#160;<span class="comment"></span>    <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="structSearch_1_1HMMState.html">HMMState</a>&amp; <a class="code" href="classSearch_1_1HMMStateNetwork.html#ad1d3b2f076795eb9002ba61f46ff487b">state</a>(StateId state)<span class="keyword"> const </span>{</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        verify_(state &gt; 0 &amp;&amp; state &lt; (<span class="keywordtype">int</span>)states_.size());</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        <span class="keywordflow">return</span> states_[state];</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    }</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment">    ///Allocates a new tree</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment"></span>    TreeIndex allocateTree();</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="comment">    ///Allocates a new subtree, and adds it into the subtree list of the given parent.</span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment">    ///As many subtrees for the same parent should be allocated in a row as possible, so batch-merging can happen</span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment">    ///Returns a fully valid subtree(With initialized edge-list)</span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment"></span>    StateId allocateTreeNode(TreeIndex parent);</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment">    ///Returns the count of nodes contained by the tree</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment"></span>    <span class="keyword">inline</span> u32 getNodeCount(TreeIndex parent);</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="comment">    ///Returns the @p number th node contained in the given parent tree</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="comment"></span>    <span class="keyword">inline</span> StateId getTreeNode(TreeIndex parent, u32 number);</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="comment">    ///Returns the number of nodes contained by the given parent tree</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="comment"></span>    <span class="keyword">inline</span> u32 getNodeNumber(TreeIndex parent, StateId node);</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="comment">    ///Much faster version of getNodeNumber, that only works when the structure has been cleaned</span></div><div class="line"><a name="l00240"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork.html#ae0180d9aa048e75e36d14eea2d55b859">  240</a></span>&#160;<span class="comment"></span>    <span class="keyword">inline</span> u32 <a class="code" href="classSearch_1_1HMMStateNetwork.html#ae0180d9aa048e75e36d14eea2d55b859">getNodeNumberCleanStructure</a>(TreeIndex parent, StateId node) {</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        <span class="keywordflow">return</span> node - subTreeListBatches_[tree(parent).nodes];</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    }</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment">    ///Returns the total number of trees, which is the maximum upper bound for a valid TreeIndex</span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment"></span>    u32 treeCount() <span class="keyword">const</span>;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment">    ///Returns the total number of nodes, which is the maximum upper bound for a valid TreeNodeIndex</span></div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment"></span>    u32 stateCount() <span class="keyword">const</span>;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno"><a class="line" href="structSearch_1_1HMMStateNetwork_1_1CleanupResult.html">  250</a></span>&#160;    <span class="keyword">struct </span><a class="code" href="structSearch_1_1HMMStateNetwork_1_1CleanupResult.html">CleanupResult</a> {</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        <a class="code" href="classCore_1_1HashMap.html">Core::HashMap&lt;StateId, StateId&gt;</a>     nodeMap;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <a class="code" href="classCore_1_1HashMap.html">Core::HashMap&lt;TreeIndex, TreeIndex&gt;</a> treeMap;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        std::set&lt;StateId&gt; mapNodes(<span class="keyword">const</span> std::set&lt;StateId&gt;&amp; nodes) <span class="keyword">const</span>;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    };</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="comment">    ///Completely removes all trees and nodes that are not reachable from the given start-nodes, compressing the structure</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="comment"></span>    <a class="code" href="structSearch_1_1HMMStateNetwork_1_1CleanupResult.html">CleanupResult</a> cleanup(std::list&lt;Search::StateId&gt; startNodes, <a class="code" href="namespaceSearch.html#a9b4630d7f0a64cb3317190d22f0bc2e4">Search::TreeIndex</a> masterTree, <span class="keywordtype">bool</span> clearDeadEnds = <span class="keyword">true</span>, <span class="keywordtype">bool</span> onlyBatches = <span class="keyword">false</span>);</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment">    ///****** EDGE MANAGEMENT *******************************************************************************************</span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment"></span><span class="comment"></span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment">    ///Adds the given target to the list of targets for the given edge. The referenced id will be changed.</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="comment"></span>    <span class="keywordtype">void</span> addNodeToEdge(SuccessorBatchId&amp; list, StateId target);</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment">    ///Adds the given target to the list of targets for the given edge. The referenced id will be changed.</span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment"></span>    <span class="keywordtype">void</span> addOutputToEdge(SuccessorBatchId&amp; list, u32 outputIndex);</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    <span class="keywordtype">void</span> addTargetToNode(StateId node, StateId target) {</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        addNodeToEdge(state(node).<a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a>, target);</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    }</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    <span class="keywordtype">void</span> addOutputToNode(StateId node, u32 outputIndex) {</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        addOutputToEdge(state(node).<a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a>, outputIndex);</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    }</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="keywordtype">void</span> removeTargetFromNode(StateId node, StateId target);</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    <span class="keywordtype">void</span> removeOutputFromNode(StateId node, u32 outputIndex);</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment">    ///Clears all connections behind the given node. The memory will be lost unless a cleanup is done afterwards.</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment"></span>    <span class="keywordtype">void</span> clearOutputEdges(StateId node);</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    u32 getChecksum()<span class="keyword"> const </span>{</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        <span class="keywordflow">return</span> states_.size() + edgeTargetBatches_.size() + edgeTargetLists_.size() + trees_.size() + subTreeListBatches_.size();</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    }</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="comment">    ///The change is applied when apply() is called</span></div><div class="line"><a name="l00288"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork_1_1ChangePlan.html">  288</a></span>&#160;<span class="comment"></span>    <span class="keyword">class </span><a class="code" href="classSearch_1_1HMMStateNetwork_1_1ChangePlan.html">ChangePlan</a> {</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="keyword">public</span>:</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="keywordtype">void</span> addSuccessor(StateId state) {</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;            <span class="keyword">remove</span>.erase(state);</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;            add.insert(state);</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        }</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        <span class="keywordtype">void</span> addSuccessorLabel(u32 label) {</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            <span class="keyword">remove</span>.erase(<a class="code" href="namespaceSearch.html#af9c583ae675f86488e953acc7bbf7d29">ID_FROM_LABEL</a>(label));</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            add.insert(<a class="code" href="namespaceSearch.html#af9c583ae675f86488e953acc7bbf7d29">ID_FROM_LABEL</a>(label));</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        }</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        <span class="keywordtype">void</span> removeSuccessor(StateId state) {</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            <span class="keyword">remove</span>.insert(state);</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;            add.erase(state);</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        }</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        <span class="keywordtype">void</span> removeSuccessorLabel(u32 label) {</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            <span class="keyword">remove</span>.insert(<a class="code" href="namespaceSearch.html#af9c583ae675f86488e953acc7bbf7d29">ID_FROM_LABEL</a>(label));</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;            add.erase(<a class="code" href="namespaceSearch.html#af9c583ae675f86488e953acc7bbf7d29">ID_FROM_LABEL</a>(label));</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        }</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        <span class="keywordtype">void</span> apply();</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="keyword">private</span>:</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        <a class="code" href="classSearch_1_1HMMStateNetwork_1_1ChangePlan.html">ChangePlan</a>(<a class="code" href="classSearch_1_1HMMStateNetwork.html">HMMStateNetwork</a>&amp; _structure, StateId _node)</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                : node(_node), structure(&amp;_structure) {</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        }</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        <a class="code" href="classSearch_1_1HMMStateNetwork_1_1ChangePlan.html">ChangePlan</a>()</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                : node(0), structure(0) {</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        }</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        std::set&lt;int&gt; add;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;        std::set&lt;int&gt; <span class="keyword">remove</span>;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSearch_1_1HMMStateNetwork.html">HMMStateNetwork</a>;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        StateId          node;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        <a class="code" href="classSearch_1_1HMMStateNetwork.html">HMMStateNetwork</a>* structure;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    };</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <a class="code" href="classSearch_1_1HMMStateNetwork_1_1ChangePlan.html">ChangePlan</a> change(StateId node);</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    <span class="keyword">inline</span> <a class="code" href="structSearch_1_1HMMStateNetwork_1_1SuccessorIterator.html">SuccessorIterator</a> batchSuccessors(<a class="code" href="namespaceSearch.html#a0f0cff107c7f9e71d4f2d77efb631ffa">Search::SuccessorBatchId</a> list) <span class="keyword">const</span>;</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="keyword">inline</span> <a class="code" href="structSearch_1_1HMMStateNetwork_1_1SuccessorIterator.html">SuccessorIterator</a> <a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a>(StateId node)<span class="keyword"> const </span>{</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        <span class="keywordflow">return</span> batchSuccessors(state(node).<a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a>);</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    }</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    <span class="keyword">inline</span> <a class="code" href="structSearch_1_1HMMStateNetwork_1_1SuccessorIterator.html">SuccessorIterator</a> <a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a>(<span class="keyword">const</span> <a class="code" href="structSearch_1_1HMMState.html">HMMState</a>&amp; node)<span class="keyword"> const </span>{</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="keywordflow">return</span> batchSuccessors(node.<a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a>);</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    }</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="comment">// Calls the given function-object with each target node</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionObject&gt;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    <span class="keyword">inline</span> <span class="keywordtype">void</span> efficientlyIterateTargets(<span class="keyword">const</span> <a class="code" href="structSearch_1_1HMMState.html">HMMState</a>&amp; node, FunctionObject&amp; <span class="keywordtype">object</span>)<span class="keyword"> const </span>{</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        <span class="keywordflow">if</span> (node.<a class="code" href="structSearch_1_1HMMState.html#a50e4a83f844ff0802f21c33b76d7cc97">hasSingleSuccessor</a>()) {</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;            object(node.<a class="code" href="structSearch_1_1HMMState.html#a1d0229123f9e7df05b4dbd7218b7a3ea">singleSuccessor</a>());</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;            <span class="keywordflow">return</span>;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        }</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        std::pair&lt;int, int&gt; targets = batchSuccessorsSimple&lt;false&gt;(node.<a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a>);</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        <span class="keywordflow">if</span> (targets.first != -1) {</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;            <span class="keywordflow">for</span> (; targets.first != targets.second; ++targets.first)</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                <span class="keywordtype">object</span>(targets.first);</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;        }</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;        <span class="keywordflow">else</span> {</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="structSearch_1_1HMMStateNetwork_1_1SuccessorIterator.html">SuccessorIterator</a> it = this-&gt;<a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a>(node); it; ++it)</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                <span class="keywordtype">object</span>(*it);</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;        }</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    }</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="comment">    /// Convenience function: Returns the set of target nodes of the given tree node</span></div><div class="line"><a name="l00360"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork.html#a36714934af5cc4d6d783c1e7f90d6463">  360</a></span>&#160;<span class="comment"></span>    std::set&lt;StateId&gt; <a class="code" href="classSearch_1_1HMMStateNetwork.html#a36714934af5cc4d6d783c1e7f90d6463">targetNodeSet</a>(StateId node)<span class="keyword"> const </span>{</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;        std::set&lt;StateId&gt; ret;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="structSearch_1_1HMMStateNetwork_1_1SuccessorIterator.html">HMMStateNetwork::SuccessorIterator</a> target = <a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a>(node); target; ++target)</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;            <span class="keywordflow">if</span> (!target.isLabel())</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;                ret.insert(*target);</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;        <span class="keywordflow">return</span> ret;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    }</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="comment">    /// Convenience function: Returns the set of target outputs of the given tree node</span></div><div class="line"><a name="l00369"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork.html#a8c1d769a106305d2a6cb8bf072811ee3">  369</a></span>&#160;<span class="comment"></span>    std::set&lt;uint&gt; <a class="code" href="classSearch_1_1HMMStateNetwork.html#a8c1d769a106305d2a6cb8bf072811ee3">targetOutputSet</a>(StateId node)<span class="keyword"> const </span>{</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;        std::set&lt;uint&gt; ret;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="structSearch_1_1HMMStateNetwork_1_1SuccessorIterator.html">HMMStateNetwork::SuccessorIterator</a> target = <a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a>(node); target; ++target)</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;            <span class="keywordflow">if</span> (target.isLabel())</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;                ret.insert(target.label());</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        <span class="keywordflow">return</span> ret;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    }</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="comment">    /// Convenience function: Returns the set of target nodes and outputs of the given tree node</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="comment">    /// Outputs are encoded with IS_OUTPUT and OUTPUT_FROM_INDEX</span></div><div class="line"><a name="l00379"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork.html#a3019751331a86fc01832058063660609">  379</a></span>&#160;<span class="comment"></span>    std::set&lt;StateId&gt; <a class="code" href="classSearch_1_1HMMStateNetwork.html#a3019751331a86fc01832058063660609">targetSet</a>(StateId node)<span class="keyword"> const </span>{</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        std::set&lt;StateId&gt; ret;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="structSearch_1_1HMMStateNetwork_1_1SuccessorIterator.html">HMMStateNetwork::SuccessorIterator</a> target = <a class="code" href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">successors</a>(node); target; ++target)</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;            ret.insert(*target);</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        <span class="keywordflow">return</span> ret;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    }</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="comment">    ///Returns -1, -1 if this simple version does not work. Then &quot;edgeTargets&quot; has to be used.</span></div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> cons<span class="keywordtype">id</span>erOutputs&gt;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    <span class="keyword">inline</span> std::pair&lt;int, int&gt; batchSuccessorsSimple(SuccessorBatchId list) <span class="keyword">const</span>;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;<span class="comment">    ///Does not work with single-batches! Those must be checked before.</span></div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="comment"></span>    <span class="keyword">inline</span> std::pair&lt;int, int&gt; batchSuccessorsSimpleIgnoreLabels(SuccessorBatchId list) <span class="keyword">const</span>;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;<span class="comment">    ///Reads out the node-range associated to the given batch. Does not verify whether</span></div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;<span class="comment">    ///the batch is a single-batch or has successor-batches, this has to be checked beforehand.</span></div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;<span class="comment"></span>    <span class="keyword">inline</span> std::pair&lt;int, int&gt; batchNodeRange(SuccessorBatchId batch) <span class="keyword">const</span>;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="comment">    ///*********************************************************************************************************************</span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    <span class="keywordtype">bool</span> write(<a class="code" href="classCore_1_1MappedArchiveWriter.html">Core::MappedArchiveWriter</a> writer);<span class="comment"></span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;<span class="comment">    /// Returns whether reading was successful. Reading will fail on format version mismatch.</span></div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;<span class="comment"></span>    <span class="keywordtype">bool</span> read(<a class="code" href="classCore_1_1MappedArchiveReader.html">Core::MappedArchiveReader</a> reader);</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="keyword">const</span> std::vector&lt;StateId&gt;&amp; edgeTargetBatches()<span class="keyword"> const </span>{</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        <span class="keywordflow">return</span> edgeTargetBatches_;</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    }</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    <span class="keywordtype">void</span> addTargetToEdge(SuccessorBatchId&amp; batch, u32 target);</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    u32  countReachableEnds(std::vector&lt;u32&gt;&amp; counts, StateId node) <span class="keyword">const</span>;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    <span class="comment">//This manager manages lists of sub-trees, one subtree-list for each network</span></div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    std::vector&lt;StateId&gt;                                                        subTreeListBatches_;</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    std::vector&lt;HMMState&gt;                                                       states_;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <a class="code" href="classTools_1_1BatchManager.html">Tools::BatchManager&lt;SubTreeListId, StateId, HMMState, true, InvalidBatchId&gt;</a> subTreeManager_;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    <span class="comment">//Contains one SuccessorBatchId for each label of a subtree, as a linear list</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    std::vector&lt;SuccessorBatchId&gt; edgeTargetLists_;</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <span class="comment">//This manager groups together edge successors, for edges coming from a common source(usually an label of a subtree)</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    std::vector&lt;StateId&gt;                                                                                      edgeTargetBatches_;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <a class="code" href="classTools_1_1BatchManager.html">Tools::BatchManager&lt;SuccessorBatchId, StateId, HMMState, false, InvalidBatchId, SingleSuccessorBatchMask&gt;</a> edgeTargetManager_;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    std::vector&lt;Tree&gt; trees_;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;};</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="keyword">inline</span> <a class="code" href="structSearch_1_1HMMStateNetwork_1_1SuccessorIterator.html">HMMStateNetwork::SuccessorIterator</a> HMMStateNetwork::batchSuccessors(<a class="code" href="namespaceSearch.html#a0f0cff107c7f9e71d4f2d77efb631ffa">Search::SuccessorBatchId</a> list)<span class="keyword"> const </span>{</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structSearch_1_1HMMStateNetwork_1_1SuccessorIterator.html">SuccessorIterator</a>(list, edgeTargetBatches_);</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;}</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div><div class="line"><a name="l00429"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork.html#a192820b02f0a1f0247d176458db38f4f">  429</a></span>&#160;<span class="keyword">inline</span> std::pair&lt;int, int&gt; <a class="code" href="classSearch_1_1HMMStateNetwork.html#a192820b02f0a1f0247d176458db38f4f">HMMStateNetwork::batchSuccessorsSimpleIgnoreLabels</a>(SuccessorBatchId batch)<span class="keyword"> const </span>{</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <span class="keywordflow">if</span> (batch == InvalidBatchId)</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;        <span class="keywordflow">return</span> std::pair&lt;int, int&gt;(-1, -2);</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">Search::StateId</a> start = edgeTargetBatches_[batch];</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">Search::StateId</a> next  = edgeTargetBatches_[batch + 1];</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">Search::StateId</a> end   = edgeTargetBatches_[batch + 2];</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    <span class="keywordflow">if</span> (next == InvalidBatchId)</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;        <span class="keywordflow">return</span> std::pair&lt;int, int&gt;(start, end);</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        <span class="keywordflow">return</span> std::pair&lt;int, int&gt;(-1, -3);</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;}</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> cons<span class="keywordtype">id</span>erOutputs&gt;</div><div class="line"><a name="l00444"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork.html#aee8e09739248045b5ab407324e9e11db">  444</a></span>&#160;<span class="keyword">inline</span> std::pair&lt;int, int&gt; <a class="code" href="classSearch_1_1HMMStateNetwork.html#aee8e09739248045b5ab407324e9e11db">HMMStateNetwork::batchSuccessorsSimple</a>(SuccessorBatchId batch)<span class="keyword"> const </span>{</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    <span class="keywordflow">if</span> (batch &amp; <a class="code" href="namespaceSearch.html#aa02a40bad1cbff39ab5efd9bcfd80e9fad646ab382f6afce3c2703c5c0663984c">SingleSuccessorBatchMask</a>) {</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        SuccessorBatchId b(batch &amp; (~SingleSuccessorBatchMask));</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;        <span class="keywordflow">if</span> (!considerOutputs &amp;&amp; <a class="code" href="namespaceSearch.html#a7bfe0531312411cd2000804311868bc5">IS_LABEL</a>(b))</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;            <span class="keywordflow">return</span> std::pair&lt;int, int&gt;(0, 0);</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;        <span class="keywordflow">return</span> std::pair&lt;int, int&gt;(b, b + 1);</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    }</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    <span class="keywordflow">if</span> (batch == InvalidBatchId)</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;        <span class="keywordflow">return</span> std::pair&lt;int, int&gt;(-1, -2);</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">Search::StateId</a> next = edgeTargetBatches_[batch + 1];</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    <span class="keywordflow">if</span> (next == InvalidBatchId || (not considerOutputs &amp;&amp; <a class="code" href="namespaceSearch.html#a7bfe0531312411cd2000804311868bc5">IS_LABEL</a>(edgeTargetBatches_[next]))) {</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">Search::StateId</a> start = edgeTargetBatches_[batch];</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;        <span class="keywordflow">if</span> (not considerOutputs &amp;&amp; <a class="code" href="namespaceSearch.html#a7bfe0531312411cd2000804311868bc5">IS_LABEL</a>(start))</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;            <span class="keywordflow">return</span> std::pair&lt;int, int&gt;(0, 0);</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;        <span class="comment">//Everything ok, this is a simple continous batch without a follower-batch</span></div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;        <span class="keywordflow">return</span> std::pair&lt;int, int&gt;(start, edgeTargetBatches_[batch + 2]);</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    }</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    <span class="keywordflow">return</span> std::pair&lt;int, int&gt;(-1, -3);</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;}</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;</div><div class="line"><a name="l00467"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork.html#a8729ac3a832d41e2aa32723596f4154a">  467</a></span>&#160;std::pair&lt;int, int&gt; <a class="code" href="classSearch_1_1HMMStateNetwork.html#a8729ac3a832d41e2aa32723596f4154a">HMMStateNetwork::batchNodeRange</a>(SuccessorBatchId batch)<span class="keyword"> const </span>{</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    <span class="keywordflow">return</span> std::make_pair&lt;int, int&gt;((int)edgeTargetBatches_[batch], (<span class="keywordtype">int</span>)edgeTargetBatches_[batch + 2]);</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;}</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;</div><div class="line"><a name="l00471"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork.html#aad01030e3243d4fcd6d759647f366a80">  471</a></span>&#160;u32 <a class="code" href="classSearch_1_1HMMStateNetwork.html#aad01030e3243d4fcd6d759647f366a80">HMMStateNetwork::getNodeCount</a>(<a class="code" href="namespaceSearch.html#a9b4630d7f0a64cb3317190d22f0bc2e4">Search::TreeIndex</a> parent) {</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    <span class="keywordflow">return</span> subTreeManager_.getIterator(tree(parent).nodes).countToEnd();</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;}</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;</div><div class="line"><a name="l00475"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork.html#aa87671628a3b6ebccdce11685bbd2abe">  475</a></span>&#160;StateId <a class="code" href="classSearch_1_1HMMStateNetwork.html#aa87671628a3b6ebccdce11685bbd2abe">HMMStateNetwork::getTreeNode</a>(<a class="code" href="namespaceSearch.html#a9b4630d7f0a64cb3317190d22f0bc2e4">Search::TreeIndex</a> parent, u32 number) {</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    <a class="code" href="classTools_1_1BatchIndexIterator.html">Tools::BatchManager&lt;SubTreeListId, StateId, HMMState, true, InvalidBatchId&gt;::Iterator</a> it = subTreeManager_.getIterator(tree(parent).nodes);</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    it += number;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    <span class="keywordflow">return</span> *it;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;}</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;</div><div class="line"><a name="l00481"></a><span class="lineno"><a class="line" href="classSearch_1_1HMMStateNetwork.html#ad5997bd5600bf2336e54b29279f6d205">  481</a></span>&#160;u32 <a class="code" href="classSearch_1_1HMMStateNetwork.html#ad5997bd5600bf2336e54b29279f6d205">HMMStateNetwork::getNodeNumber</a>(TreeIndex parent, StateId node) {</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    <a class="code" href="classTools_1_1BatchIndexIterator.html">Tools::BatchManager&lt;SubTreeListId, StateId, HMMState, true, InvalidBatchId&gt;::Iterator</a> it = subTreeManager_.getIterator(tree(parent).nodes);</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    <span class="keywordflow">return</span> it.<a class="code" href="classTools_1_1BatchIndexIterator.html#a31aea30ef4766933f1af0dbb590a7d02">countUntil</a>(node);</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;}</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;}  <span class="comment">// namespace Search</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="preprocessor">#endif  // SEARCH_SUBTREESTRUCTURE_HH</span></div><div class="ttc" id="namespaceSearch_html_af9c583ae675f86488e953acc7bbf7d29"><div class="ttname"><a href="namespaceSearch.html#af9c583ae675f86488e953acc7bbf7d29">Search::ID_FROM_LABEL</a></div><div class="ttdeci">inline_ StateId ID_FROM_LABEL(const u32 x)</div><div class="ttdoc">Returns the representation index of this label as an edge-successor. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00063">TreeStructure.hh:63</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_html_ad1d3b2f076795eb9002ba61f46ff487b"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork.html#ad1d3b2f076795eb9002ba61f46ff487b">Search::HMMStateNetwork::state</a></div><div class="ttdeci">const HMMState &amp; state(StateId state) const </div><div class="ttdoc">Do not keep pointers to the returned state, the address may change when the network is manipulated...</div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00217">TreeStructure.hh:217</a></div></div>
<div class="ttc" id="namespaceSearch_html"><div class="ttname"><a href="namespaceSearch.html">Search</a></div><div class="ttdoc">Copyright 2020 RWTH Aachen University. </div><div class="ttdef"><b>Definition:</b> <a href="Flf_2Archive_8cc_source.html#l00041">Flf/Archive.cc:41</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_1_1EfficientBatchTargetIterator_html"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork_1_1EfficientBatchTargetIterator.html">Search::HMMStateNetwork::EfficientBatchTargetIterator</a></div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00169">TreeStructure.hh:169</a></div></div>
<div class="ttc" id="structSearch_1_1HMMStateNetwork_1_1CleanupResult_html"><div class="ttname"><a href="structSearch_1_1HMMStateNetwork_1_1CleanupResult.html">Search::HMMStateNetwork::CleanupResult</a></div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00250">TreeStructure.hh:250</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_html_ab154efb1f5084f3dee331a5e415a161a"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork.html#ab154efb1f5084f3dee331a5e415a161a">Search::HMMStateNetwork::tree</a></div><div class="ttdeci">Tree &amp; tree(TreeIndex index)</div><div class="ttdoc">****** STATE MANAGEMENT *****************************************************************************...</div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00205">TreeStructure.hh:205</a></div></div>
<div class="ttc" id="namespaceSearch_html_a6db22ea3065285134fef597f8933b87f"><div class="ttname"><a href="namespaceSearch.html#a6db22ea3065285134fef597f8933b87f">Search::SubTreeListId</a></div><div class="ttdeci">u32 SubTreeListId</div><div class="ttdoc">Index representing the batch of all nodes that are contained by one tree. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00055">TreeStructure.hh:55</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_html"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork.html">Search::HMMStateNetwork</a></div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00113">TreeStructure.hh:113</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_html_ae0180d9aa048e75e36d14eea2d55b859"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork.html#ae0180d9aa048e75e36d14eea2d55b859">Search::HMMStateNetwork::getNodeNumberCleanStructure</a></div><div class="ttdeci">u32 getNodeNumberCleanStructure(TreeIndex parent, StateId node)</div><div class="ttdoc">Much faster version of getNodeNumber, that only works when the structure has been cleaned...</div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00240">TreeStructure.hh:240</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_html_a3019751331a86fc01832058063660609"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork.html#a3019751331a86fc01832058063660609">Search::HMMStateNetwork::targetSet</a></div><div class="ttdeci">std::set&lt; StateId &gt; targetSet(StateId node) const </div><div class="ttdoc">Convenience function: Returns the set of target nodes and outputs of the given tree node Outputs are ...</div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00379">TreeStructure.hh:379</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_html_a36714934af5cc4d6d783c1e7f90d6463"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork.html#a36714934af5cc4d6d783c1e7f90d6463">Search::HMMStateNetwork::targetNodeSet</a></div><div class="ttdeci">std::set&lt; StateId &gt; targetNodeSet(StateId node) const </div><div class="ttdoc">Convenience function: Returns the set of target nodes of the given tree node. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00360">TreeStructure.hh:360</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_1_1ChangePlan_html"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork_1_1ChangePlan.html">Search::HMMStateNetwork::ChangePlan</a></div><div class="ttdoc">The change is applied when apply() is called. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00288">TreeStructure.hh:288</a></div></div>
<div class="ttc" id="structSearch_1_1Tree_html_a925197c56a955fc70b035b060c3201fa"><div class="ttname"><a href="structSearch_1_1Tree.html#a925197c56a955fc70b035b060c3201fa">Search::Tree::nodes</a></div><div class="ttdeci">SubTreeListId nodes</div><div class="ttdoc">All nodes contained by this tree. Managed as a batch by TreeStructure. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00110">TreeStructure.hh:110</a></div></div>
<div class="ttc" id="classTools_1_1BatchIndexIterator_html_a31aea30ef4766933f1af0dbb590a7d02"><div class="ttname"><a href="classTools_1_1BatchIndexIterator.html#a31aea30ef4766933f1af0dbb590a7d02">Tools::BatchIndexIterator::countUntil</a></div><div class="ttdeci">u32 countUntil(NodeIdType until)</div><div class="ttdoc">Returns the count of steps needed until the given node is reached. The node must be part of this batc...</div><div class="ttdef"><b>Definition:</b> <a href="BatchManager_8hh_source.html#l00282">BatchManager.hh:282</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_html_aa87671628a3b6ebccdce11685bbd2abe"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork.html#aa87671628a3b6ebccdce11685bbd2abe">Search::HMMStateNetwork::getTreeNode</a></div><div class="ttdeci">StateId getTreeNode(TreeIndex parent, u32 number)</div><div class="ttdoc">Returns the number th node contained in the given parent tree. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00475">TreeStructure.hh:475</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_html_a192820b02f0a1f0247d176458db38f4f"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork.html#a192820b02f0a1f0247d176458db38f4f">Search::HMMStateNetwork::batchSuccessorsSimpleIgnoreLabels</a></div><div class="ttdeci">std::pair&lt; int, int &gt; batchSuccessorsSimpleIgnoreLabels(SuccessorBatchId list) const </div><div class="ttdoc">Does not work with single-batches! Those must be checked before. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00429">TreeStructure.hh:429</a></div></div>
<div class="ttc" id="namespaceSearch_html_a7bfe0531312411cd2000804311868bc5"><div class="ttname"><a href="namespaceSearch.html#a7bfe0531312411cd2000804311868bc5">Search::IS_LABEL</a></div><div class="ttdeci">inline_ bool IS_LABEL(const StateId x)</div><div class="ttdoc">Returns whether the given edge-successor index represents a label rather than a state. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00058">TreeStructure.hh:58</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_html_aad01030e3243d4fcd6d759647f366a80"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork.html#aad01030e3243d4fcd6d759647f366a80">Search::HMMStateNetwork::getNodeCount</a></div><div class="ttdeci">u32 getNodeCount(TreeIndex parent)</div><div class="ttdoc">Returns the count of nodes contained by the tree. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00471">TreeStructure.hh:471</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_html_a71f0ad7ab5348bdf64fe33d29741f7e7"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork.html#a71f0ad7ab5348bdf64fe33d29741f7e7">Search::HMMStateNetwork::state</a></div><div class="ttdeci">inline_ HMMState &amp; state(StateId state)</div><div class="ttdoc">Do not keep pointers to the returned state, the address may change when the network is manipulated...</div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00211">TreeStructure.hh:211</a></div></div>
<div class="ttc" id="structSearch_1_1HMMState_html_ab0820720d752a7d95f2b3fbdafaf9241"><div class="ttname"><a href="structSearch_1_1HMMState.html#ab0820720d752a7d95f2b3fbdafaf9241">Search::HMMState::successors</a></div><div class="ttdeci">SuccessorBatchId successors</div><div class="ttdoc">Batch of successor states, managed through a batch-manager in TreeStructure. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00092">TreeStructure.hh:92</a></div></div>
<div class="ttc" id="namespaceSearch_html_a0f0cff107c7f9e71d4f2d77efb631ffa"><div class="ttname"><a href="namespaceSearch.html#a0f0cff107c7f9e71d4f2d77efb631ffa">Search::SuccessorBatchId</a></div><div class="ttdeci">u32 SuccessorBatchId</div><div class="ttdoc">This index represents an arbitrary list of successor-states and labels. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00036">TreeStructure.hh:36</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_1_1EfficientSingleTargetIterator_html"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork_1_1EfficientSingleTargetIterator.html">Search::HMMStateNetwork::EfficientSingleTargetIterator</a></div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00139">TreeStructure.hh:139</a></div></div>
<div class="ttc" id="structSearch_1_1StateTree_1_1StateDesc_html"><div class="ttname"><a href="structSearch_1_1StateTree_1_1StateDesc.html">Search::StateTree::StateDesc</a></div><div class="ttdoc">Description of a state by its mixture index and its transition model. </div><div class="ttdef"><b>Definition:</b> <a href="StateTree_8hh_source.html#l00124">StateTree.hh:124</a></div></div>
<div class="ttc" id="classTools_1_1BatchIndexIterator_html"><div class="ttname"><a href="classTools_1_1BatchIndexIterator.html">Tools::BatchIndexIterator</a></div><div class="ttdef"><b>Definition:</b> <a href="BatchManager_8hh_source.html#l00156">BatchManager.hh:156</a></div></div>
<div class="ttc" id="namespaceSearch_html_ad5b661f14c566570312f3dd56d120dee"><div class="ttname"><a href="namespaceSearch.html#ad5b661f14c566570312f3dd56d120dee">Search::StateId</a></div><div class="ttdeci">u32 StateId</div><div class="ttdoc">Index of a state or label (see IS_LABEL, ID_FROM_LABEL, and LABEL_FROM_ID) </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00049">TreeStructure.hh:49</a></div></div>
<div class="ttc" id="namespaceSearch_html_ac3db4fa1c38a3c0e7e9a3979f50f0fc5"><div class="ttname"><a href="namespaceSearch.html#ac3db4fa1c38a3c0e7e9a3979f50f0fc5">Search::LABEL_FROM_ID</a></div><div class="ttdeci">inline_ u32 LABEL_FROM_ID(StateId x)</div><div class="ttdoc">Encodes the given index as an edge-successor so that it represents a label. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00068">TreeStructure.hh:68</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_html_aee8e09739248045b5ab407324e9e11db"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork.html#aee8e09739248045b5ab407324e9e11db">Search::HMMStateNetwork::batchSuccessorsSimple</a></div><div class="ttdeci">std::pair&lt; int, int &gt; batchSuccessorsSimple(SuccessorBatchId list) const </div><div class="ttdoc">Returns -1, -1 if this simple version does not work. Then &quot;edgeTargets&quot; has to be used...</div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00444">TreeStructure.hh:444</a></div></div>
<div class="ttc" id="classCore_1_1MappedArchiveWriter_html"><div class="ttname"><a href="classCore_1_1MappedArchiveWriter.html">Core::MappedArchiveWriter</a></div><div class="ttdef"><b>Definition:</b> <a href="MappedArchive_8hh_source.html#l00395">MappedArchive.hh:395</a></div></div>
<div class="ttc" id="structSearch_1_1HMMStateNetwork_1_1SuccessorIterator_html"><div class="ttname"><a href="structSearch_1_1HMMStateNetwork_1_1SuccessorIterator.html">Search::HMMStateNetwork::SuccessorIterator</a></div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00127">TreeStructure.hh:127</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_html_a8729ac3a832d41e2aa32723596f4154a"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork.html#a8729ac3a832d41e2aa32723596f4154a">Search::HMMStateNetwork::batchNodeRange</a></div><div class="ttdeci">std::pair&lt; int, int &gt; batchNodeRange(SuccessorBatchId batch) const </div><div class="ttdoc">Reads out the node-range associated to the given batch. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00467">TreeStructure.hh:467</a></div></div>
<div class="ttc" id="namespaceSearch_html_aa02a40bad1cbff39ab5efd9bcfd80e9fad646ab382f6afce3c2703c5c0663984c"><div class="ttname"><a href="namespaceSearch.html#aa02a40bad1cbff39ab5efd9bcfd80e9fad646ab382f6afce3c2703c5c0663984c">Search::SingleSuccessorBatchMask</a></div><div class="ttdoc">When this bitmask set on an SuccessorBatchId, the id represents only one successor (or label)...</div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00041">TreeStructure.hh:41</a></div></div>
<div class="ttc" id="structSearch_1_1HMMState_html_a50e4a83f844ff0802f21c33b76d7cc97"><div class="ttname"><a href="structSearch_1_1HMMState.html#a50e4a83f844ff0802f21c33b76d7cc97">Search::HMMState::hasSingleSuccessor</a></div><div class="ttdeci">inline_ bool hasSingleSuccessor() const </div><div class="ttdoc">Returns true if the label-edges batch represents only one single successor, which can be handled more...</div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00095">TreeStructure.hh:95</a></div></div>
<div class="ttc" id="classTools_1_1BatchManager_html"><div class="ttname"><a href="classTools_1_1BatchManager.html">Tools::BatchManager</a></div><div class="ttdoc">invalidBatch_ is the index that is interpreted as &quot;no batch&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="BatchManager_8hh_source.html#l00514">BatchManager.hh:514</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_html_a8c1d769a106305d2a6cb8bf072811ee3"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork.html#a8c1d769a106305d2a6cb8bf072811ee3">Search::HMMStateNetwork::targetOutputSet</a></div><div class="ttdeci">std::set&lt; uint &gt; targetOutputSet(StateId node) const </div><div class="ttdoc">Convenience function: Returns the set of target outputs of the given tree node. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00369">TreeStructure.hh:369</a></div></div>
<div class="ttc" id="namespaceSearch_html_aaf94240d77ec07d15534b2a7d2d33174"><div class="ttname"><a href="namespaceSearch.html#aaf94240d77ec07d15534b2a7d2d33174">Search::invalidTreeNodeIndex</a></div><div class="ttdeci">static const StateId invalidTreeNodeIndex</div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00052">TreeStructure.hh:52</a></div></div>
<div class="ttc" id="namespaceSearch_html_a9b4630d7f0a64cb3317190d22f0bc2e4"><div class="ttname"><a href="namespaceSearch.html#a9b4630d7f0a64cb3317190d22f0bc2e4">Search::TreeIndex</a></div><div class="ttdeci">u32 TreeIndex</div><div class="ttdoc">Global index of a tree or subtree. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00046">TreeStructure.hh:46</a></div></div>
<div class="ttc" id="structSearch_1_1HMMState_html"><div class="ttname"><a href="structSearch_1_1HMMState.html">Search::HMMState</a></div><div class="ttdoc">The standard network state, representing a state and its successor-links. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00077">TreeStructure.hh:77</a></div></div>
<div class="ttc" id="classCore_1_1HashMap_html"><div class="ttname"><a href="classCore_1_1HashMap.html">Core::HashMap&lt; StateId, StateId &gt;</a></div></div>
<div class="ttc" id="structSearch_1_1HMMState_html_a1d0229123f9e7df05b4dbd7218b7a3ea"><div class="ttname"><a href="structSearch_1_1HMMState.html#a1d0229123f9e7df05b4dbd7218b7a3ea">Search::HMMState::singleSuccessor</a></div><div class="ttdeci">inline_ StateId singleSuccessor() const </div><div class="ttdoc">If hasSingleSuccessor returned true, then this can be used to retrieve the single successor...</div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00100">TreeStructure.hh:100</a></div></div>
<div class="ttc" id="structSearch_1_1Tree_html"><div class="ttname"><a href="structSearch_1_1Tree.html">Search::Tree</a></div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00105">TreeStructure.hh:105</a></div></div>
<div class="ttc" id="classCore_1_1MappedArchiveReader_html"><div class="ttname"><a href="classCore_1_1MappedArchiveReader.html">Core::MappedArchiveReader</a></div><div class="ttdef"><b>Definition:</b> <a href="MappedArchive_8hh_source.html#l00260">MappedArchive.hh:260</a></div></div>
<div class="ttc" id="classSearch_1_1HMMStateNetwork_html_ad5997bd5600bf2336e54b29279f6d205"><div class="ttname"><a href="classSearch_1_1HMMStateNetwork.html#ad5997bd5600bf2336e54b29279f6d205">Search::HMMStateNetwork::getNodeNumber</a></div><div class="ttdeci">u32 getNodeNumber(TreeIndex parent, StateId node)</div><div class="ttdoc">Returns the number of nodes contained by the given parent tree. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00481">TreeStructure.hh:481</a></div></div>
<div class="ttc" id="structSearch_1_1HMMState_html_a4b2e1bde03da6576335841b6a3928db1"><div class="ttname"><a href="structSearch_1_1HMMState.html#a4b2e1bde03da6576335841b6a3928db1">Search::HMMState::stateDesc</a></div><div class="ttdeci">StateTree::StateDesc stateDesc</div><div class="ttdoc">This must be initialized explicitly after creating the state. </div><div class="ttdef"><b>Definition:</b> <a href="TreeStructure_8hh_source.html#l00089">TreeStructure.hh:89</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
